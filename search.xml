<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安装ROS Noetic</title>
    <url>/2020/09/29/2020.9.29/</url>
    <content><![CDATA[<p>有点难受，但是还是入门了，啊，站在一堆门的门口、伸着脖子往里看的感觉真是滑稽</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%97%A5%E5%BF%97/ros_setup.PNG" alt="avatar"></p>
<a id="more"></a>
<h1>在Ubuntu20.04中安装ROS Noetic</h1>
<p>参考：<a href="https://www.jianshu.com/p/1efe8fe41800" target="_blank" rel="noopener">在Ubuntu20.04中安装ROS Noetic - 简书</a></p>
<h2 id="一、安装ROS-Noetic"><a class="header-anchor" href="#一、安装ROS-Noetic">¶</a>一、安装ROS Noetic</h2>
<h3 id="1-安装源"><a class="header-anchor" href="#1-安装源">¶</a>1. 安装源</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main" &gt; /etc/apt/sources.list.d/ros-latest.list'</span><br></pre></td></tr></table></figure>
<h3 id="2-安装KEY"><a class="header-anchor" href="#2-安装KEY">¶</a>2. 安装KEY</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>
<h3 id="3-更新源"><a class="header-anchor" href="#3-更新源">¶</a>3. 更新源</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<h3 id="4-安装-ROS"><a class="header-anchor" href="#4-安装-ROS">¶</a>4. 安装 ROS</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure>
<h3 id="5-环境变量"><a class="header-anchor" href="#5-环境变量">¶</a>5. 环境变量</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "source /opt/ros/noetic/setup.bash" &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="二、安装测试"><a class="header-anchor" href="#二、安装测试">¶</a>二、安装测试</h2>
<h3 id="1-启动"><a class="header-anchor" href="#1-启动">¶</a>1. 启动</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
<h3 id="2-打开小乌龟"><a class="header-anchor" href="#2-打开小乌龟">¶</a>2. 打开小乌龟</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<h3 id="3-键盘控制小乌龟"><a class="header-anchor" href="#3-键盘控制小乌龟">¶</a>3. 键盘控制小乌龟</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年北京市大学生电子设计竞赛初选（一）</title>
    <url>/2020/03/30/2020%E5%B9%B4%E5%8C%97%E4%BA%AC%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E5%88%9D%E9%80%89%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>在整个设计过程中，博主主要负责设计与仿真，报告内容大部分为博主的搭档完成，经得他的同意后，博主将报告整理成这篇博客。</p>
<h2 id="2020年北京市大学生电子设计竞赛初选设计任务书"><a class="header-anchor" href="#2020年北京市大学生电子设计竞赛初选设计任务书">¶</a>2020年北京市大学生电子设计竞赛初选设计任务书</h2>
<blockquote>
<p>主要内容、基本要求、主要参考资料等：<br>
主要内容<br>
1．阅读相关的科技文献。<br>
2．学习使用multisim软件对模拟电路的仿真研究。<br>
3．学会整理和总结设计文档报告。<br>
4．学习如何查找器件手册及相关参数。<br>
技术要求<br>
1）大二组见题目：“2011年全国大学生电子设计竞赛综合测评题目”<br>
2）大三组见题目：“2013年全国大学生电子设计竞赛综合测评题目”<br>
3）仿真电路设计的运放尽量用单电源供电，如果用双电源供电会扣分。<br>
主要参考资料<br>
1．何小艇，电子系统设计，浙江大学出版社，2010年8月<br>
… …</p>
</blockquote>
<a id="more"></a>
<h2 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h2>
<p>  集成运放器上是一种高增益直流放大、直流放大器既能放大变化极其缓慢的直流信号，下限频率可到零；又能放大交流信号，上限频率与普通放大器一样，受限于电路中的电容或电感等电抗性元器件。集成运放和外部反馈网络相配置后，能够在它的输出和输入之间建立起种种特定的函数关系，故而称它为“运算”放大器。<br>
  一般运放电路都是双电源供电，也有的电路是单电源供电的。之所以选择单电源电路，主要是由设计的需求决定的。一方面在模拟和数字混合系统里，选择和数字系统共用电源更方便。另一方面在电池供电的系统中获得多组电源会让系统复杂，提高成本。<br>
  本题目要求实现的基本目标：使用一片通用四运放芯片 LM324组成预设的电路，电路中包括三角波发生器、加法器、滤波器、比较器四个设计模块，每个模块均采用一个运放及其他基本元器件搭建，通过理论计算，最终实现电路要求。</p>
<p><strong>关键词</strong>： 运算放大器LM324、加法器、滤波器、比较器</p>
<h2 id="1-设计方案"><a class="header-anchor" href="#1-设计方案">¶</a>1. 设计方案</h2>
<p>  使用一片通用四运放芯片 LM324 组成电路框图见图 1（a），实现下述功能 ：使用低频信号源产生 $u_{i1}=0.1sin2\pi{f_{0}}t($V$)$ ， $f_{0}=500$Hz 的正弦波信号，加至加法器的输入端，加法器另一输入端加入由自制振荡器产生的信号 $u_{o1}$ ， $u_{o1}$ 如图1（b）所示， $T_1$=0.5ms ，允许$T_1$有±5%的误差。</p>
<div align=center><img width = '600' height ='100' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%871.png"/></div>
<center>（a）</center><br>
<div align=center><img width = '400' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%872.png"/></div>
<center>（b）</center><br>
<p>  图中要求加法器的输出电压 $u_{i2} = 10u_{i1} + u_{o1}$ 。经选频滤波器滤除 $u_{o1}$ 频率分量，选出 $f_0$ 信号为 $u_{o2}$ ， $u_{o2}$ 为峰峰值等于 9V 的正弦信号，用示波器观察无明显失真。 $u_{o2}$ 信号再经比较器后 1kΩ 负载上得到峰峰值为 2V 的输出电压 $u_{o3}$ 。<br>
  电源只能选用 +12V 和 +5V 两种单电源，由稳压电源供给。不得使用额外电源和其它型号运算放大器。<br>
  要求预留 $u_{i1}$，$u_{i2}$，$u_{o1}$，$u_{o2}$和$u_{o3}$ 的测试端子。</p>
<h2 id="2-波形产生电路设计"><a class="header-anchor" href="#2-波形产生电路设计">¶</a>2. 波形产生电路设计</h2>
<h3 id="2-1-三角波发生器及其元件参数设计"><a class="header-anchor" href="#2-1-三角波发生器及其元件参数设计">¶</a>2.1 三角波发生器及其元件参数设计</h3>
<p><strong>初始双电源设计：(图中参数未经修改，不代表实际设计电路)</strong><br><br>
利用负反馈对电容C1进行充电，当$U_+=U_-$时，输出电压反相。则对电容C1左侧结点分析，输出波形近似为三角波。电路设计如图1。</p>
<p>$U_C(t)=U(\infty)+[ U(0_+) - U(\infty)]e^{-t \over R3C1}$<br>
设$U_{sat}(V_{sat})$为运算放大器上升到的理论最大值，则C1左侧结点电压能够上升到的理论最大值为${R1\over R1+R2}U_{sat}$，即为三角波峰值。</p>
<p>三角波周期为：$T=2R3C1ln(1+2{R1 \over R2})$</p>
<div align=center><img width = '400' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%879.png"/></div>
<center>图1. 双电源三角波发生器电路</center><br>
<p><strong>单电源改进方案：(图中参数未经修改，不代表实际设计电路)</strong><br><br>
电路设计如图2.<br>
由 $V_{CC}$ 通过 $R3、R5$ 分压，使 $U_+={R5 \over R3+R5}V_{CC}$<br>
开始仿真时没有三角波与方波出现，整个电路呈现平衡状态，有 $U_+=U_-=U_{OUT}={V_{CC} \over 2}$<br>
如果电路中出现小的波动，导致 $U_+&gt;U_-$ ，则引起强大的正反馈，此时 $U_{OUT}$ 从 ${V_{CC} \over 2}$ 上升至 $V_{sat}$ ,引起一阶RC电路充电。由一阶电路的三要素法列方程解得：<br><br>
三角波周期 $T=2{\tau}ln({V_{sat}-V_{+Low} \over V_{sat}-V_{+High}})=2R1C1ln(1-{R3R5V_{sat} \over (R3R4+R4R5)V_{sat}-R4R5V_{CC}})$<br><br>
三角波峰峰值 $V_{pp}=V_{+High}-V_{+Low}={R3R5V_{sat} \over R3R4+R4R5+R3R5}$<br><br>
其中 $V_{+High}={{V_{CC} \over R3}+{V_{sat} \over R4} \over {1 \over R3}+{1 \over R4}+{1 \over R5}}$， $V_{+Low}={R4R5 \over R4R5+R3(R4+R5)}V_{CC}$<br><br>
同相输入端处波形应为以 $V_{+High}$ 为上限，$V_{+Low}$ 为下限的方波。<br>
由 $T=0.5$ms，$V_{pp}=4$V ，实际 $V_{sat}$ 约为10.94V，经计算和调试可得到满足条件的元件参数。</p>
<div align=center><img width = '400' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8710.png"/></div>
<center>图2. 单电源三角波发生器电路</center><br>
<h3 id="2-2-电路仿真设计及效果"><a class="header-anchor" href="#2-2-电路仿真设计及效果">¶</a>2.2 电路仿真设计及效果</h3>
<p>电路设计如图3. 产生波形如图4.</p>
<div align=center><img width = '400' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8711.png"/></div>
<center>图3</center><br>
<div align=center><img width = '400' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8712.png"/></div>
<center>图4</center><br>
<p>分析：三角波峰峰值在4V附近浮动，误差不超过5% 。周期在0.5ms附近浮动，误差不超过5%。</p>
<h2 id="3-单元设计电路（1）"><a class="header-anchor" href="#3-单元设计电路（1）">¶</a>3. 单元设计电路（1）</h2>
<h3 id="3-1-加法器电路及其元件参数设计"><a class="header-anchor" href="#3-1-加法器电路及其元件参数设计">¶</a>3.1 加法器电路及其元件参数设计</h3>
<p><strong>初始双电源方案：(图中参数未经修改，不代表实际设计电路)</strong><br></p>
<p>电路设计如图5.<br>
由加法器原理知： $u_{i2} = -({R5 \over R3}u_{i1} + {R5 \over R4}u_{o1})$</p>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8713.png"/></div>
<center>图5. 双电源加法器</center><br>
<p><strong>单电源改进方案：(图中参数未经修改，不代表实际设计电路)</strong><br><br>
电路设计如图6.<br>
由 $V_{CC}$ 进行分压，在同相输入端进行信号相加。满足负反馈条件，进行电路分析：<br>
$V_{-}={R1 \over R1+R2}V_{OUT}$， $V_{+}=V_{-}$<br>
由结点电压法可得：<br></p>
$V_{+}={{V_{CC} \over R3}+{V_{in1} \over R4}+{V_{in2} \over R5} \over {1 \over R3}+{1 \over R4}+{1 \over R5}+{1 \over R6}}$， $V_{OUT}=(1+{R2 \over R1})V_{+}$<br>
<p>由 $u_{i2} = 10u_{i1} + u_{o1}$ 经计算和调试可得到满足条件的元件参数。</p>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8714.png"/></div>
<center>图6. 单电源加法器</center><br>
<h3 id="3-2电路仿真设计及效果"><a class="header-anchor" href="#3-2电路仿真设计及效果">¶</a>3.2电路仿真设计及效果</h3>
<p>电路设计如图7. 产生波形如图8.</p>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8715.png"/></div>
<center>图7</center><br>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8716.png"/></div>
<center>图8</center><br>
<p>分析：由于单电源作用，导致该波形中加入了直流信号，使波形抬高，在之后的整体设计中需加入RC高通滤波电路进行隔直流来获得 $u_{i2}$ 。</p>
<h2 id="4-滤波电路设计"><a class="header-anchor" href="#4-滤波电路设计">¶</a>4. 滤波电路设计</h2>
<h3 id="4-1-多种滤波器电路设计对比分析"><a class="header-anchor" href="#4-1-多种滤波器电路设计对比分析">¶</a>4.1 多种滤波器电路设计对比分析</h3>
<p>由题意过滤2kHz三角波，并将500Hz正弦波放大4.5倍，尝试采用不同滤波器进行滤波，观察滤波效果，选择其中最合适的采用。</p>
<h4 id="4-1-1-低通滤波器设计及其效果"><a class="header-anchor" href="#4-1-1-低通滤波器设计及其效果">¶</a>4.1.1 低通滤波器设计及其效果</h4>
<p><strong>采用二阶有源低通滤波器——Sallen-Key滤波器</strong><br><br>
电路设计如图9.</p>
$\dot{A_{u}}={{\dot{U_{o}}} \over {\dot{U_{i}}}}={A_{up} \over 1+(3-A_{up})j{\omega}RC+{(j{\omega}RC)}^2}={A_{up} \over 1-{({f \over f_0})}^2+j{1 \over Q}{\cdot}{f \over f_0}}$
<p>式中 ：<br>
通带电压放大倍数 $A_{up}=1+{R_F \over R1}$<br>
通带截止频率 $f_0={1 \over 2{\pi}RC}Q={1 \over 3-A_{up}}$<br>
效果：经调试，观察波特图和输出波形分析得，此滤波器无法将2kHz得三角波滤除彻底，放大倍数的差值不够大，无法达到所需效果。</p>
<div align=center><img width = '240' height ='160' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8717.png"/></div>
<center>图9. Sallen-Key滤波器</center><br>
<h4 id="4-1-2-带阻滤波器设计及其效果"><a class="header-anchor" href="#4-1-2-带阻滤波器设计及其效果">¶</a>4.1.2 带阻滤波器设计及其效果</h4>
<p><strong>采用双T网络有源带阻滤波器</strong><br><br>
电路设计如图10.</p>
$\dot{A_{u}}={1-{({f \over f_0})}^2 \over 1+(3-A_{up})j{\omega}RC+{(j{\omega}RC)}^2}={A_{up} \over 1-{({f \over f_0})}^2+j2(2-A_{up}){\cdot}{f \over f_0}}={A_{up} \over 1+j{1 \over Q}{\cdot}{f{f_0} \over {f_0}^2-f^2}}$
<p>式中 ：<br>
通带电压放大倍数 $A_{up}=1+{R_F \over R1}$<br>
中心频率 $f_0={1 \over 2{\pi}RC}$ ， $Q={1 \over 2(2-A_{up})}$<br>
效果：经调试，观察波特图和输出波形分析得，此滤波器无法将2kHz得三角波滤除彻底，放大倍数的差值不够大，并且难以将所需波形进行有效放大，依旧无法达到所需效果。</p>
<div align=center><img width = '240' height ='160' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8718.png"/></div>
<center>图10. 双T型网络带阻滤波器</center><br>
<h4 id="4-1-3-无源带阻滤波器-有源二阶低通滤波器的设计及其效果"><a class="header-anchor" href="#4-1-3-无源带阻滤波器-有源二阶低通滤波器的设计及其效果">¶</a>4.1.3 无源带阻滤波器+有源二阶低通滤波器的设计及其效果</h4>
<p>由上述两种滤波器的滤波效果进行分析，单个高通滤波器和带通滤波器效果也无法达到需求。因此考虑可以先用无源带阻滤波器进行对2kHz的三角波进行精准打击滤除，再用有源二阶低通滤波器进行对500Hz的正弦波的放大。<br>
其中有源二阶低通滤波器采用Sallen-Key滤波器，第一级RC电路的电容不接地而改接到输出端，这种接法相当于在二阶有源滤波电路中引入了一个反馈，使输出电压在高频段迅速下降，但在接近于的范围内又不要下降太多，从而有利于改善滤波特性。<br>
设计电路如11.(图中参数未经修改，不代表实际设计电路)（省略输入信号）<br>
利用波特图来观测500HZ和2kHZ频率的分贝差值，同时结合示波器波形确定滤波结果。<br>
根据带阻滤波器和低通滤波器的原理，进行参数的调节，确定合适的滤波电路参数。</p>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8719.png"/></div>
<center>图11. 无源带阻滤波器+有源二阶低通滤波器</center><br>
<h3 id="4-2-电路的仿真设计及效果"><a class="header-anchor" href="#4-2-电路的仿真设计及效果">¶</a>4.2 电路的仿真设计及效果</h3>
<p>电路设计如图12.（省略输入信号）产生波形如图13.</p>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8720.png"/></div>
<center>图12</center><br>
<div align=center><img width = '480' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8721.png"/></div>
<center>图13</center><br>
<div align=center><img width = '240' height ='168' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8722.png"/></div>
<center>图14(a)</center><br>
<div align=center><img width = '240' height ='168' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8723.png"/></div>
<center>图14(b)</center><br>
<p>由波特图（图14）可知，500HZ信号和2kHz信号之间相差约90dB，即可认为滤波完全。<br>
输出正弦波较为完整，峰峰值在9V左右浮动，误差不超过5%。</p>
<h2 id="5-单元电路设计（2）"><a class="header-anchor" href="#5-单元电路设计（2）">¶</a>5. 单元电路设计（2）</h2>
<h3 id="5-1-比较器电路及其元件参数设计"><a class="header-anchor" href="#5-1-比较器电路及其元件参数设计">¶</a>5.1 比较器电路及其元件参数设计</h3>
<p>比较器的输出只有两种可能的状态：高电平或低电平，即输出电压 $u_{o3}$ 要求为峰峰值为2V的方波，由于要求在1kΩ的负载上输出，则电路设计如图15.(图中参数未经修改，不代表实际设计电路)<br>
（省略输入、输出信号）<br>
通过调节R1控制方波的峰峰值为2V，经过计算和调试可得到合适输出波形。</p>
<div align=center><img width = '384' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8724.png"/></div>
<center>图15. 比较器</center><br>
<h3 id="5-2-电路仿真设计及效果"><a class="header-anchor" href="#5-2-电路仿真设计及效果">¶</a>5.2 电路仿真设计及效果</h3>
<p>电路设计如图16（省略输入信号）产生波形如图17.</p>
<div align=center><img width = '384' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8725.png"/></div>
<center>图16</center><br>
<div align=center><img width = '384' height ='336' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%8726.png"/></div>
<center>图17</center><br>
<p>分析：产生较为规整的方波图像，峰峰值在2V左右浮动，误差不超过5%。</p>
<h2 id="6-整体电路仿真及分析"><a class="header-anchor" href="#6-整体电路仿真及分析">¶</a>6. 整体电路仿真及分析</h2>
<h3 id="6-1-整体电路"><a class="header-anchor" href="#6-1-整体电路">¶</a>6.1 整体电路</h3>
<p>将四个分立电路连接在一起，设计电路如图18. 整体电路，电路之间加入耦合电容或RC电路消除电路之间的影响或隔绝直流。四个滤波器可以观察所需的$u_{i1}$端口、$u_{o1}$端口、$u_{i2}$端口、$u_{o2}$端口、$u_{o3}$端口处的波形。</p>
<div align=center><img width = '720' height ='560' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%873.png"/></div>
<center>图18. 整体电路</center><br>
<h3 id="6-2-端口-u-i1"><a class="header-anchor" href="#6-2-端口-u-i1">¶</a>6.2 端口$u_{i1}$</h3>
<p>由于$u_{i1}$端口由低频信号源（函数发生器）产生，所以波形（如图19.）无失真，得到$U_m$=0.1V，$f_0$=500Hz。</p>
<div align=center><img width = '512' height ='448' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%874.png"/></div>
<center>图19</center><br>
<h3 id="6-3-端口-u-o1"><a class="header-anchor" href="#6-3-端口-u-o1">¶</a>6.3 端口$u_{o1}$</h3>
<p>波形近似为三角波，但受整体电路影响，导致该波形（如图20.）略有失真，$U_m$=2V，$f$=2kHz，误差不超过5%。</p>
<div align=center><img width = '512' height ='448' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%875.png"/></div>
<center>图20</center><br>
<h3 id="6-3-端口-u-i2"><a class="header-anchor" href="#6-3-端口-u-i2">¶</a>6.3 端口$u_{i2}$</h3>
<p>经过 $C3$ 和 $R17$ 的高通滤波电路隔绝直流后获得所需波形（如图21.）。由于三角波自身存在失真，该波形与独立电路工作时产生波形相比略有失真。</p>
<div align=center><img width = '512' height ='448' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%876.png"/></div>
<center>图21</center><br>
<h3 id="6-4-端口-u-o2"><a class="header-anchor" href="#6-4-端口-u-o2">¶</a>6.4 端口$u_{o2}$</h3>
<p>波形（如图22.）理论为正弦波，受整体电路影响，部分波形不稳定，峰峰值不固定，在9V上下5%内浮动，周期约为500Hz。</p>
<div align=center><img width = '512' height ='448' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%877.png"/></div>
<center>图22</center><br>
<h3 id="6-5-端口-u-o3"><a class="header-anchor" href="#6-5-端口-u-o3">¶</a>6.5 端口$u_{o3}$</h3>
<p>波形（如图23.）近似为高低电平交替的方波，峰峰值约为2V，误差不超过5%。波形略有失真，部分由于不稳定信号产生毛刺。</p>
<div align=center><img width = '512' height ='448' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%8C%97%E4%BA%AC%E5%B8%82%E7%94%B5%E8%B5%9B%E5%88%9D%E9%80%89/%E5%9B%BE%E7%89%878.png"/></div>
<center>图23</center><br>
<h2 id="7-个人总结"><a class="header-anchor" href="#7-个人总结">¶</a>7. 个人总结</h2>
<p>一、仿真结果与理论分析存在较大差距，需要根据仿真结果来调试电路中的相关参数，从而达到题目所要求的端口条件。在调试参数时，利用理论推导出的公式结合波特图与示波器图像，先做定性分析，后做定量调试，有利于迅速找到问题、解决问题。<br><br>
二、在模块与模块的链接过程中，发现各功能模块的波形会收到其他模块的影响，造成一定程度上的失真，我们给出的处理办法是，在各模块之间加入耦合电容，或者是电阻、电容组成的高通网络作为接口电路。<br><br>
三、运放采用单电源供电，其输出值的范围在电源提供的电压范围之内，此时若想让运放正常工作需要在同相输入端接入直流偏置，可以从给运放供电的单电源直接接电阻分压后接入，抬升输入波形，同时要注意接入直流偏置电阻的大小，避免超过运放工作范围而造成运放输出失真。<br><br>
四、尝试用滞回比较器来改善输出的方波质量，但未能成功，个人认为题目对比较器的功能要求指向不明确。<br><br>
五、对于三角波进入比较器前的处理较为玄学。<br></p>
<hr>
<h2 id="8-参考文献"><a class="header-anchor" href="#8-参考文献">¶</a>8. 参考文献</h2>
<p>[1] 清华大学电子学教研组编 . 杨素行主编 . 模拟电子技术基础简明教程 . 3版 . 北京：高等教育出版社，2006.<br>
[2] 清华大学电子学教研组编 . 童诗白，华成英主编 . 模拟电子技术基础 . 3版 . 北京：高等教育出版社，2001.<br>
[3] Thomas L. Floyd，David M. Buchla. Analog Fundamentals: A Systems Approach. Pearson Education, 2013.</p>
<hr>
]]></content>
      <tags>
        <tag>电子设计竞赛</tag>
        <tag>ANALOG</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:GO Hacking Notes</title>
    <url>/2022/04/16/CSGOHackingNotes/</url>
    <content><![CDATA[<p>学习 CS:GO Hacking 的笔记</p>
<a id="more"></a>
<h2 id="HOOK-技术"><a class="header-anchor" href="#HOOK-技术">¶</a>HOOK 技术</h2>
<p>Hook 技术又被称为钩子技术</p>
<p>在系统没有调用该函数之前，钩子程序就先捕获该消息，钩子函数先得到控制权，这时钩子函数既可以加工处理（改变）该函数的执行行为，还可以强制结束消息的传递</p>
<p>简单来说，Hook 是一种截取信息、更改程序执行流向、添加新功能的技术</p>
<p>通俗来说，就是一条高速公路，我们去追击一个罪犯(要截获的消息或事件)，然后在他要经过的地方提前埋下埋伏，等到罪犯到来时，实现截获，并执行自己的操作</p>
<p>DOS 时代的 Hook 技术是指修改中断向量表中的中断地址，那时操作系统提供的编程接口称为中断服务向量（即中断向量，中断向量是中断服务程序的入口地址），它以数组的形式保存，这就是中断向量表。要捕获一个中断服务程序，首先修改中断向量表中该程序的中断向量，具体是保存原程序中断地址（原中断向量），然后替换为自己函数的地址。这样，当要调用该中断服务程序时，实际调用了自己编写的函数，在该函数中，可以做一些我们需要的工作，然后可以继续通过原中断向量调用原中断服务程序，完成其原有的功能</p>
<p>Windows 下，Hook 技术的方法比较多，常见的 Hook 方法有 Inline Hook、IAT Hook、EAT Hook、Windows 钩子等</p>
<h2 id="Inline-Hook-内联钩子"><a class="header-anchor" href="#Inline-Hook-内联钩子">¶</a>Inline Hook 内联钩子</h2>
<h3 id="Inline-Hook-的原理"><a class="header-anchor" href="#Inline-Hook-的原理">¶</a>Inline Hook 的原理</h3>
<p>API 函数保存在提供的 DLL 文件中，当在程序中调用某个 API 函数并运行程序后，程序会隐式地将 API 函数所在的 DLL 文件加载入进程中，这样，程序就会像调用自己的函数一样调用 API 函数。而 Inline Hook 就是通过一种暴力的方法直接地修改 API 函数在内存中的映像，从而对 API 函数进行 Hook，其方法是，直接使用汇编指令的 jmp 指令将其代码执行流程改变，进而执行自己的代码，使得原来的函数的流程改变了，执行完自己的流程后，可以选择性地继续执行或不执行原来的函数</p>
<p>由于这种方法是在程序流程中直接进行嵌入 jmp 指令来改变流程的，所以才将其称为 Inline Hook</p>
<h3 id="Inline-Hook-的实现"><a class="header-anchor" href="#Inline-Hook-的实现">¶</a>Inline Hook 的实现</h3>
<p>Inline Hook 是在程序中嵌入 jmp 汇编指令后跳转到流程处继续执行的，jmp 指令是一条无条件的跳转指令，其后跟随的参数是要跳转的目的地址，jmp 指令编译为机器码后，其长度为 5 个 byte，前一个字节为 jmp 对应的机器码（E9），后四个字节为目的地址相对于 jmp 指令的下一条指令地址的偏移量，即一个 32 位的偏移量</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">00402260</span>	- E9 1334F411	<span class="keyword">jmp</span> <span class="number">12345678</span> 	<span class="comment">;偏移量为 11 F4 34 13</span></span><br></pre></td></tr></table></figure>
<p>jmp 指令后的偏移量的计算可以使用如下公式：</p>
<p>jmp 后的偏移量 = 目标地址 - jmp 指令的下一条指令的地址 = 目标地址 - jmp 指令的地址 - 5</p>
<p>这样我们就得到了 Inline Hook 的流程：</p>
<ul>
<li>构造跳转指令</li>
<li>在内存中找到要 HOOK 的函数地址，并保存要 HOOK 位置处的前 5 字节</li>
<li>将构造的跳转指令写入需 HOOK 的位置处</li>
<li>当被 HOOK 位置被执行时会跳转到自己的流程执行</li>
<li>如果要执行原来的流程，那么取消 HOOK，也就是还原被修改的字节</li>
<li>执行原来的流程</li>
<li>继续 HOOK 住原来的位置</li>
</ul>
<p>用 C++ 封装一个 Inline Hook 的类，类的头文件与实现文件分别是 ILHook.h 与 ILHook.cpp</p>
<figure class="highlight cpp"><figcaption><span>ILHook.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CILHook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CILHook();				<span class="comment">// 构造函数</span></span><br><span class="line">	~CILHook();				<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hook 函数</span></span><br><span class="line">	<span class="function">BOOL <span class="title">Hook</span><span class="params">(LPSTR pszModuleName,		<span class="comment">// Hook 的模块名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">		  LPSTR pszFuncName,		<span class="comment">// Hook 的 API 函数名称</span></span></span></span><br><span class="line"><span class="function"><span class="params">		  PROC pfnHookFunc)</span></span>;		<span class="comment">// 要替换的函数名称（钩子函数）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取消 Hook 函数</span></span><br><span class="line">	<span class="function">VOID <span class="title">UnHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新进行 Hook 函数</span></span><br><span class="line">	<span class="function">BOOL <span class="title">ReHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PROC m_pfnOrig;				<span class="comment">// 函数地址</span></span><br><span class="line">	BYTE m_bOldBytes[<span class="number">5</span>];			<span class="comment">// 函数入口代码</span></span><br><span class="line">	BYTE m_bNewBytes[<span class="number">5</span>];			<span class="comment">// Inline 代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最重要的函数是 CILHook::Hook，在该成员函数中，首先获得了被 Hook 函数的函数地址，接着保存了被 Hook 函数的前 5 个字节，最后用构造好的跳转指令来修改被 Hook 函数的前 5 个字节的内容</p>
<figure class="highlight cpp"><figcaption><span>ILHook.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ILHook.h"</span></span></span><br><span class="line"></span><br><span class="line">CILHook::CILHook()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 对成员变量的初始化</span></span><br><span class="line">	m_pfnOrig = <span class="literal">NULL</span>;</span><br><span class="line">	ZeroMemory(m_bOldBytes, <span class="number">5</span>);</span><br><span class="line">	ZeroMemory(m_bNewBytes, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CILHook::~CILHook()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 取消 Hook</span></span><br><span class="line">	UnHook();</span><br><span class="line"></span><br><span class="line">	m_pfnOrig = <span class="literal">NULL</span>;</span><br><span class="line">	ZeroMemory(m_bOldBytes, <span class="number">5</span>);</span><br><span class="line">	ZeroMemory(m_bNewBytes, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对指定模块中的函数进行挂钩</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">BOOL <span class="title">CILHook::Hook</span><span class="params">(LPSTR pszModuleName,</span></span></span><br><span class="line"><span class="function"><span class="params">	           LPSTR pszFuncName,		</span></span></span><br><span class="line"><span class="function"><span class="params">	           PROC pfnHookFunc)</span>		</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指定模块中函数的地址</span></span><br><span class="line">	m_pfnOrig = (PROC)GetProcAddress(</span><br><span class="line">				GetModuleHandle(pszModuleName),</span><br><span class="line">				pszFuncName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( m_pfnOrig!= <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 保存该地址处 5 字节的内容</span></span><br><span class="line">		DWORD dwNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ReadProcessMemory(GetCurrentProcess(),	<span class="comment">// 被读取进程（远程进程）的句柄</span></span><br><span class="line">				  m_pfnOrig,		<span class="comment">// 读的（远程进程中）起始地址</span></span><br><span class="line">				  m_bOldBytes,		<span class="comment">// （本地进程中）存放读取数据缓冲区</span></span><br><span class="line">				  <span class="number">5</span>,			<span class="comment">// 一次读取的字节数</span></span><br><span class="line">				  &amp;dwNum);		<span class="comment">// 实际读取的字节数，函数返回时报告</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造 JMP 指令</span></span><br><span class="line">		m_bNewBytes[<span class="number">0</span>] = <span class="string">'\xe9'</span>;		<span class="comment">// jmp Opcode</span></span><br><span class="line">		<span class="comment">// pfnHookFunc 是 Hook 后的目标地址</span></span><br><span class="line">		<span class="comment">// m_pfnOrig 是原来的地址</span></span><br><span class="line">		<span class="comment">// 5 是指令长度</span></span><br><span class="line">		*(DWORD*)(m_bNewBytes + <span class="number">1</span>) = (DWORD)pfnHookFunc - (DWORD)m_pfnOrig - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将构造好的地址写入该地址处</span></span><br><span class="line">		WriteProcessMemory(GetCurrentProcess(),	<span class="comment">// 参数表与 ReadProcessMemory 类似</span></span><br><span class="line">				   m_pfnOrig,</span><br><span class="line">				   m_bNewBytes,</span><br><span class="line">			           <span class="number">5</span>,</span><br><span class="line">			           &amp;dwNum);</span><br><span class="line"></span><br><span class="line">		bRet = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">取消函数的挂钩</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">VOID <span class="title">CILHook::UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( m_pfnOrig != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">		WriteProcessMemory(GetCurrentProcess(),</span><br><span class="line">				   m_pfnOrig,</span><br><span class="line">				   m_bOldBytes,</span><br><span class="line">			           <span class="number">5</span>,</span><br><span class="line">			           &amp;dwNum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">重新对函数进行挂钩</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">BOOL <span class="title">CILHook::ReHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( m_pfnOrig != <span class="literal">NULL</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">		WriteProcessMemory(GetCurrentProcess(),</span><br><span class="line">				   m_pfnOrig,</span><br><span class="line">				   m_bNewBytes,</span><br><span class="line">			           <span class="number">5</span>,</span><br><span class="line">			           &amp;dwNum);</span><br><span class="line">		</span><br><span class="line">		bRet = TRUE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在自己实现的 Hook 函数（要替换的函数，不是上面的 CILHook::Hook）中，如果要调用原来的 API 函数，需要恢复 Inline Hook（恢复 Hook 前的状态，即恢复原来的 5 个字节），否则会进入死循环，在调用完成后，再重新对函数进行 Hook</p>
<p>用于 CSGOhacking 项目的 inline_hook 类</p>
<figure class="highlight cpp"><figcaption><span>inline_hook.hpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jmp xx xx xx xx : 5 bytes</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> byte_length = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">inline_hook</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> uchar = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line">	<span class="keyword">using</span> dword = DWORD;</span><br><span class="line"></span><br><span class="line">	uchar m_original_byte[byte_length];		<span class="comment">// 原始函数处的汇编指令</span></span><br><span class="line">	uchar m_self_byte[byte_length];			<span class="comment">// 我们自己构造需要改写的汇编指令</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_origin_address;				<span class="comment">// 原始函数的地址</span></span><br><span class="line">	<span class="keyword">int</span> m_self_address;				<span class="comment">// 改写函数的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="function">dword <span class="title">motify_memory_attributes</span><span class="params">(<span class="keyword">int</span> address, dword attributes = PAGE_EXECUTE_READWRITE)</span></span></span><br><span class="line"><span class="function">	<span class="comment">// 改变内存的属性</span></span></span><br><span class="line"><span class="function">	<span class="comment">// PAGE_EXECUTE_READWRITE 需要将内存的属性设置为可读可写</span></span></span><br><span class="line"><span class="function">	<span class="comment">// 返回内存原有的属性</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dword old_attributes;</span><br><span class="line">		<span class="comment">// VirtualProtect 是对应 Win32 函数的逻辑包装函数</span></span><br><span class="line">		<span class="comment">// 它会在呼叫处理程序的虚拟位置空间里，变更认可页面区域上的保护</span></span><br><span class="line">		VirtualProtect(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(address),</span><br><span class="line">					   byte_length,</span><br><span class="line">					   attributes,</span><br><span class="line">					   &amp;old_attributes);</span><br><span class="line">		<span class="keyword">return</span> old_attributes;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	构造函数</span></span><br><span class="line"><span class="comment">	用初始化列表初始化</span></span><br><span class="line"><span class="comment">	构造我们编写的跳转汇编指令 bytes，保存原汇编指令 bytes</span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">	inline_hook(<span class="keyword">int</span> origin_address, <span class="keyword">int</span> self_address) :</span><br><span class="line">		m_origin_address(origin_address),</span><br><span class="line">		m_self_address(self_address)</span><br><span class="line">	&#123;</span><br><span class="line">		m_self_byte[<span class="number">0</span>] = <span class="string">'\xe9'</span>;	<span class="comment">// \x 为转义字符，表示十六进制数</span></span><br><span class="line">						<span class="comment">// e9 为汇编指令中的 jmp 指令</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 转移的位移计算</span></span><br><span class="line">		<span class="comment">// 用转移指令的下一条指令的起始地址进行计算</span></span><br><span class="line">		<span class="keyword">int</span> offset = self_address - (origin_address + byte_length);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 构造跳转到我们函数的 byte</span></span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;m_self_byte[<span class="number">1</span>], &amp;offset, byte_length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改内存属性</span></span><br><span class="line">		dword attributes = motify_memory_attributes(origin_address);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 保存原始函数地址的 byte</span></span><br><span class="line">		<span class="built_in">memcpy</span>(m_original_byte, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(origin_address), byte_length);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 恢复内存属性</span></span><br><span class="line">		motify_memory_attributes(origin_address, attributes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">motify_address</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dword attributes = motify_memory_attributes(m_origin_address);</span><br><span class="line">		<span class="comment">// 写入我们构造的 byte 实现 inline hook</span></span><br><span class="line">		<span class="built_in">memcpy</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(m_origin_address), m_self_byte, byte_length);</span><br><span class="line">		motify_memory_attributes(m_origin_address, attributes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">restore_address</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dword attributes = motify_memory_attributes(m_origin_address);</span><br><span class="line">		<span class="comment">// 恢复原始的 byte</span></span><br><span class="line">		<span class="built_in">memcpy</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(m_origin_address), m_original_byte, byte_length);</span><br><span class="line">		motify_memory_attributes(m_origin_address, attributes);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<p>C++ 黑客编程揭秘与防范 : 第三版 / 冀云编著. —— 北京 : 人民邮电出版社，2019.2</p>
<p><a href="https://blog.csdn.net/weixin_43742894/article/details/105244870" target="_blank" rel="noopener">CSDN : 王大碗Dw / Hook技术简介</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>inline hook</tag>
        <tag>Cheats</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 与 STL</title>
    <url>/2022/06/22/C++%E4%B8%8ESTL/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=1" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356307" target="_blank" rel="noopener">课程刷题地址 2020 BIT冬训-C++STL</a><br>
本篇博文为看视频学习时的记录与自己的一些总结<br>
学习笔记合集：<a href="https://cloudplayer.top/2022/06/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">算法入门基础</a></p>
</blockquote>
<a id="more"></a>
<ul>
<li>C++ 与 STL
<ul>
<li>hello world program
<ul>
<li>C 与 C++ 的区别</li>
<li>Visual Studio</li>
<li>hello world</li>
</ul>
</li>
<li>基本数据类型、输入输出</li>
<li>C++ 语法特性
<ul>
<li>新的基本类型 bool</li>
<li>动态开辟内存</li>
<li>引用</li>
<li>函数重载</li>
<li>结构体</li>
<li>C++11 新的特性</li>
</ul>
</li>
<li>C 标准库函数与 C++STL
<ul>
<li>C 标准库常用函数回顾
<ul>
<li>&lt;cstring&gt;</li>
<li>&lt;cmath&gt;</li>
<li>&lt;cstdlib&gt;</li>
<li>&lt;ctime&gt;</li>
<li>&lt;ctype&gt;</li>
</ul>
</li>
<li>C++STL &lt;vector&gt;</li>
<li>C++STL &lt;string&gt;</li>
<li>C++STL &lt;algorithm&gt;
<ul>
<li>sort</li>
<li>其他 algorithm 函数</li>
</ul>
</li>
<li>其他
<ul>
<li>&lt;stack&gt; 栈</li>
<li>&lt;queue&gt; 队列</li>
<li>&lt;set&gt; 集合</li>
<li>&lt;map&gt; 映射</li>
<li>&lt;bitset&gt;</li>
<li>其他中的其他</li>
</ul>
</li>
</ul>
</li>
<li>细节上的一点东西
<ul>
<li>竞赛细节</li>
<li>日常练习</li>
</ul>
</li>
<li>在线评测系统（Online Judge, OJ）</li>
</ul>
</li>
</ul>
<h1>C++ 与 STL</h1>
<h2 id="hello-world-program"><a class="header-anchor" href="#hello-world-program">¶</a>hello world program</h2>
<h3 id="C-与-C-的区别"><a class="header-anchor" href="#C-与-C-的区别">¶</a>C 与 C++ 的区别</h3>
<blockquote>
<p>C：操控一切过程与细节<br>
C++：有一套STL<br>
打ACM用？ C with C++STL</p>
</blockquote>
<h3 id="Visual-Studio"><a class="header-anchor" href="#Visual-Studio">¶</a>Visual Studio</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS   <span class="comment">//从 scanf_s 到 scanf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//这是万能头    but VS 莫得 就用不了 Dev-C++ 或可用</span></span><br></pre></td></tr></table></figure>
<h3 id="hello-world"><a class="header-anchor" href="#hello-world">¶</a>hello world</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">                           <span class="comment">//C：#include&lt;stdio.h&gt; C++：#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;       <span class="comment">//用标准库里的东西：std:: 这里可以是std::cout</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;                        <span class="comment">//C++：cout C：printf</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello world!"</span>&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//这里endl与'\n'在细节上略有不同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                      <span class="comment">//养成return 0;的好习惯</span></span><br><span class="line">&#125;</span><br><span class="line">                                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                   说一下命名：不能与库函数冲突</span></span><br><span class="line"><span class="comment">                                   prev next count &gt;&gt; pre nxt cnt</span></span><br><span class="line"><span class="comment">                                   */</span></span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型、输入输出"><a class="header-anchor" href="#基本数据类型、输入输出">¶</a>基本数据类型、输入输出</h2>
<blockquote>
<p><strong>int</strong><br>
<strong>char</strong><br>
<strong>bool</strong><br>
<strong>char*</strong><br>
<strong>string</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输出就是刚刚的<span class="built_in">cout</span></span><br><span class="line">输入 C++：cin C：scanf         cout用'&lt;&lt;' cin用'&gt;&gt;' 表示数据流的方向</span><br><span class="line">C++里面没有<span class="string">"%d"</span>,<span class="string">"%s"</span>,<span class="string">"%c"</span>：所有标准数据类型都可以用<span class="built_in">cin</span>输入</span><br><span class="line">并不是说C++没有输入输出格式控制，只是在这里并不会讲什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.getline();   <span class="comment">//报错？得是指针！</span></span><br><span class="line">getline();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件输入输出 <span class="built_in">cin</span>判断EOF</span><br><span class="line">C：<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a)!=EOF;</span><br><span class="line">C++：<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>的速度比<span class="built_in">scanf</span>慢不少</span><br><span class="line"><span class="number">1e5</span>以上的数据用<span class="built_in">cin</span>读入可能TLE(Time Limit Exceeded)</span><br><span class="line">此时建议用<span class="built_in">scanf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出小数用<span class="built_in">printf</span>更方便</span><br><span class="line">C++格式输出要用&lt;iomanip&gt;头文件</span><br><span class="line">用<span class="built_in">cout</span>.setprecistion(<span class="keyword">int</span> digit)来修改精度</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-语法特性"><a class="header-anchor" href="#C-语法特性">¶</a>C++ 语法特性</h2>
<h3 id="新的基本类型-bool"><a class="header-anchor" href="#新的基本类型-bool">¶</a>新的基本类型 bool</h3>
<blockquote>
<p>true/false 两个值<br>
<strong>true</strong>：真：非0 / <strong>false</strong>：假：0</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> yes=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(yes) <span class="built_in">puts</span>(<span class="string">"yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"no"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="动态开辟内存"><a class="header-anchor" href="#动态开辟内存">¶</a>动态开辟内存</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++:用<span class="keyword">new</span>来动态开辟内存</span><br><span class="line"><span class="keyword">int</span>* number = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span>* carr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">C:</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">释放内存：<span class="keyword">delete</span>();</span><br><span class="line">平时写题的代码可以不用释放内存。</span><br></pre></td></tr></table></figure>
<p>这位北理的学长说 C++ 不支持变长数组，但C语言支持，想起当时在学校里用 VC++6.0 学C的时候好像也不支持，于是我用VS2019试了试，好像也不行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样，还是有一条清晰的红色波浪线摆在arr[num]的num下边。<br>
但是，此时弹幕大神说到：C99支持Variable Length Array<br>
那么就是说我们可以在C99标准下使用变长数组emmm…<br>
具体参见：<a href="https://www.cnblogs.com/cpoint/p/3368380.html" target="_blank" rel="noopener">C99中的变长数组</a></p>
<h3 id="引用"><a class="header-anchor" href="#引用">¶</a>引用</h3>
<blockquote>
<p>C++中用 <strong>&amp;</strong> 来创建引用，可把其当作不能改变指向对象的指针</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span>        <span class="comment">//在C语言里干不了的经典事件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>引用多数情况下在函数传递参数的时候才会用到，以简化指针的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; a = number;</span><br><span class="line"><span class="keyword">int</span>* b = &amp;number;</span><br></pre></td></tr></table></figure>
<h3 id="函数重载"><a class="header-anchor" href="#函数重载">¶</a>函数重载</h3>
<blockquote>
<p>C++中，函数是以<strong>函数名+参数列表</strong>来区分的<br>
两个函数可以名字相同，但是参数列表和返回值不同</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>函数的部分参数可以缺省，没有提供参数时用缺省值代替</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">0</span>)</span></span>&#123;...&#125;</span><br><span class="line">...</span><br><span class="line">add(<span class="number">1</span>);             <span class="comment">//1,0</span></span><br><span class="line">add(<span class="number">1</span> + <span class="number">2</span>);         <span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a class="header-anchor" href="#结构体">¶</a>结构体</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C:</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>         //<span class="title">C</span>++<span class="title">typedef</span>可省</span></span><br><span class="line"><span class="class">&#123;</span>...&#125;Node;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span>                <span class="comment">//C++struct可省</span></span><br><span class="line"></span><br><span class="line">C++:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    node* next;</span><br><span class="line">&#125;;</span><br><span class="line">node* head;                 <span class="comment">//可以直接使用结构的名字</span></span><br></pre></td></tr></table></figure>
<p>struct中可以加入与结构同名，无返回值的构造函数<br>
在创建struct时会自动调用构造函数<br>
与缺省参数配合使用，使代码更简洁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    node* next;</span><br><span class="line">    node(<span class="keyword">int</span> _number = <span class="number">0</span>, node* _next = <span class="literal">NULL</span>)       <span class="comment">//使用构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        number = _number;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node a = node(<span class="number">0</span>);</span><br><span class="line">    node* b = <span class="keyword">new</span> node(<span class="number">1</span>, &amp;a);</span><br></pre></td></tr></table></figure>
<h3 id="C-11-新的特性"><a class="header-anchor" href="#C-11-新的特性">¶</a>C++11 新的特性</h3>
<p>新型 for 循环：只需给出变量和要迭代的区间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(数据类型 x: 数据集)</span><br><span class="line"><span class="keyword">for</span>(数据类型 &amp;x: 数据集)</span><br></pre></td></tr></table></figure>
<p>auto 自动类型推导</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = v.begin();</span><br><span class="line"><span class="keyword">auto</span> iter = v.begin();</span><br></pre></td></tr></table></figure>
<h2 id="C-标准库函数与-C-STL"><a class="header-anchor" href="#C-标准库函数与-C-STL">¶</a>C 标准库函数与 C++STL</h2>
<blockquote>
<p>C++ 标准库<br>
重点：&lt;vector&gt; &lt;string&gt; &lt;algorithm&gt;<br>
以后：&lt;queue&gt; &lt;stack&gt; &lt;set&gt; &lt;map&gt; &lt;bitset&gt; &lt;functional&gt; &lt;complex&gt;</p>
</blockquote>
<h3 id="C-标准库常用函数回顾"><a class="header-anchor" href="#C-标准库常用函数回顾">¶</a>C 标准库常用函数回顾</h3>
<h4 id="cstring"><a class="header-anchor" href="#cstring">¶</a>&lt;cstring&gt;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;cstring&gt;   <span class="comment">//C Language: &lt;string.h&gt;</span></span><br><span class="line"><span class="built_in">strlen</span>();   <span class="comment">//字符串长度</span></span><br><span class="line"><span class="built_in">strcmp</span>();   <span class="comment">//字符串比较</span></span><br><span class="line"><span class="built_in">strcpy</span>();   <span class="comment">//字符串拷贝</span></span><br><span class="line"><span class="built_in">memset</span>();   <span class="comment">//暴力清空（赋值）</span></span><br><span class="line"><span class="built_in">memcpy</span>();   <span class="comment">//暴力拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----常用初始化函数-----*/</span></span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));    <span class="comment">//0可换为-1、0x3f3f3f3f</span></span><br></pre></td></tr></table></figure>
<p>这些都很基础，应该还是得记一记<br>
废话不多说，直接上文档：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">strlen</span>                                 <span class="comment">//注意strlen与sizeof的区别</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* str )</span></span>;</span><br><span class="line">Parameters: str  -   pointer to the null-terminated byte <span class="built_in">string</span> to be examined</span><br><span class="line">Return value: The length of the null-terminated <span class="built_in">string</span> str.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----strlen与sizeof-----*/</span></span><br><span class="line"><span class="keyword">sizeof</span>运算符指出的是整个数组的长度;</span><br><span class="line"><span class="built_in">strlen</span>返回的是存储在数组中的字符串的长度，而非数组本身长度</span><br><span class="line"><span class="built_in">strlen</span>只计算可见字符，而不会包含结束字符‘\<span class="number">0'</span></span><br><span class="line">存储字符串到字符数组中要求数组长度至少为字符串长度<span class="built_in">strlen</span>+<span class="number">1</span></span><br><span class="line">字符串以‘\<span class="number">0'</span>为结束标志</span><br><span class="line"><span class="comment">/*----------*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strcmp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *lhs, <span class="keyword">const</span> <span class="keyword">char</span> *rhs )</span></span>;</span><br><span class="line">Parameters: lhs, rhs    -   pointers to the null-terminated byte strings to compare</span><br><span class="line">Return value：</span><br><span class="line">Negative value <span class="keyword">if</span> lhs appears before rhs in lexicographical order.  <span class="comment">//小于</span></span><br><span class="line">Zero <span class="keyword">if</span> lhs <span class="keyword">and</span> rhs compare equal.                                  <span class="comment">//等于</span></span><br><span class="line">Positive value <span class="keyword">if</span> lhs appears after rhs in lexicographical order.   <span class="comment">//大于</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">strcpy</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">( <span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src )</span></span>;</span><br><span class="line">Parameters</span><br><span class="line">dest    -   pointer to the character <span class="built_in">array</span> to write to</span><br><span class="line">src     -   pointer to the null-terminated byte <span class="built_in">string</span> to copy from</span><br><span class="line">Return value</span><br><span class="line">dest</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">memset</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memset</span><span class="params">( <span class="keyword">void</span>* dest, <span class="keyword">int</span> ch, <span class="built_in">std</span>::<span class="keyword">size_t</span> count )</span></span>;</span><br><span class="line">Parameters</span><br><span class="line">dest    -   pointer to the object to fill</span><br><span class="line">ch      -   fill byte</span><br><span class="line">count   -   number of bytes to fill</span><br><span class="line">Return value</span><br><span class="line">dest</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">memcpy</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">( <span class="keyword">void</span>* dest, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="built_in">std</span>::<span class="keyword">size_t</span> count )</span></span>;</span><br><span class="line">Parameters</span><br><span class="line">dest    -   pointer to the memory location to copy to</span><br><span class="line">src     -   pointer to the memory location to copy from</span><br><span class="line">count   -   number of bytes to copy</span><br><span class="line">Return value</span><br><span class="line">dest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="cmath"><a class="header-anchor" href="#cmath">¶</a>&lt;cmath&gt;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;cmath&gt;</span><br><span class="line"><span class="built_in">pow</span>(); <span class="built_in">sin</span>(); <span class="built_in">cos</span>(); <span class="built_in">tan</span>();</span><br><span class="line"><span class="built_in">asin</span>(); <span class="built_in">acos</span>(); <span class="built_in">atan</span>(); ...</span><br></pre></td></tr></table></figure>
<h4 id="cstdlib"><a class="header-anchor" href="#cstdlib">¶</a>&lt;cstdlib&gt;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;cstdlib&gt;</span><br><span class="line">qsort();    <span class="comment">//C语言快排</span></span><br><span class="line">rand();     <span class="comment">//随机数</span></span><br><span class="line"><span class="built_in">malloc</span>(); <span class="built_in">free</span>();       <span class="comment">//C语言动态分配内存</span></span><br></pre></td></tr></table></figure>
<h4 id="ctime"><a class="header-anchor" href="#ctime">¶</a>&lt;ctime&gt;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;ctime&gt;</span><br><span class="line">time();</span><br><span class="line"><span class="comment">/*-----From C++ reference-----*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> result = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::asctime(<span class="built_in">std</span>::localtime(&amp;result))</span><br><span class="line">              &lt;&lt; result &lt;&lt; <span class="string">" seconds since the Epoch\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Wed Sep <span class="number">21</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">52</span> <span class="number">2011</span></span><br><span class="line"><span class="number">1316615272</span> seconds since the Epoch</span><br><span class="line"><span class="comment">/*----------------------------*/</span></span><br><span class="line">还可配合随机数使用：</span><br><span class="line"><span class="comment">/*-----From C++ reference-----*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="number">0</span>));   <span class="comment">//use current time as seed for random generator</span></span><br><span class="line">    <span class="keyword">int</span> random_variable = <span class="built_in">std</span>::rand();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Random value on [0 "</span> &lt;&lt; RAND_MAX &lt;&lt; <span class="string">"]: "</span></span><br><span class="line">              &lt;&lt; random_variable &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Possible output:</span><br><span class="line">Random value on [<span class="number">0</span> <span class="number">2147483647</span>]: <span class="number">1373858591</span></span><br><span class="line"><span class="comment">/*----------------------------*/</span></span><br><span class="line"></span><br><span class="line">clock();                        <span class="comment">//程序启动到目前位置的毫秒数</span></span><br></pre></td></tr></table></figure>
<h4 id="ctype"><a class="header-anchor" href="#ctype">¶</a>&lt;ctype&gt;</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;ctype&gt;</span><br><span class="line"><span class="built_in">isdigit</span>();          <span class="comment">//判断字符是否为数字</span></span><br><span class="line"><span class="built_in">isalpha</span>();          <span class="comment">//判断字符是否大小写字母</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="C-STL-vector"><a class="header-anchor" href="#C-STL-vector">¶</a>C++STL &lt;vector&gt;</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr0;           <span class="comment">// 初始化一个 size 为 0 的 vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1[<span class="number">100</span>];      <span class="comment">// 初始化一百个默认值为 0 的元素</span></span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">100</span>];              <span class="comment">// 普通整型数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;    <span class="comment">// 初始化十个值为 1 的元素</span></span><br></pre></td></tr></table></figure>
<p>vector 可以被看成一个“超级数组”<br>
可以像链表一样动态改变长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span>.push_back(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>vector 的遍历（输入）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">list</span>.push_back(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.size(); i++;</span><br></pre></td></tr></table></figure>
<p>与普通的数组类似，vector 也可以使用指针来访问遍历每一个元素，<br>
STL 中的指针被称为迭代器（iterator）</p>
<p>迭代器：遍历容器中数据的对象。对存储于容器中的数据进行处理时，迭代器能按预先定义的顺序从一个成员移向另一个成员。</p>
<p>也就是说，<strong>通过迭代器可以在不了解容器内部原理的情况下遍历容器</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator p1;</span><br><span class="line"><span class="keyword">for</span> (p1 = arr1.begin(); p1 != arr1.end(); p1++)     <span class="comment">//朴实枯燥</span></span><br><span class="line"><span class="comment">//注意arr1.end()为最后一个元素的下一个元素的地址</span></span><br><span class="line"><span class="keyword">for</span> (p = str; *p; p++)                              <span class="comment">//花里胡哨</span></span><br></pre></td></tr></table></figure>
<p>常见操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>.size();        <span class="comment">//获得元素个数          O(1)</span></span><br><span class="line"><span class="comment">// 实际元素个数，不是容量</span></span><br><span class="line"><span class="built_in">list</span>.clear();       <span class="comment">//一键清空              O(n)</span></span><br><span class="line"><span class="built_in">list</span>.empty();       <span class="comment">//是否为空              O(1)</span></span><br><span class="line"><span class="built_in">list</span>.begin();       <span class="comment">//首元素的迭代器        O(1)</span></span><br><span class="line"><span class="built_in">list</span>.end();         <span class="comment">//最后一个的下一个元素   O(1)</span></span><br><span class="line">                    <span class="comment">//（实际并不存在的）</span></span><br><span class="line"><span class="built_in">list</span>.erase(p1);     <span class="comment">//删p1位置              O(n)</span></span><br><span class="line"><span class="built_in">list</span>.push_back();   <span class="comment">//往后加元素            O(1)</span></span><br><span class="line"><span class="built_in">list</span>.pop_back();    <span class="comment">//删最后一个元素        O(1)</span></span><br><span class="line">reverse(<span class="built_in">list</span>.begin(), <span class="built_in">list</span>.end());</span><br><span class="line">                    <span class="comment">// 翻转向量             O(n)</span></span><br></pre></td></tr></table></figure>
<h3 id="C-STL-string"><a class="header-anchor" href="#C-STL-string">¶</a>C++STL &lt;string&gt;</h3>
<p>string 可看成一个特殊的 vector<br>
string $\Longleftarrow$ C 语言字符串<br>
vector $\Longleftarrow$ 普通数组</p>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure>
<p>vector 的操作 string 基本都有<br>
唯一区别是 size 的复杂度<br>
所有参数为字符串的地方既可以是 string<br>
也可以是 C 字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"hello"</span>;</span><br><span class="line">str.length(); str.size();       <span class="comment">// O(n)</span></span><br><span class="line">str.insert(n, <span class="string">"aaa"</span>);           <span class="comment">// 在下标为 n 处插入一个字符或字符串 O(n)</span></span><br><span class="line"><span class="comment">// str.insert(n, 3, 'a');</span></span><br><span class="line">str.insert(str.begin(), <span class="string">'a'</span>);</span><br><span class="line">str.erase(n, m);                <span class="comment">// 删除 string 对象中的子串</span></span><br><span class="line">str.erase(n);                   <span class="comment">// 从 n 开始删到最后</span></span><br><span class="line">str.c_str();                    <span class="comment">// 返回 C 语言字符串，用于 printf O(n)</span></span><br><span class="line">str.append(str2);               <span class="comment">// 把 str2 拼接到 str 后面 O(n)</span></span><br><span class="line">str.compare(str2);              <span class="comment">// strcmp(str, str2);</span></span><br><span class="line">str == str2;                    <span class="comment">// strcmp(str, str2) == 0;</span></span><br><span class="line">str += str;                     <span class="comment">// str.append(str2);</span></span><br><span class="line">str += <span class="string">'a'</span>;                     <span class="comment">// str.push_back('a');</span></span><br></pre></td></tr></table></figure>
<p>可以使用 + 和 += 运算符对 string 对象执行字符串的连接操作，可以用 &lt;、&lt;=、==、!=、 &gt;=、&gt; 运算符比较 string 对象</p>
<p>substr 成员函数可以用于求子串 (n, m);<br>
调用时，若省略 m 或 m 超过了字符串的长度，则求出来的字串就是从下标 n 开始一直到字符串结束的部分</p>
<p>交换两个 string 对象的内容：swap<br>
查找子串位置 find</p>
<p>用 STL 算法操作 string 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"afgcbed"</span>)</span></span>;</span><br><span class="line">sort(s.begin(), s.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;              <span class="comment">// 输出 abcdefg</span></span><br><span class="line">next_permutation(s.begin(), s.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;              <span class="comment">// 输出 abcdegf</span></span><br><span class="line">reverse(s.begin(), s.end());    <span class="comment">// 翻转字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;              <span class="comment">// 输出 fgedcba</span></span><br></pre></td></tr></table></figure>
<h3 id="C-STL-algorithm"><a class="header-anchor" href="#C-STL-algorithm">¶</a>C++STL &lt;algorithm&gt;</h3>
<p>定义了很多经常使用的算法，极大地简化了代码量</p>
<h4 id="sort"><a class="header-anchor" href="#sort">¶</a>sort</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">sort();     <span class="comment">//快排（默认升序）</span></span><br><span class="line"><span class="keyword">void</span> sort&lt;_Ranlt&gt; (<span class="keyword">const</span> _Ranlt_First, <span class="keyword">const</span> _Ranlt_Last)</span><br><span class="line"><span class="comment">//第一个参数是数组的头指针，另一个参数是最后一个元素的下一个元素的指针</span></span><br><span class="line"><span class="comment">//O(nlogn)</span></span><br><span class="line"><span class="comment">/*-------------------------*/</span></span><br><span class="line"><span class="keyword">int</span> arr[] &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">sort(arr, arr + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------*/</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">sort(arr.begin(), arr.end());</span><br></pre></td></tr></table></figure>
<p>和 C 语言 qsort 一样，sort 可以使用自定义的比较函数<br>
比较函数参数是两个待比较变量，返回值是比较的 bool 值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpInt</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">sort(arr.begin(), arr.end(), cmpInt);</span><br></pre></td></tr></table></figure>
<p>内部排序函数是按小于关系来的，排序结果是升序<br>
如果像上图一样按大于关系比较，则可以得到降序的排序结果</p>
<p>自己定义的结构体一定要写比较函数！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point points[<span class="number">1111</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point a, Point b)</span>      <span class="comment">//你可以给自己的结构体钦定一个小于关系</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(points, point + <span class="number">10</span>, cmp);</span><br></pre></td></tr></table></figure>
<p>把刚刚的 cmp 改名成 operator&lt; 后，你就可以像整数一样用小于号来比较两个结构体了<br>
由于 sort 默认使用的是小于关系，sort 默认使用的函数也可以省略不写了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point points[<span class="number">1111</span>];</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Point a, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(points, point + <span class="number">10</span>);</span><br><span class="line">    points[<span class="number">0</span>] &lt; points[<span class="number">111</span>];</span><br></pre></td></tr></table></figure>
<h4 id="其他-algorithm-函数"><a class="header-anchor" href="#其他-algorithm-函数">¶</a>其他 algorithm 函数</h4>
<p>最大最小值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">min(<span class="number">1</span>, <span class="number">2</span>);  max(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
<p>数组最大最小指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">min_element(arr.begin(), arr.end());</span><br><span class="line">max_element(arr.begin(), arr.end());</span><br><span class="line"><span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure>
<p>把数组中第 n 小（n 从 0 开始算）的数放到第 n 个位置<br>
类似快排，并且保证它左边的数比它小，右边的数比它大<br>
即能保证 n 在正确的位置：arr.begin()+n</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nth_element(arr.begin(), arr.begin() + n, arr.end());   <span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure>
<p>交换任意两个同类型变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">swap(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);   <span class="comment">// O(1)</span></span><br></pre></td></tr></table></figure>
<p>反转数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reverse(arr.begin(), arr.end());    <span class="comment">// O(n)</span></span><br></pre></td></tr></table></figure>
<p>在 sort 后用，去重，返回去重后数组的结束指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique();                           <span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">int</span> newLength = unique(arr.begin(), arr.end());</span><br><span class="line"><span class="comment">// newLength 为新数组长度</span></span><br></pre></td></tr></table></figure>
<p>二分查找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExist = binary_search(arr.begin(), arr.end(), value);</span><br><span class="line">binary_search();        <span class="comment">//二分查找</span></span><br><span class="line"><span class="comment">//查找对应元素value是否存在     O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> firstLoc = lower_bound(arr.begin(), arr.end(), <span class="number">2</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> lastLoc = upper_bound(arr.begin(), arr.end(), <span class="number">2</span>);   <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//两个函数都是在做一件事</span></span><br><span class="line"><span class="comment">//如果把一个数插入有序数组，它应该插入到哪一个位置</span></span><br><span class="line"><span class="comment">//lower_bound 返回第一插入位置的指针，upper_bound 返回最后一个位置的指针</span></span><br><span class="line"><span class="comment">//O(logn)</span></span><br></pre></td></tr></table></figure>
<p>next_permutation 与 prev_permutation<br>
用于生成序列的全排列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a, a+<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>若当前调用排列已经达到最大字典序，比如 321，则函数返回 false<br>
可对部分长度全排列</p>
<p><a href="https://blog.csdn.net/sgh666666/article/details/87953158" target="_blank" rel="noopener">next_permutation 的实现</a>：<br>
从最右边开始，两两比较相邻的元素<br>
直至找到右边比左边大的一对，设左边那个为 A<br>
再从最右边开始找比 A 大的第一个元素，设为 B，交换 A 与 B<br>
然后翻转现在 B （之前 A）的位置之后的所有元素<br>
1 3 4 6 5 2 &gt;&gt; 1 3 5 6 4 2 &gt;&gt; 1 3 5 2 4 6</p>
<h3 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h3>
<h4 id="stack-栈"><a class="header-anchor" href="#stack-栈">¶</a>&lt;stack&gt; 栈</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">stack</span>&gt;         <span class="comment">//栈：后进先出</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">sta.push();     <span class="comment">//inserts element at the top</span></span><br><span class="line"><span class="keyword">int</span> topElement = sta.top();     <span class="comment">//accesses the top element</span></span><br><span class="line">sta.pop();      <span class="comment">//removes the top element</span></span><br><span class="line">sta.empty();    <span class="comment">//checks whether the underlying container is empty</span></span><br><span class="line">sta.size();     <span class="comment">//returns the number of elements</span></span><br><span class="line"><span class="comment">//入、出、获取栈顶元素  O(1)</span></span><br></pre></td></tr></table></figure>
<p>stack 操作包括入、出、获取栈顶元素，复杂度都是 O(1)</p>
<p>栈的典型应用：<a href="https://cloudplayer.top/2022/06/22/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">括号匹配问题</a></p>
<h4 id="queue-队列"><a class="header-anchor" href="#queue-队列">¶</a>&lt;queue&gt; 队列</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">queue</span>&gt;         <span class="comment">//队列：先进先出</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push();     <span class="comment">//inserts element at the end</span></span><br><span class="line"><span class="keyword">int</span> frontElement = que.front(); <span class="comment">//access the first element</span></span><br><span class="line"><span class="keyword">int</span> backElement = que.back();   <span class="comment">//access the last element</span></span><br><span class="line">que.pop();      <span class="comment">//removes the first element</span></span><br><span class="line">que.empty();    <span class="comment">//checks whether the underlying container is empty</span></span><br><span class="line">que.size();     <span class="comment">//returns the number of elements</span></span><br><span class="line"><span class="comment">//入、出、获取队列元素  O(1)</span></span><br></pre></td></tr></table></figure>
<p>&lt;queue&gt; 包含 queue 和 priority_queue（优先队列）两种数据结构<br>
二者用法和 stack 完全相同</p>
<p>栈和队列都没有 clear 之类的函数，如果想要清空一个栈或者队列，需要循环调用出栈或出队函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!s.empty()) s.pop();      <span class="comment">// 清空栈</span></span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();      <span class="comment">// 清空队列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::priority_queue             <span class="comment">// 优先队列（排队有优先级） O(n)</span></span><br><span class="line">                                <span class="comment">// 每次取出的是具有最高优先权的元素，即不一定是先进先出</span></span><br></pre></td></tr></table></figure>
<p>优先队列是一种比较重要的数据结构，它本质上是用堆来实现的<br>
可以以 O(log n) 的效率查找一个队列中的最大值或者最小值<br>
其中是最大值还是最小值是根据创建的优先队列的性质来决定的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt; type, container, function &gt;</span><br></pre></td></tr></table></figure>
<p>这三个参数，后面两个可以省略，第一个不可以<br>
其中：<br>
<strong>type</strong>：数据类型<br>
<strong>container</strong>：实现优先队列的底层容器<br>
<strong>function</strong>：元素之间的比较方式<br>
对于 container ，要求必须是数组形式实现的容器<br>
在 STL 中，默认情况下（不加后面两个参数）是以 vector 为容器<br>
以 operator&lt; 为比较方式，所以在只使用第一个参数时，优先队列默认是一个最大堆（大顶堆）<br>
每次输出的堆顶元素是此时堆中的最大元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; que2;</span><br><span class="line">que2.push();</span><br><span class="line"><span class="keyword">int</span> maxElement = que2.top();</span><br><span class="line">que2.pop();</span><br><span class="line">que2.empty();</span><br><span class="line">que2.size();</span><br></pre></td></tr></table></figure>
<p>如果 type 是一个自己写的结构体，不能够直接比较时<br>
这种情况下就需要我们重载运算符，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2)</span><br><span class="line">    <span class="comment">// bool operator &lt; (const T t2) const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> t1.z &lt; t2.z; &#125; <span class="comment">// &#123; return z &lt; t2.z; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="set-集合"><a class="header-anchor" href="#set-集合">¶</a>&lt;set&gt; 集合</h4>
<p>&lt;set&gt; 包含 set（集合）、multiset（多重集）</p>
<p>数学上的集合的三个特征：<br>
确定性（任一元素必须是确定属于或不属于某个集合）<br>
互异性（集合中的元素互不相同）<br>
无序性（集合中的元素没有先后之分）</p>
<p>STL 中的 set 的含义就是集合，它是一个有序的容器，里面的元素都是排序好的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;        <span class="comment">// 集合</span></span><br><span class="line">st.clear();         <span class="comment">// set 的清空</span></span><br><span class="line">st.insert();        <span class="comment">// 插入一个元素，自带去重</span></span><br><span class="line"><span class="comment">// 查询有无元素 x</span></span><br><span class="line"><span class="keyword">int</span> hav = s.count(x);   <span class="comment">// 返回 0 或 1</span></span><br><span class="line">st.find();          <span class="comment">// 查找一个元素并返回迭代器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.find(x);</span><br><span class="line">st.erase();         <span class="comment">// 删除元素</span></span><br><span class="line">st.size();          <span class="comment">// 求集合元素个数</span></span><br><span class="line">st.empty();         <span class="comment">// 判断是否为空集</span></span><br></pre></td></tr></table></figure>
<p>set 用来保存很多很多元素，并能够在 O(logn) 的时间内查找、删除、添加某个元素，效率非常高</p>
<p>set 最主要的用途：自动去重并按升序排序<br>
set 只能通过迭代器（iterator）访问<br>
迭代器的 ++ 和 – 能够在 O(logn) 的时间里找到第一个比它大（小）的数</p>
<p>set 的遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，set 不支持 it &lt; st.end() 的写法，而 vector 支持</span></span><br><span class="line"><span class="comment">// 原因是 vector 是一维的，在地址上是连续的，而 set 是堆结构，在地址上不连续</span></span><br><span class="line"><span class="comment">// 统一写 it != elem.end() 就好啦</span></span><br><span class="line"><span class="comment">// for (auto it = st.begin(); it != st.end(); it++)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = st.begin(); it != st.end(); it++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, *it);</span><br></pre></td></tr></table></figure>
<p>如果想对 set 中的元素降序排列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; st;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>如果 set 中的元素是结构体类型，处理排序问题是应当重载运算符</p>
<p>set 自带去重，而 multiset 允许元素重复，通过 count 可以获得某个元素的数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; mst;  <span class="comment">//多重集</span></span><br><span class="line">mst.insert(<span class="number">1</span>);</span><br><span class="line">mst.insert(<span class="number">1</span>);</span><br><span class="line">mst.count(<span class="number">1</span>);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="map-映射"><a class="header-anchor" href="#map-映射">¶</a>&lt;map&gt; 映射</h4>
<p>&lt;map&gt; 包含的第一个数据结构是 pair<br>
要用到两个相关联的变量时，可以偷懒不写 struct</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; origin;  </span><br><span class="line"><span class="comment">//由任意两种类型构成，自带比较函数，先比第一个元素</span></span><br><span class="line">origin = make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">origin.first == origin.second</span><br><span class="line">origin.swap;    <span class="comment">//返回 swap 的新 pair</span></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line">id = make_pair(<span class="string">"somebody"</span>, <span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; studentHeight;</span><br><span class="line">studentHeight[<span class="string">"小明"</span>] = <span class="number">170</span>;</span><br><span class="line">studentHeight[<span class="string">"小红"</span>] = <span class="number">150</span>;</span><br><span class="line">studentHeight.count(<span class="string">"小明"</span>);        <span class="comment">// 返回 map 中键值等于 k 的元素的个数（1 或 0）</span></span><br><span class="line">studentHeight.find(<span class="string">"小明"</span>);         <span class="comment">// 存在则返回指向该元素的迭代器，否则返回结束地址 end()</span></span><br><span class="line">studentHeight.insert(id);           <span class="comment">// 若插入时键已经存在，则不进行任何操作 </span></span><br><span class="line">studentHeight.erase(<span class="string">"小明"</span>);        <span class="comment">// 删除 map 中键为 k 的元素，返回删除元素的个数（1 或 0）</span></span><br><span class="line">                                    <span class="comment">// 也可以用迭代器 p 当参数，从而删除迭代器 p 所指向的元素</span></span><br><span class="line">studentHeight.clear();              <span class="comment">// 清空 map</span></span><br></pre></td></tr></table></figure>
<p>&lt;map&gt; 的第二个数据结构是 map<br>
map 是一个键值对（key / value）容器，对于迭代器来说，可以修改 value，而不能修改 key。map 会根据 key 自动排序</p>
<p>可以看成一个超级数组，你可以把字符串或者其他类型当成数组的下标，从而获取其中的值<br>
可以用 { } 初始化<br>
插入、查询、删除操作复杂度都是O(logn)<br>
map 内部使用了 pair ，所以你也可以通过 insert 一个 pair 来插入</p>
<p>map 的遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapSample;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span> (iter = mapSample.begin(); iter != mapSample.end(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bitset"><a class="header-anchor" href="#bitset">¶</a>&lt;bitset&gt;</h4>
<p>bitset 是一个只由0和1构成的数组，其占用空间较小<br>
不仅可以和数组一样用下标访问，还可以进行位运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bit&lt;<span class="number">1000</span>&gt; bst;</span><br><span class="line"></span><br><span class="line">bst[<span class="number">0</span>] = <span class="number">1</span>; bst.<span class="built_in">set</span>(<span class="number">0</span>);     <span class="comment">//set: sets bits to true or given value</span></span><br><span class="line">bst[<span class="number">0</span>] = <span class="number">0</span>; bst.reset(<span class="number">0</span>);   <span class="comment">//reset: sets bits to false</span></span><br><span class="line">bst &lt;&lt; <span class="number">1</span>; bst &gt;&gt; <span class="number">1</span>; bst ^= <span class="number">1</span>; bst &amp;= <span class="number">1</span>;</span><br><span class="line">bst.count();                <span class="comment">// 1 的个数</span></span><br><span class="line">bst.to_string();</span><br><span class="line">bst.to_ullong();</span><br></pre></td></tr></table></figure>
<h4 id="其他中的其他"><a class="header-anchor" href="#其他中的其他">¶</a>其他中的其他</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;functional&gt;</span><br><span class="line">&lt;<span class="built_in">complex</span>&gt;</span><br><span class="line">&lt;<span class="built_in">unordered_map</span>&gt;</span><br><span class="line">&lt;<span class="built_in">unordered_set</span>&gt;</span><br></pre></td></tr></table></figure>
<p>以上头文件都不需要记忆，只要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>就能一键包含所有头文件（Visual Studio 除外）</p>
<h2 id="细节上的一点东西"><a class="header-anchor" href="#细节上的一点东西">¶</a>细节上的一点东西</h2>
<h3 id="竞赛细节"><a class="header-anchor" href="#竞赛细节">¶</a>竞赛细节</h3>
<blockquote>
<ol>
<li>1s 时限运算大约 1e8 次，用复杂度算是否超时</li>
<li>估计初始化的常数时间</li>
<li>G++ 在输出 double 时不能用 %lf ，要用 %f，不然会WA到哭</li>
<li>注意多组用例时的EOF、初始化</li>
<li>数据范围及运算结果均在 1e9 以内时，可令：</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>      <span class="comment">//表示无穷大值</span></span><br><span class="line"><span class="built_in">memset</span>(arr, INF, <span class="keyword">sizeof</span>(arr))   <span class="comment">//初始化为无穷大</span></span><br></pre></td></tr></table></figure>
<h3 id="日常练习"><a class="header-anchor" href="#日常练习">¶</a>日常练习</h3>
<p>版本：VS2019</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> INFLL = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//#define memset0(x)</span></span><br><span class="line"><span class="comment">//#define memsetN1(x)</span></span><br><span class="line"><span class="comment">//#define memsetINF(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">"test.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"test.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> startTime = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Time = %dms\n"</span>, clock() - startTime);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="在线评测系统（Online-Judge-OJ）"><a class="header-anchor" href="#在线评测系统（Online-Judge-OJ）">¶</a>在线评测系统（Online Judge, OJ）</h2>
<blockquote>
<p><a href="https://vjudge.net/" target="_blank" rel="noopener">Virtual Judge</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS&amp;&amp;BFS&amp;&amp;图</title>
    <url>/2022/06/22/DFS&amp;&amp;BFS&amp;&amp;%E5%9B%BE/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=9" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356453" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-DFS&amp;&amp;BFS&amp;&amp;图</a> Password: bfshedfsnandubuda(好像并不需要)<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<ul>
<li>DFS&amp;&amp;BFS&amp;&amp;图
<ul>
<li>DFS 与 BFS
<ul>
<li>DFS 类枚举
<ul>
<li>枚举全排列</li>
<li>枚举集合</li>
<li>枚举组合</li>
</ul>
</li>
<li>剪枝初探</li>
<li>二维平面问题
<ul>
<li>迷宫问题</li>
</ul>
</li>
</ul>
</li>
<li>图
<ul>
<li>图的概念</li>
<li>树的概念</li>
<li>图的表示
<ul>
<li>邻接矩阵</li>
<li>邻接表</li>
<li>邻接表的 DFS 与 BFS 操作</li>
</ul>
</li>
<li>其他</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>DFS&amp;&amp;BFS&amp;&amp;图</h1>
<h2 id="DFS-与-BFS"><a class="header-anchor" href="#DFS-与-BFS">¶</a>DFS 与 BFS</h2>
<ul>
<li>你穿越到了异世界，你想要找到这个异世界的一对儿红毛+蓝毛双胞胎女仆，但毕竟人生地不熟，你知道的信息只有：</li>
<li>当前你所在的位置；你所在的位置连接有几条路，以及这些路通向哪里；</li>
<li>现在，你想到达这张图的所有地方，请给出一种不重复的，且便于程序实现的策略。</li>
<li>举个栗子：你初始在 $1$ 号位置。</li>
</ul>
<div align=center><img width = '300' height = '300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/graph_dfs&&bfs.png"/></div>
<ul>
<li>DFS：深度优先搜索——一往无前，有路就走；用递归实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">到了 (位置 P) &#123;</span><br><span class="line">    <span class="keyword">for</span> (每个能走的位置 Q) &#123;</span><br><span class="line">        如果没到过 Q</span><br><span class="line">        到了 (位置 Q)</span><br><span class="line">        记录 Q 到过了</span><br><span class="line">    &#125;</span><br><span class="line">    返回一步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>DFS 序列：1 2 4 6 3 5 7 8</center>
<div align=center><img width = '300' height = '300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/dfs.PNG"/></div>
<ul>
<li>BFS：广度优先搜索——稳中求进，由近及远；用队列实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">重复:</span><br><span class="line">    取出队首的位置 P</span><br><span class="line">    <span class="keyword">for</span> (每个能走到的位置 Q)</span><br><span class="line">        Q 入队</span><br><span class="line">        走到 Q 看看</span><br><span class="line">        返回一步</span><br><span class="line">直到队列为空</span><br></pre></td></tr></table></figure>
<center>BFS 序列：1 2 3 7 8 4 6 5</center>
<div align=center><img width = '300' height = '300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/bfs.PNG"/></div>
<p>DFS 与 BFS 序列都不唯一，这里假设多个选择的时候优先选数字小的</p>
<p>DFS 与 BFS 既是遍历图的方式，也是一种搜索思想</p>
<h3 id="DFS-类枚举"><a class="header-anchor" href="#DFS-类枚举">¶</a>DFS 类枚举</h3>
<ul>
<li>常用到 $vis$ 数组做标记</li>
<li>灵活掌握递归函数的传参很重要</li>
<li>一般可以写成这种形式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DFS(某状态) &#123;</span><br><span class="line">    如果搜出一种结果 返回;</span><br><span class="line">    在所有能做出的选择中: &#123;</span><br><span class="line">        做出该选择并记录该选择做过;</span><br><span class="line">        DFS(选择后的状态);</span><br><span class="line">        取消该选择以及对该选择的记录;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举全排列"><a class="header-anchor" href="#枚举全排列">¶</a>枚举全排列</h4>
<p>全排列的枚举：<br>
输入 $n$，按字典序输出所有 $1$ ~ $n$ 的全排列，$n$ 不超过 $10$<br>
例如：输入 $3$，输出 $\{ 1,2,3 \}$，$\{ 1,3,2 \}$，$\{ 2,1,3 \}$，$\{ 2,3,1 \}$，$\{ 3,1,2 \}$，$\{ 3,2,1 \}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%5d"</span>, ans[i]);</span><br><span class="line">    &#125;<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">12</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == n + <span class="number">1</span>)&#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            dfs(num + <span class="number">1</span>);</span><br><span class="line">            ans.pop_back();</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度 $O(n!)$</li>
<li>next_permutation 很强大！可以生成下一个全排列并判断是否生成了所有 $n!$ 个全排列，但需要定义小于号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        show();</span><br><span class="line">    &#125; <span class="keyword">while</span>( next_permutation(ans.begin(), ans.end()) );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举集合"><a class="header-anchor" href="#枚举集合">¶</a>枚举集合</h4>
<p>集合的枚举：<br>
给一个 $n$ 个元素的集合，输出他的所有子集，$n$ 不超过 $10$<br>
例如：$\{ 1,2,3 \}$ 需要输出 $\{ \}$，$\{ 1 \}$，$\{ 2 \}$，$\{ 3 \}$，$\{ 1,2 \}$，$\{ 1,3 \}$，$\{ 2,3 \}$，$\{ 1,2,3 \}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == n + <span class="number">1</span>)&#123;</span><br><span class="line">        show();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// √</span></span><br><span class="line">    ans.push_back(num);</span><br><span class="line">    dfs(num + <span class="number">1</span>);</span><br><span class="line">    ans.pop_back();</span><br><span class="line">    <span class="comment">// X </span></span><br><span class="line">    dfs(num + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度 $O(2^n)$</li>
<li>可以用位运算来非递归的枚举</li>
</ul>
<h4 id="枚举组合"><a class="header-anchor" href="#枚举组合">¶</a>枚举组合</h4>
<p>组合的枚举：<br>
给一个 $n$ 个元素的集合，输出从该集合中选出 $k$ 个元素的所有方案<br>
例如：$\{ 1,2,3 \}$ 中选两个需要输出 $\{ 1,2 \}$，$\{ 1,3 \}$，$\{ 2,3 \}$</p>
<ul>
<li>时间复杂度 $O(n^k)$</li>
<li>类似全排列，在 DFS 函数的判断终止条件处改一下即可</li>
</ul>
<h3 id="剪枝初探"><a class="header-anchor" href="#剪枝初探">¶</a>剪枝初探</h3>
<p>给你一个 $9*9$ 的数独，填了它</p>
<ul>
<li>
<p>V1.0：这不和枚举全排列差不多吗<br>
搜索对象：所有的空位置上试着填 $1$ ~ $9$ 所有的数字<br>
终止条件：无空位置（填满了），判断是否合法</p>
</li>
<li>
<p>V2.0：<strong>可行性剪枝</strong><br>
在 V1.0 的基础上，每填一个数字，check 一次；（不再填 $1$ ~ $9$ 所有的数字，而填当前能合法的数字）<br>
幂小于指数，早剪早享受<br>
搜索对象：所有的空位置上试着填合法的所有的数字<br>
终止条件：无空位置（填满了），那就是答案了</p>
</li>
<li>
<p>V3.0：<strong>排除等效冗余</strong><br>
不用搜所有的空位置，选一个搜就可以了<br>
搜索对象：在某一个空位置上试着填合法的所有的数字<br>
终止条件：无空位置（填满了），那就是答案了</p>
</li>
<li>
<p>V4.0：<strong>搜索顺序剪枝</strong><br>
在所有位置中，总是选择合法数字最少的位置来填<br>
一些搜索问题只要求我们找到一组可行解（或可行解唯一，抑或判断是否可行），所以我们争取做到不用搜完所有情况就可以出答案<br>
搜索对象：在合法数字最少的一个空位置上试着填合法的所有数字<br>
终止条件：无空位置（填满了），那就是答案了</p>
</li>
</ul>
<h3 id="二维平面问题"><a class="header-anchor" href="#二维平面问题">¶</a>二维平面问题</h3>
<ul>
<li>利用 $dx[\ ]$, $dy[\ ]$ 这种数组来高效地写 $4$ 方向、$6$ 方向、$8$ 方向的移动</li>
<li>DFS 或 BFS 可以解决一些判断联通、可达的问题；各自有各自的用处</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有 $N*M$ 大小的农田，下雨后积水，格子中 ‘W’ 代表积水，’.’ 代表未积水的土地，每个格子被认为和相邻的 $8$ 个格子相连，一片相互连接的积水叫做 “水WA”，根据农田的航拍图确定有多少个 “水WA”</p>
<h4 id="迷宫问题"><a class="header-anchor" href="#迷宫问题">¶</a>迷宫问题</h4>
<p>给你个只含有障碍和平地的二维迷宫，问你两个点是否互相可达？<br>
问两个点之间的最短距离是多少？<br>
问题一，只要从一个点开始 BFS 看能不能到另外一个就可了<br>
问题二，使用 dis[N][N] 数组（初始化为负无穷）记录所有点到起点之间的最短距离<br>
每次从队列取出一点时，试着更新周围各点距离<br>
当前点：$px$，$py$；周围一点：$xx$，$yy$；则通过这个更新：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dis[xx][yy] = min(dis[xx][yy], dis[px][py] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>为什么 BFS 这样可以找到最短路？<br>
距离关于入列顺序单调不减<br>
入列顺序越靠后的一个点相对于起始点的距离一定不会短于比它在队列中位置靠前的点</p>
<h2 id="图"><a class="header-anchor" href="#图">¶</a>图</h2>
<h3 id="图的概念"><a class="header-anchor" href="#图的概念">¶</a>图的概念</h3>
<p>图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G = (V, E)$<br>
要素：顶点（Vertex）与边（Edge）和边权（Weight）<br>
边分为有向边和无向边</p>
<p>更多的概念：</p>
<blockquote>
<p>顶点 弧 弧尾 弧头 有向图 边 无向图<br>
完全图 有向完全图 稀疏图 稠密图<br>
权 网 子图 邻接点 度 入度 出度<br>
路径 回路（环） 简单路径<br>
连通 连通图 连通分量 强连通图 强连通分量 生成树<br>
自环 重边</p>
</blockquote>
<h3 id="树的概念"><a class="header-anchor" href="#树的概念">¶</a>树的概念</h3>
<p>对于 $n$ 个顶点的无向图：<br>
满足有 $n-1$ 条边且连通，就是树（但是树可以是空树，图不可以是空图）</p>
<p>好的性质：<br>
没有任何环，两点之间简单路径唯一</p>
<h3 id="图的表示"><a class="header-anchor" href="#图的表示">¶</a>图的表示</h3>
<p>图的存储结构：邻接矩阵，邻接表，十字链表，邻接多重表</p>
<h4 id="邻接矩阵"><a class="header-anchor" href="#邻接矩阵">¶</a>邻接矩阵</h4>
<div align=center><img width = '' height = '' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%9B%BE.PNG"/></div>
<ul>
<li>对角线全为 $0$，矩阵对称（无向图）</li>
<li>可能需要初始化</li>
<li>$O(1)$ 判断两点间是否有边</li>
<li>炸空间，存稀疏图有大量无效元素</li>
<li>代码实现：二维数组</li>
</ul>
<h4 id="邻接表"><a class="header-anchor" href="#邻接表">¶</a>邻接表</h4>
<div align=center><img width = '' height = '' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E5%9B%BE.PNG"/></div>
<ul>
<li>每个点要存一个序列，序列长度可能不等</li>
<li>用 vector 实现邻接表</li>
<li>完全可以取代前向星</li>
<li>如果有边权的话，vector 的数据类型设为 pair 或者自定义的结构体 node 即可</li>
</ul>
<h4 id="邻接表的-DFS-与-BFS-操作"><a class="header-anchor" href="#邻接表的-DFS-与-BFS-操作">¶</a>邻接表的 DFS 与 BFS 操作</h4>
<p>BFS 操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    ans.push_back(now);</span><br><span class="line">    vis[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> to : a[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to]) &#123;</span><br><span class="line">            dfs(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS 操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    q.push(st);</span><br><span class="line">    vis[st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to : a[now]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to]) &#123;</span><br><span class="line">                q.push(to);</span><br><span class="line">                vis[to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码（包含 main 函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        a[u].push_back(v);</span><br><span class="line">        a[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dfs or bfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i<span class="number">-1</span>], (i == n) ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, vis[i], (i == n) ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">测试数据：这个图就是本文开头介绍 DFS 与 BFS 用的图</span></span><br><span class="line"><span class="comment">8 8</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">1 8</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="链式前向星"><a class="header-anchor" href="#链式前向星">¶</a>链式前向星</h4>
<p>链式前向星（邻接表的静态数组实现）</p>
<div align=center><img width = '' height = '' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E7%BB%93%E6%9E%84.PNG"/></div>
<ul>
<li>需要初始化为 $-1$</li>
<li>数组从下标为 $1$ 开始用，下标为 $0$ 的空间不用</li>
<li>空间节省</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,s,u,v,w,cnt,head[<span class="number">100005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, dis, next;</span><br><span class="line">&#125;edge[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    edge[++cnt].to=to;</span><br><span class="line">    edge[cnt].dis=w;</span><br><span class="line">    edge[cnt].next=head[from];</span><br><span class="line">    head[from]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    Add_edge(u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历图的所有的边：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每个内循环访问第 i 个顶点出发的所有边</span></span><br><span class="line">    <span class="keyword">for</span>(k=head[i];~k;k=edge[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 得到了 k 值，就可以到 edge 中找到对应边</span></span><br><span class="line">        <span class="comment">// 然后这里就可以做具体的处理过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h3>
<p>DFS 序：<br>
随便选个点 DFS，全过程中依次到达的点的编号组成的序列（同一个点出现一次 or 两次）</p>
<p>树的直径：<br>
树上距离最远的两点，可以通过两次 BFS 求解<br>
先找到树的一个叶结点，一次 BFS 找到一个离该结点最远的一个点 $A$，再以 $A$ 为起始点 BFS 找到离 $A$ 最远的点 $B$，$A$、$B$ 的距离即为树的直径</p>
<p>树的重心：<br>
以该点作为根时，各个子树中点数最多的子树点数最少</p>
<p>关于 DFS 与 BFS 推荐阅读：<a href="https://www.cnblogs.com/wzl19981116/p/9397203.html" target="_blank" rel="noopener">dfs和bfs</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：JupyterLab：程序员的笔记本神器</title>
    <url>/2020/08/14/JupyterLab%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<h1>JupyterLab：程序员的笔记本神器</h1>
<p><br><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-6670fdd5811eb235.webp" alt="avatar"></p>
<center>image</center><br>
<blockquote>
<p>JupyterLab 对于 Jupyter Notebook 有着完全的支持</p>
</blockquote>
<p><code>JupyterLab</code> 是一个交互式的开发环境，是 <code>jupyter notebook</code> 的下一代产品，集成了更多的功能，等其正式版发布，相信那时就是 <code>jupyter notebook</code> 被取代的时候</p>
<a id="more"></a>
<p>通过使用 <code>JupyterLab</code>，能够以灵活，集成和可扩展的方式处理文档和活动：</p>
<ul>
<li>可以开启终端，用于交互式运行代码，完全支持丰富的输出</li>
<li>支持 <code>Markdown</code>，<code>Python</code>，<code>R</code>，<code>LaTeX</code> 等任何文本文件</li>
<li>增强 <code>notebook</code> 功能</li>
<li>更多插件支持</li>
</ul>
<p>如果你在日常生活中，有以下需求，我觉得你可以安装一个 <code>JupyterLab</code></p>
<ul>
<li>随时随地希望试验一些代码片段</li>
<li>多语言、多文档支持</li>
<li>有记笔记需求（文本+代码）</li>
</ul>
<blockquote>
<p>安装</p>
</blockquote>
<p>接下来，我将以 <code>Python</code> 为默认语言来搭建 <code>JupyterLab</code> ，首先确认你安装好了 <code>Python</code> 基本环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一行命令搞定</span></span><br><span class="line">pip install jupyterlab</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装ipython</span></span><br><span class="line">pip install ipython</span><br></pre></td></tr></table></figure>
<p>如果在服务器使用的话，个人建议还是设置一下密码，配置过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入ipython交互环境</span></span><br><span class="line">ipython</span><br></pre></td></tr></table></figure>
<p>生成密码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br><span class="line"><span class="comment"># 输入你自己设置登录JupyterLab界面的密码 然后会有一串输出，记得复制下来，等会配置需要使用</span></span><br></pre></td></tr></table></figure>
<p>修改 <code>JupyterLab</code> 配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter lab --generate-config</span><br></pre></td></tr></table></figure>
<p>修改以下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.allow_root = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span></span><br><span class="line">c.NotebookApp.password = <span class="string">'刚才复制的一串数字粘贴到这里'</span></span><br></pre></td></tr></table></figure>
<p>为了后续能够方便地安装插件，请先安装好 <code>node</code> 环境，假设你安装好，接下来演示一下怎么安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以安装一个生成目录的插件为例</span></span><br><span class="line">jupyter labextension install @jupyterlab/toc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看安装的插件</span></span><br><span class="line">jupyter labextension list</span><br></pre></td></tr></table></figure>
<p>安装完毕后，打开 <code>JupyterLab</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter-lab --ip=0.0.0.0</span><br></pre></td></tr></table></figure>
<p><font color='red'> 这里在命令行使用 jupyter-lab 或 jupyter lab 命令即可 </font></p>
<p>点击 <code>Settings-&gt;Advanced Settings Editor</code>，将 <code>false</code> 改成 <code>true</code>，如下图：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-86ee5941b8645506.webp" alt="avatar"></p>
<center>image</center><br>
<p>此时在界面左侧应该可以看到一个插件管理的图标，点击就可以看到刚才安装的插件</p>
<p>通过这个插件查询功能，你可以很方便的安装插件，安装完成后可以直接热更新，看一下我的 <code>JupyterLab</code> 首页：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-ddbe8be12debaba9.webp" alt="avatar"></p>
<center>image</center><br>
<p>画流程图、写代码、写文档，各种文档渲染、多语言支持，怎么样，有兴趣你也可以搭建一个~</p>
<blockquote>
<p>插件</p>
</blockquote>
<p><code>JupyterLab</code> 目前的插件也算丰富，我目前使用的插件如下：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-4b30d4e26734afe0.webp" alt="avatar"></p>
<center>image</center><br>
<blockquote>
<p>功能</p>
</blockquote>
<p>代码提示：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-8f93294d6359ff61.webp" alt="avatar"></p>
<center>image</center><br>
<p>使用文档提示：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-22c6dfd6a35496d9.webp" alt="avatar"></p>
<center>image</center><br>
<p>支持 <code>vim emacs</code> 等按键风格：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-74e3b503c903a297.webp" alt="avatar"></p>
<center>image</center><br>
<p>文档查看特别方便：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-697abe1cc8a8b5f3.webp" alt="avatar"></p>
<center>image</center><br>
<p>代码以及界面主题设置：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-7139f5f500a34034.webp" alt="avatar"></p>
<center>image</center><br>
<p>文档多窗口：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-13753abc317684a3.webp" alt="avatar"></p>
<center>image</center><br>
<p><code>cell</code> 可以拖拽且输出可以新窗口显示：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-16ea97010a5d0c22.webp" alt="avatar"></p>
<center>image</center><br>
<p>随时启动新的终端交互：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/jupyter/1157824-af69697e4cc2999a.webp" alt="avatar"></p>
<center>image</center><br>
<p>这里只是捡了一些常见的功能说说，更多功能可以查看官方文档来发现，如果你有更好的使用技巧，欢迎交流~</p>
<blockquote>
<p>更多</p>
</blockquote>
<ul>
<li>官方地址：<a href="https://github.com/jupyterlab" target="_blank" rel="noopener">https://github.com/jupyterlab</a></li>
<li>文档：<a href="https://jupyterlab.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://jupyterlab.readthedocs.io/en/stable/</a></li>
<li>插件：<a href="https://github.com/topics/jupyterlab-extension" target="_blank" rel="noopener">https://github.com/topics/jupyterlab-extension</a></li>
</ul>
<hr>
<p>作者：howie6879<br>
链接：<a href="https://www.jianshu.com/p/88feebf3eb3a" target="_blank" rel="noopener">https://www.jianshu.com/p/88feebf3eb3a</a><br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>另有一篇文章可参考：<br>
<a href="https://zhuanlan.zhihu.com/p/87403131" target="_blank" rel="noopener">知乎：JupyterLab，极其强大的下一代notebook！</a></p>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>JupyterLab</tag>
      </tags>
  </entry>
  <entry>
    <title>Getting Started With JUCE</title>
    <url>/2022/04/19/GettingStartedWithJUCE/</url>
    <content><![CDATA[<p>The tutorial is from the following video<br>
<a href="https://www.youtube.com/watch?v=Mo0Oco3Vimo" target="_blank" rel="noopener">C++ Programming Tutorial - Build a 3-Band Compressor Audio Plugin (w/ JUCE Framework)</a><br>
All operations are reproducible</p>
<ul>
<li>Install the IDE (Visual Studio)</li>
<li>Clone JUCE</li>
<li>Build Projucer</li>
<li>Create a project</li>
<li>Create a repository for the project</li>
<li>Build and run the stand-alone app version of the project</li>
<li>Set up Audio Plugin host</li>
<li>Configure our IDE to launch APH whenever we build and run the project</li>
<li>Configure APH so it can load our plugin and set up a FilterGraph so audio will run through our plugin</li>
<li>Set up an AudioFilePlayer plugin so we can play audio files through our plugin</li>
<li>Configure APH to use the AudioFilePlayer plugin to send audio into our plugin and out to the soundcard</li>
<li>Notice: This is a tutorial for windows users. If I have a macbook, Maybe I will supplement the tutorial of MacOS<a id="more"></a></li>
</ul>
<h2 id="Install-the-IDE-Visual-Studio"><a class="header-anchor" href="#Install-the-IDE-Visual-Studio">¶</a>Install the IDE (Visual Studio)</h2>
<p>open your website and search for <strong>visual studio community 2019</strong><br>
go ahead and download it and run the installer<br>
click the <strong>Modify</strong> button<br>
choose the <strong>Desktop development with C++</strong> and set the installation details to set it up for C++ development<br>
just click the <strong>install while downloading</strong> button</p>
<p>This is not the point in this blog so we quickly go to the next step</p>
<h2 id="Clone-JUCE"><a class="header-anchor" href="#Clone-JUCE">¶</a>Clone JUCE</h2>
<p>the first thing<br>
we are going to use fork which is the git gui to interact with the repository<br>
go to <a href="https://fork.dev/" target="_blank" rel="noopener"><strong>fork.dev</strong></a></p>
<div align=center><img width = '400' height = '160' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/fork.PNG"/></div><br>
<p>download fork for windows</p>
<div align=center><img width = '600' height = '360' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/WelcomeToFork.PNG"/></div><br>
<p>launch fork and go to the file menu</p>
<div align=center><img width = '600' height = '400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/ForkPage.PNG"/></div><br>
<p>go to preferences and we need to specify the default clone folder<br>
anything that we clone is going to go into that folder in its own repository<br>
navigate to the JUCE framework and get the url for that<br>
visit <a href="https://github.com/juce-framework/JUCE" target="_blank" rel="noopener"><strong>github.com/juce-framework/JUCE</strong></a><br>
copy the url</p>
<div align=center><img width = '360' height = '300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/CopyUrl.png"/></div><br>
<p>back to fork, choose <strong>file</strong>, then <strong>clone</strong></p>
<div align=center><img width = '600' height = '252' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/cloneJUCE.png"/></div><br>
<p>click the <strong>clone</strong> button and you will be downloading a copy of the JUCE repository to your computer</p>
<div align=center><img width = '600' height = '361' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/AfterCloneJUCE.png"/></div><br>
<p>we want to check the develop branch, not the master branch<br>
just double click the <strong>origin/develop</strong> button and click <strong>Track</strong> button</p>
<div align=center><img width = '600' height = '276' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/developBranch.png"/></div><br>
<p>the next thing to do is to build the Projucer which creates JUCE projects for us</p>
<h2 id="Build-Projucer"><a class="header-anchor" href="#Build-Projucer">¶</a>Build Projucer</h2>
<p>click on this <strong>Open in</strong> and choose <strong>Open In File Explorer</strong></p>
<div align=center><img width = '360' height = '257' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/OpenInFileExplorer.png"/></div><br>
<p>navigate to <strong>extras\Projucer\Builds\VisualStudio2019</strong><br>
open the <strong>Projucer.sln</strong><br>
just go to the build menu and choose <strong>build solution</strong><br>
this is going to build Projucer for us</p>
<div align=center><img width = '600' height = '275' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/BuildSolution.png"/></div><br>
<p>close the visual studio project</p>
<h2 id="Create-a-project"><a class="header-anchor" href="#Create-a-project">¶</a>Create a project</h2>
<p>navigate to <strong>JUCE\extras\Projucer\Builds\VisualStudio2019\x64\Debug\App</strong><br>
open the <strong>Projucer.exe</strong></p>
<div align=center><img width = '600' height = '421' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/JUCEprojucer.PNG"/></div><br>
<p>if this is the first time you are using Projucer it’s going to ask you to sign in<br>
if this is not the first time, go to the file menu<br>
choose <strong>sign in</strong><br>
if you have a JUCE account you can set that up<br>
or you can <strong>Enable GPL Mode</strong><br>
GPL Mode has the requirement that we make our projects open source</p>
<div align=center><img width = '600' height = '400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/EnableGPLMode.png"/></div><br>
<p>go to the file menu and choose <strong>Global Paths</strong><br>
and then customize these paths here</p>
<div align=center><img width = '600' height = '124' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/setPaths.PNG"/></div><br>
<p>back to your Projucer<br>
choose <strong>Basic</strong> in Plug-In and give the name to your project (this project: SimpleMBComp)<br>
set the correct Exporters: Visual Studio 2019<br>
then click the <strong>Create Project…</strong> button<br>
set your project’s folder</p>
<div align=center><img width = '600' height = '420' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/MyNewProject.PNG"/></div><br>
<p>Enabled the <strong>Plugin copy step</strong> if needed</p>
<div align=center><img width = '600' height = '167' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/enableCopyStep.PNG"/></div><br>
<p>Change the C++ language Standard in Project Settings (click the little <strong>Settings</strong> button and you will see it)</p>
<div align=center><img width = '600' height = '189' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/ChangeLanguageStandard.PNG"/></div><br>
<p>change <strong>C++14</strong> to <strong>C++17</strong></p>
<h2 id="Create-a-repository-for-the-project"><a class="header-anchor" href="#Create-a-repository-for-the-project">¶</a>Create a repository for the project</h2>
<p>open fork<br>
click <strong>file</strong>, choose <strong>init new repository</strong><br>
and choose SimpleMBComp folder for the project</p>
<div align=center><img width = '600' height = '361' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/initNewRepository.PNG"/></div><br>
<p>notice that there are a ton of files here<br>
we need to customize the .gitignore file for this project<br>
right click and choose <strong>ignore</strong> and choose <strong>Custom Pattren</strong></p>
<div align=center><img width = '600' height = '362' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/addIgnore.PNG"/></div><br>
<p>Add Pattern to .gitignore</p>
<div align=center><img width = '600' height = '369' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/AddPatternToIgnore.PNG"/></div><br>
<p>you can see we only have the four source files, our .gitignore file and the .jucer file</p>
<div align=center><img width = '600' height = '361' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/afterIgnore.PNG"/></div><br>
<p>we can make our initial commit<br>
let’s stage these by clicking the stage all button (easy to find)<br>
and now committing them</p>
<div align=center><img width = '600' height = '361' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/initialCommit.PNG"/></div>
<h2 id="Build-and-run-the-stand-alone-app-version-of-the-project"><a class="header-anchor" href="#Build-and-run-the-stand-alone-app-version-of-the-project">¶</a>Build and run the stand-alone app version of the project</h2>
<p>back to Projucer<br>
click the <strong>Save and Open in IDE</strong> button (the symbol of Visual Studio)<br>
this will launch visual studio one more time<br>
right click on the StandalonePlugin in the Solution Explorer<br>
and choose <strong>Set as Startup Project</strong></p>
<div align=center><img width = '600' height = '400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/setAsStartupProject.PNG"/></div><br>
<p>now we can build it and run it on this local windows debugger<br>
and this is the default audio plugin from Projucer</p>
<div align=center><img width = '360' height = '321' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/buildStandalonePlugin.PNG"/></div><br>
<p>we need to come up with a test bed so that we can actually run audio through our plugin</p>
<h2 id="Set-up-Audio-Plugin-host"><a class="header-anchor" href="#Set-up-Audio-Plugin-host">¶</a>Set up Audio Plugin host</h2>
<p>let’s set up audio plugin host<br>
navigate to <strong>JUCE\extras\AudioPluginHost</strong> and open the <strong>AudioPluginHost.jucer</strong> file in Projucer (Projucer.exe)</p>
<div align=center><img width = '600' height = '420' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/AudioPluginHost.PNG"/></div><br>
<p>click <strong>Save and Open in IDE</strong><br>
go to the build menu and choose <strong>build solution</strong><br>
build succeeded and we are done with audio plugin host</p>
<div align=center><img width = '600' height = '105' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/BuildAPH.PNG"/></div>
<h2 id="Configure-our-IDE-to-launch-APH-whenever-we-build-and-run-the-project"><a class="header-anchor" href="#Configure-our-IDE-to-launch-APH-whenever-we-build-and-run-the-project">¶</a>Configure our IDE to launch APH whenever we build and run the project</h2>
<p>let’s configure audio plugin host to launch whenever we have the vst3 as to startup project</p>
<p>open your project in Visual Studio<br>
right click on the VST3 target and go down to properties</p>
<div align=center><img width = '600' height = '757' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/setPropertiesInVS.png"/></div><br>
<p>navigate to where it says <strong>debugging</strong> and we’re going to change the <strong>Command</strong><br>
click on this arrow and go to <strong>&lt;Browse…&gt;</strong><br>
and we are going to look for audio plugin host<br>
the position:<br>
<strong>\JUCE\extras\AudioPluginHost\Builds\VisualStudio2019\x64\Debug\App</strong><br>
and we find the <strong>AudioPluginHost.exe</strong><br>
click apply and ok</p>
<div align=center><img width = '600' height = '417' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/ChangesCommand.PNG"/></div><br>
<p>now we need to change the target from standalone to vst3, change that to the startup project<br>
build and run<br>
if you enabled the <strong>Plugin copy step</strong>, it’s going to fail on that copy step</p>
<div align=center><img width = '600' height = '78' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/failOnCopyStep.PNG"/></div><br>
<p>what we need to do is change the permissions of this folder to allow the current user to write in this folder</p>
<p><strong>%CommonProgramW6432%</strong> resolves to <strong>C:Program Files\Common Files</strong><br>
This is where visual studio is trying to copy this file to<br>
navigate to <strong>C:Program Files\Common Files</strong><br>
right click to create new folder called <strong>VST3</strong><br>
right click on this<br>
go to <strong>Properties</strong> and go to <strong>Security</strong><br>
click on <strong>Edit…</strong> to change the permissions for the User to be able to modify</p>
<div align=center><img width = '600' height = '449' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/changePermssions.PNG"/></div><br>
<p>click apply and ok</p>
<p>let’s build and run one more time in Visual Studio<br>
we can see copy step completed</p>
<div align=center><img width = '600' height = '124' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/copyCompleted.PNG"/></div><br>
<p>launch the Juce Plug-In Host</p>
<div align=center><img width = '600' height = '462' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/JucePluginHost.PNG"/></div>
<h2 id="Configure-APH-so-it-can-load-our-plugin-and-set-up-a-FilterGraph-so-audio-will-run-through-our-plugin"><a class="header-anchor" href="#Configure-APH-so-it-can-load-our-plugin-and-set-up-a-FilterGraph-so-audio-will-run-through-our-plugin">¶</a>Configure APH so it can load our plugin and set up a FilterGraph so audio will run through our plugin</h2>
<p>we need to scan for our plugin<br>
choose <strong>options</strong><br>
choose <strong>Edit the List of Available Plug-Ins…</strong><br>
choose <strong>options…</strong><br>
choose <strong>scan for new or updated VST3 plug-ins</strong><br>
Select folders to scan:<br>
<strong>C:Program Files\Common Files\VST3</strong></p>
<div align=center><img width = '600' height = '132' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/scanForPlugin.PNG"/></div><br>
<p>you will find our plugin and now we can load it<br>
right click on your Juce Plug-In Host<br>
find your plugin in yourcompany (you can set your company name in Projucer) and click it</p>
<div align=center><img width = '600' height = '464' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/findedYourPlugin.PNG"/></div><br>
<p>let’s wire it up to the outputs</p>
<div align=center><img width = '360' height = '368' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/wireItUpToTheOutput.PNG"/></div><br>
<p>first we save this and add to our repository</p>
<div align=center><img width = '600' height = '172' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/SaveAndAddToRepository.PNG"/></div><br>
<p>let’s make a commit that we added this</p>
<div align=center><img width = '600' height = '429' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/AddedFGCommit.PNG"/></div>
<h2 id="Set-up-an-AudioFilePlayer-plugin-so-we-can-play-audio-files-through-our-plugin"><a class="header-anchor" href="#Set-up-an-AudioFilePlayer-plugin-so-we-can-play-audio-files-through-our-plugin">¶</a>Set up an AudioFilePlayer plugin so we can play audio files through our plugin</h2>
<p>we are going to set up audio file player so that we can run audio files through our plugin</p>
<p>in MacOS, we can use AUAudioFilePlayer<br>
we need a windows equivalent to this<br>
we can use the audio file player plugin that the tutorial author created</p>
<p>open up your browser<br>
navigate to <a href="https://github.com/matkatmusic/AudioFilePlayer" target="_blank" rel="noopener"><strong>github.com/matkatmusic/AudioFilePlayer</strong></a></p>
<div align=center><img width = '600' height = '249' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/GithubAudioFilePlayer.PNG"/></div><br>
<p>copy the HTTPS to clone<br>
Fork: <strong>File Menu -&gt; clone</strong></p>
<div align=center><img width = '600' height = '255' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/CloneAFP.PNG"/></div><br>
<p>open in file explorer<br>
open up the jucer file<br>
Save and Open in IDE<br>
<strong>Build Solution</strong> to compile the VST3<br>
go back to our project</p>
<h2 id="Configure-APH-to-use-the-AudioFilePlayer-plugin-to-send-audio-into-our-plugin-and-out-to-the-soundcard"><a class="header-anchor" href="#Configure-APH-to-use-the-AudioFilePlayer-plugin-to-send-audio-into-our-plugin-and-out-to-the-soundcard">¶</a>Configure APH to use the AudioFilePlayer plugin to send audio into our plugin and out to the soundcard</h2>
<p>Launch AudioPluginHost by running the project<br>
scan the plugin one more time<br>
Options menu, Edit the List of Available Plugins<br>
Scan for VST3s<br>
load the <strong>AudioFilePlayer</strong></p>
<div align=center><img width = '600' height = '462' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/loadAFP.PNG"/></div><br>
<p>load the audio file</p>
<div align=center><img width = '600' height = '472' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/loadAudioFile.PNG"/></div><br>
<p>save the <strong>.filtergraph</strong> file<br>
make a commit</p>
<div align=center><img width = '600' height = '365' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/JUCE/GettingStartedWithJUCE/makeCommitConfigureTheFGFile.PNG"/></div><br>
<p>And this tutorial about getting started with JUCE ends here</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>JUCE Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 产生伪随机数的一些参考</title>
    <url>/2021/08/12/C++%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<p>我不生产代码，我只是代码的搬运工；<br>
我也不生产文档，只是想替官方文档宣传宣传；<br>
其实我也不写博客，只是拿别人的博客修修改改。<a id="more"></a></p>
<h2 id="C-库伪随机数发生器"><a class="header-anchor" href="#C-库伪随机数发生器">¶</a>C 库伪随机数发生器</h2>
<p>定义于头文件 &lt;cstdlib&gt;<br>
<a href="https://www.apiref.com/cpp-zh/cpp/numeric/random/rand.html" target="_blank" rel="noopener">rand</a> 生成伪随机数(函数)<br>
<a href="https://www.apiref.com/cpp-zh/cpp/numeric/random/srand.html" target="_blank" rel="noopener">srand</a> 初始化伪随机数生成器(函数)<br>
<a href="https://www.apiref.com/cpp-zh/cpp/numeric/random/RAND_MAX.html" target="_blank" rel="noopener">RAND_MAX</a> std::rand 生成的最大可能值(宏常量)</p>
<p><code>rand()</code> 函数无参数，其返回值为 <code>​0</code>​ 与 <code>RAND_MAX</code> （包含 <code>0</code> 与 <code>RAND_MAX</code> ）的随机整数值，保证 <code>RAND_MAX</code> 至少为 <code>32767</code>，<code>rand()</code> 函数内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。<code>rand()</code> 每次执行时是相同的；若要不同，需要用函数 <code>srand()</code> 初始化它。<code>srand()</code> 函数用来设置 <code>rand()</code> 产生随机数时的随机数种子，参数 <code>seed</code> 必须是个整数，未设定随机数种子时，系统默认的随机数种子为 <code>1</code>。</p>
<p>产生随机数的用法</p>
<ol>
<li>
<p>给 <code>srand()</code> 提供一个 <code>unsigned int</code> 类型的种子；</p>
</li>
<li>
<p>调用 <code>rand()</code>，它会根据提供给 <code>srand()</code> 的种子值返回一个随机数(在 <code>0</code> 到 <code>RAND_MAX</code> 之间)；</p>
</li>
<li>
<p>根据需要多次调用 <code>rand()</code>，从而不间断地得到新的随机数；</p>
</li>
<li>
<p>无论什么时候，都可以给 <code>srand()</code> 提供一个新的种子，从而进一步“随机化” <code>rand()</code> 的输出结果。</p>
</li>
</ol>
<p>0~RAND_MAX之间的随机数程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> seed = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// time_t 向 unsigned int 作类型转换</span></span><br><span class="line">	<span class="comment">// time(NULL) 也可作 time(0) 或 time(nullptr)</span></span><br><span class="line">	srand(seed);</span><br><span class="line">	<span class="comment">// 使用当前时钟作为随机数种子每一次运行程序可产生不同的随机数种子			 	</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; rand() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align=left><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/Random_rand.PNG"/></div>
<p>产生一定范围随机数的通用表示公式</p>
<p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;<br>
要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;<br>
要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;<br>
通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。<br>
要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。<br>
要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p>
<p>其实现函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomRangeLeftCloseRightOpen</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (rand() % (b - a)) + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomRangeLeftCloseRightClose</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (rand() % (b - a + <span class="number">1</span>)) + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomRangeLeftOpenRightClose</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (rand() % (b - a)) + a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomIntNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + (<span class="keyword">int</span>)b * rand() / (RAND_MAX + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RandomZeroToOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rand() / <span class="keyword">double</span>(RAND_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-随机数库"><a class="header-anchor" href="#C-随机数库">¶</a>C++ 随机数库</h2>
<p>在 C++11 中引入了 &lt;random&gt; 头文件，功能更完善，可以得到更精确和的随机数，能够更好地解决相关领域问题。这个标准库分为两大部分，分别是：</p>
<ul>
<li>生成器：定义了用来产生均匀分布的伪随机数的机制，也称为随机数引擎。</li>
<li>分布：以生成器得到的均匀分布的随机数序列转换为某种特定数学概率分布的序列，如均匀分布、正态分布、泊松分布等。</li>
</ul>
<h3 id="生成器"><a class="header-anchor" href="#生成器">¶</a>生成器</h3>
<h4 id="random-device"><a class="header-anchor" href="#random-device">¶</a>random_device</h4>
<p>std::random_device 是生成非确定随机数的均匀分布整数随机数生成器，是所有生成器中唯一不需要随机数种子的生成方式。在 Linux 的实现中，是读取 <code>/dev/urandom</code> 设备；在 Windows 的实现中是调用 <code>rand_s</code>。这种生成器基于随机过程来产生均匀分布的随机数序列，可以视为一个真随机数。<br>
<code>random_device</code> 在某些系统中可无法使用，会在构造函数或者调用 <code>operator()</code> 函数时抛出异常，因此对于移植性而言需要格外注意。</p>
<p>成员函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">random_device</span>;</span></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 构造 *****/</span></span><br><span class="line"><span class="comment">// (构造函数) 构造引擎</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 生成 *****/</span></span><br><span class="line"><span class="comment">// operator() 推进引擎状态并返回生成的值，即均匀分布于 [min(), max()] 的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 特征 *****/</span></span><br><span class="line"><span class="comment">// entropy 获得非确定随机数生成器的熵估计(公开成员函数)</span></span><br><span class="line"><span class="comment">// min[静态] 获取输出范围中的最小可能值(公开静态成员函数)</span></span><br><span class="line"><span class="comment">// max[静态] 获取输出范围中的最大可能值(公开静态成员函数)</span></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd.min() &lt;&lt; <span class="string">'\t'</span> &lt;&lt; rd.max() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd() &lt;&lt; <span class="string">'\t'</span> &lt;&lt; rd.entropy() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd() &lt;&lt; <span class="string">'\t'</span> &lt;&lt; rd.entropy() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能的结果</p>
<div align=left><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/Random_device.PNG"/></div>
<p>确定的随机数生成器（例如伪随机数生成器）拥有零熵，之所以此处 <code>rd.entropy()</code> 的值不为 <code>0</code> ，是因为此函数在一些标准库中未完全实现。例如，版本 12 前的 LLVM libc++ 始终返回零，即使设备是非确定的（对于 libstdc++ ，见 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67578" target="_blank" rel="noopener">bug 67578</a> ）。与之相比， Microsoft Visual C++ 实现始终返回 <code>32</code> ，且 boost.random 返回 <code>10</code> 。</p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hist;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">20000</span>; ++n) &#123;</span><br><span class="line">        ++hist[dist(rd)]; <span class="comment">// note: demo only: the performance of many </span></span><br><span class="line">                          <span class="comment">// implementations of random_device degrades sharply</span></span><br><span class="line">                          <span class="comment">// once the entropy pool is exhausted. For practical use</span></span><br><span class="line">                          <span class="comment">// random_device is generally only used to seed </span></span><br><span class="line">                          <span class="comment">// a PRNG such as mt19937</span></span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 注意：仅用于演示：一旦熵池耗尽，</span></span><br><span class="line">                          <span class="comment">// 许多 random_device 实现的性能就急剧下滑</span></span><br><span class="line">                          <span class="comment">// 对于实践使用， random_device 通常仅用于</span></span><br><span class="line">                          <span class="comment">// 播种类似 mt19937 的伪随机数生成器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : hist) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.first &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(p.second/<span class="number">100</span>, <span class="string">'*'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能的结果</p>
<div align=left><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/Random_demo.PNG"/></div>
<h4 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h4>
<p>随机数引擎</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">linear_congruential_engine  <span class="comment">//实现线性同余算法(类模板)</span></span><br><span class="line">mersenne_twister_engine     <span class="comment">//实现梅森缠绕器算法(类模板)</span></span><br><span class="line">subtract_with_carry_engine  <span class="comment">//实现带进位减（一种延迟斐波那契）算法(类模板)</span></span><br></pre></td></tr></table></figure>
<p>随机数引擎适配器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">discard_block_engine        <span class="comment">//舍弃随机数引擎的某些输出(类模板)</span></span><br><span class="line">independent_bits_engine     <span class="comment">//将一个随机数引擎的输出打包为指定位数的块(类模板)</span></span><br><span class="line">shuffle_order_engine        <span class="comment">//以不同顺序发送一个随机数引擎的输出(类模板)</span></span><br></pre></td></tr></table></figure>
<p>预定义随机数生成器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">minstd_rand0</span><br><span class="line">minstd_rand</span><br><span class="line">mt19937</span><br><span class="line">mt19937_64</span><br><span class="line">ranlux24_base</span><br><span class="line">ranlux48_base</span><br><span class="line">ranlux24</span><br><span class="line">ranlux48</span><br><span class="line">knuth_b</span><br><span class="line">default_random_engine</span><br></pre></td></tr></table></figure>
<p>所有生成器引擎都提供如下接口供使用</p>
<ul>
<li>min：返回最小值，静态函数</li>
<li>max：返回最大值，静态函数</li>
<li>seed：设置随机数生成的种子</li>
<li>operator()：产生随机数</li>
<li>void discard (unsigned long long z)：调用z次operator()函数</li>
</ul>
<p>另外，都定义了输入输出操作符和关系运算的非成员函数。<br>
随机数引擎接收一个整数作为种子，不提供就会使用默认值。一般可以使用 <code>chrono</code> 库中的时间或者 <code>random_device</code> 生成一个随机数作为种子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> clock = <span class="built_in">std</span>::chrono::high_resolution_clock;</span><br><span class="line">clock::time_point begin = clock::now();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> seed = begin.time_since_epoch().count();</span><br><span class="line"><span class="function"><span class="built_in">std</span>::minstd_rand0 <span class="title">rand_gen</span><span class="params">(seed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; rand_gen() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="分布"><a class="header-anchor" href="#分布">¶</a>分布</h3>
<p>通过强大的生成器引擎得到了均匀分布的随机数之后，为了满足特定场景的需求，random提供的分布可以以生成器为输入，得到满足不同分布的随机数序列，广义上看，可以认为是对生成器的进一步修饰和包装。主要有三个作用：</p>
<ul>
<li>利用模版参数，改变生成值的类型</li>
<li>利用构造函数参数，改变生成值的区间范围</li>
<li>选择不同的分布得到满足不同分布的随机数序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//均匀分布</span></span><br><span class="line">uniform_int_distribution        <span class="comment">//产生在一个范围上均匀分布的整数值。(类模板)</span></span><br><span class="line">uniform_real_distribution       <span class="comment">//产生在一个范围上均匀分布的实数值。(类模板)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//伯努利分布</span></span><br><span class="line">bernoulli_distribution          <span class="comment">//产生伯努利分布上的 bool 值。(类)</span></span><br><span class="line">binomial_distribution           <span class="comment">//产生二项分布上的整数值。(类模板)</span></span><br><span class="line">negative_binomial_distribution  <span class="comment">//产生负二项分布上的整数值。(类模板)</span></span><br><span class="line">geometric_distribution          <span class="comment">//产生几何分布上的整数值。(类模板)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//泊松分布</span></span><br><span class="line">poisson_distribution            <span class="comment">//产生泊松分布上的整数值。(类模板)</span></span><br><span class="line">exponential_distribution        <span class="comment">//产生指数分布上的实数值。(类模板)</span></span><br><span class="line">gamma_distribution              <span class="comment">//产生 Γ 分布上的实数值。(类模板)</span></span><br><span class="line">weibull_distribution            <span class="comment">//产生威布尔分布上的实数值。(类模板)</span></span><br><span class="line">extreme_value_distribution      <span class="comment">//产生极值分布上的实数值。(类模板)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正态分布</span></span><br><span class="line">normal_distribution             <span class="comment">//产生标准正态（高斯）分布上的实数值。(类模板)</span></span><br><span class="line">lognormal_distribution          <span class="comment">//产生对数正态分布上的实数值。(类模板)</span></span><br><span class="line">chi_squared_distribution        <span class="comment">//产生 χ2 分布上的实数值。(类模板)</span></span><br><span class="line">cauchy_distribution             <span class="comment">//产生柯西分布上的实数值。(类模板)</span></span><br><span class="line">fisher_f_distribution           <span class="comment">//产生费舍尔 F 分布上的实数值。(类模板)</span></span><br><span class="line">student_t_distribution          <span class="comment">//产生学生 t 分布上的实数值。(类模板)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采样分布</span></span><br><span class="line">discrete_distribution           <span class="comment">//产生离散分布上的随机整数。(类模板)</span></span><br><span class="line">piecewise_constant_distribution <span class="comment">//产生分布在常子区间上的实数值。(类模板)</span></span><br><span class="line">piecewise_linear_distribution   <span class="comment">//产生分布在定义的子区间上的实数值。(类模板)</span></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以随机值播种，若可能</span></span><br><span class="line">    <span class="built_in">std</span>::random_device r;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 选择 1 与 6 间的随机数</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::default_random_engine <span class="title">e1</span><span class="params">(r())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">uniform_dist</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> mean = uniform_dist(e1);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Randomly-chosen mean: "</span> &lt;&lt; mean &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 生成围绕平均值的正态分布</span></span><br><span class="line">    <span class="built_in">std</span>::seed_seq seed2&#123;r(), r(), r(), r(), r(), r(), r(), r()&#125;; </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">e2</span><span class="params">(seed2)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::normal_distribution&lt;&gt; <span class="title">normal_dist</span><span class="params">(mean, <span class="number">2</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        ++hist[<span class="built_in">std</span>::round(normal_dist(e2))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Normal distribution around "</span> &lt;&lt; mean &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : hist) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">2</span>)</span><br><span class="line">                  &lt;&lt; p.first &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(p.second/<span class="number">200</span>, <span class="string">'*'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align=left><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/Random_demo1.PNG"/></div>
<h2 id="Random-类的写法参考"><a class="header-anchor" href="#Random-类的写法参考">¶</a>Random 类的写法参考</h2>
<h3 id="Random-h"><a class="header-anchor" href="#Random-h">¶</a>Random.h</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Random</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Seed the generator with the specified int</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> You should generally not need to manually use this</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Seed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get a float between 0.0f and 1.0f</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetFloat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get a float from the specified range</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">GetFloatRange</span><span class="params">(<span class="keyword">float</span> min, <span class="keyword">float</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get an int from the specified range</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetIntRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get a random vector given the min/max bounds</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Math::Vector2 <span class="title">GetVector</span><span class="params">(<span class="keyword">const</span> Math::Vector2&amp; min, <span class="keyword">const</span> Math::Vector2&amp; max)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Math::Vector3 <span class="title">GetVector</span><span class="params">(<span class="keyword">const</span> Math::Vector3&amp; min, <span class="keyword">const</span> Math::Vector3&amp; max)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::mt19937 sGenerator;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	mt19937是c++11中加入的新特性</span></span><br><span class="line"><span class="comment">	它是一种随机数算法，用法与rand()函数类似</span></span><br><span class="line"><span class="comment">	但是具有速度快，周期长的特点(它的名字便来自周期长度：2^19937-1)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Random-cpp"><a class="header-anchor" href="#Random-cpp">¶</a>Random.cpp</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Random.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Random::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::random_device rd;</span><br><span class="line">	Random::Seed(rd());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Random::Seed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sGenerator.seed(seed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Random::GetFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> GetFloatRange(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Random::GetFloatRange</span><span class="params">(<span class="keyword">float</span> min, <span class="keyword">float</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; <span class="title">dist</span><span class="params">(min, max)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> dist(sGenerator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random::GetIntRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(min, max)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> dist(sGenerator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Math::Vector2 <span class="title">Random::GetVector</span><span class="params">(<span class="keyword">const</span> Math::Vector2&amp; min, <span class="keyword">const</span> Math::Vector2&amp; max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Math::Vector2 r = Math::Vector2(GetFloat(), GetFloat());</span><br><span class="line">	<span class="keyword">return</span> min + (max - min) * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Math::Vector3 <span class="title">Random::GetVector</span><span class="params">(<span class="keyword">const</span> Math::Vector3&amp; min, <span class="keyword">const</span> Math::Vector3&amp; max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Math::Vector3 r = Math::Vector3(GetFloat(), GetFloat(), GetFloat());</span><br><span class="line">	<span class="keyword">return</span> min + (max - min) * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mt19937 Random::sGenerator;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<p><a href="https://blog.csdn.net/hgl868/article/details/7057843" target="_blank" rel="noopener">[1] C++ rand,srand用法 / playbar</a></p>
<p><a href="https://blog.csdn.net/u010487568/article/details/51526337" target="_blank" rel="noopener">[2] C++标准库——random / OshynSong</a></p>
<p><a href="https://www.cnblogs.com/egmkang/archive/2012/09/06/2673253.html" target="_blank" rel="noopener">[3] C++11带来的随机数生成器 / egmkang</a></p>
<p><a href="https://en.cppreference.com/w/cpp/numeric/random" target="_blank" rel="noopener">[4] Pseudo-random number generation / C++ reference</a></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>RS232通过modbus协议通信</title>
    <url>/2021/07/01/RS232%E9%80%9A%E8%BF%87modbus%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/luomingui/archive/2013/06/14/Modbus.html" target="_blank" rel="noopener">什么是Modbus？</a></p>
<p>Modbus 协议是应用于电子控制器上的一种通用语言。通过此协议，控制器相互之间、控制器经由网络（例如以太网）和其它设备之间可以通信。Modbus 协议定义了一个控制器能认识使用的消息结构,而不管它们是经过何种网络进行通信的。它描述了一控制器请求访问其它设备的过程，如果回应来自其它设备的请求，以及怎样侦测错误并记录。它制定了消息域格局和内容的公共格式。<a id="more"></a></p>
<p>以下是基于 MCU 为 LPC1768 的具体实现代码。</p>
<h2 id="代码数据类型别名"><a class="header-anchor" href="#代码数据类型别名">¶</a>代码数据类型别名</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************************</span></span><br><span class="line"><span class="comment">  定义与编译器无关的数据类型</span></span><br><span class="line"><span class="comment">************************************************************************************/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  BOOLEAN;                     <span class="comment">/*  布尔变量                    */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>  INT8U;                       <span class="comment">/*  无符号8位整型变量            */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span>   <span class="keyword">char</span>  INT8S;                       <span class="comment">/*  有符号8位整型变量            */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> short INT16U;                      <span class="comment">/*  无符号16位整型变量           */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span>   short INT16S;                      <span class="comment">/*  有符号16位整型变量           */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  INT32U;                      <span class="comment">/*  无符号32位整型变量           */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span>   <span class="keyword">long</span>  INT32S;                      <span class="comment">/*  有符号32位整型变量           */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>          FP32;                        <span class="comment">/*  单精度浮点数（32位长度）      */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>         FP64;                        <span class="comment">/*  双精度浮点数（64位长度）      */</span></span><br></pre></td></tr></table></figure>
<h2 id="变量定义"><a class="header-anchor" href="#变量定义">¶</a>变量定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span>          INT8U        GucRcvBuf[<span class="number">128</span>];        <span class="comment">/* 串口接收数据缓冲区          */</span></span><br><span class="line"><span class="keyword">extern</span>          INT8U        SendBuf[<span class="number">128</span>];          <span class="comment">/* 串口发送数据缓冲区          */</span></span><br><span class="line"><span class="keyword">extern</span>          INT32U       GulNum;                <span class="comment">/* 串口接收数据的个数          */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BPS             9600                   <span class="comment">/* 串口通信波特率              */</span></span></span><br><span class="line">INT8U           GucRcvBuf[<span class="number">128</span>];                     <span class="comment">/* 串口接收数据缓冲区          */</span></span><br><span class="line">INT8U           SendBuf[<span class="number">128</span>];                       <span class="comment">/* 串口发送数据缓冲区          */</span></span><br><span class="line">INT32U          GulNum=<span class="number">0</span>;</span><br><span class="line">INT32U          GucRcvLen;      </span><br><span class="line">INT8U           GucProcessBuf[<span class="number">128</span>];	</span><br><span class="line">INT32U          GucRcvfininshFlag; 	</span><br><span class="line"></span><br><span class="line">INT8U addr=<span class="number">0x01</span>;                <span class="comment">/* 从机地址           */</span> </span><br><span class="line">INT16U CRC16;                   <span class="comment">/* CRC校验码          */</span></span><br><span class="line">INT16U AD[<span class="number">4</span>];                   <span class="comment">/* AD采集数据（4通道） */</span></span><br><span class="line">INT8U start = <span class="number">0x00</span>;             <span class="comment">/* 数据地址起始位      */</span></span><br><span class="line">INT8U len = <span class="number">0</span>;                  <span class="comment">/* 数据个数           */</span> </span><br><span class="line">INT8U Index = <span class="number">3</span>;                <span class="comment">/* 数组下标           */</span></span><br></pre></td></tr></table></figure>
<h2 id="Modbus协议"><a class="header-anchor" href="#Modbus协议">¶</a>Modbus协议</h2>
<p>以下内容来自课程设计资料，设计好的程序通过串口调试助手与modbus从站主站模拟进行调试。</p>
<h3 id="数据报文格式"><a class="header-anchor" href="#数据报文格式">¶</a>数据报文格式</h3>
<h4 id="修改地址（10-功能码）"><a class="header-anchor" href="#修改地址（10-功能码）">¶</a>修改地址（10 功能码）</h4>
<p>（假设将传感器地址修改为：03）</p>
<table>
<thead>
<tr>
<th>广播地址</th>
<th>功能码</th>
<th>起始寄存器地址</th>
<th>寄存器数量</th>
<th>数据</th>
<th>CRC-L</th>
<th>CRC-H</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>10</td>
<td>00 10</td>
<td>00 01</td>
<td>00 03</td>
<td>81</td>
<td>C8</td>
</tr>
</tbody>
</table>
<h4 id="读地址（03-功能码）"><a class="header-anchor" href="#读地址（03-功能码）">¶</a>读地址（03 功能码）</h4>
<p>主机发送（假设从机地址：01）</p>
<table>
<thead>
<tr>
<th>从机地址</th>
<th>功能码</th>
<th>起始寄存器地址</th>
<th>数据长度</th>
<th>CRC-L</th>
<th>CRC-H</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>03</td>
<td>00 02</td>
<td>00 02</td>
<td>C5</td>
<td>E9</td>
</tr>
</tbody>
</table>
<p>从机回应</p>
<table>
<thead>
<tr>
<th>从机地址</th>
<th>功能码</th>
<th>数据区字节数</th>
<th>寄存器数据</th>
<th>CRC-L</th>
<th>CRC-H</th>
</tr>
</thead>
<tbody>
<tr>
<td>01</td>
<td>03</td>
<td>04</td>
<td>41 DE 41 05</td>
<td>AD</td>
<td>F5</td>
</tr>
</tbody>
</table>
<h3 id="CRC校验码"><a class="header-anchor" href="#CRC校验码">¶</a>CRC校验码</h3>
<p>生成 CRC 校验码的程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> INT8U <span class="keyword">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> INT16U <span class="keyword">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CRC 高位字节值表 */</span></span><br><span class="line"><span class="keyword">uint8_t</span> auchCRCHi[] = &#123;</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, </span><br><span class="line"><span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, </span><br><span class="line"><span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, </span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, </span><br><span class="line"><span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, </span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, </span><br><span class="line"><span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, </span><br><span class="line"><span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, <span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xC0</span>, </span><br><span class="line"><span class="number">0x80</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x40</span> </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* CRC 低位字节值表 */</span> </span><br><span class="line"><span class="keyword">uint8_t</span> auchCRCLo[] = &#123; </span><br><span class="line"><span class="number">0x00</span>, <span class="number">0xC0</span>, <span class="number">0xC1</span>, <span class="number">0x01</span>, <span class="number">0xC3</span>, <span class="number">0x03</span>, <span class="number">0x02</span>, <span class="number">0xC2</span>, <span class="number">0xC6</span>, <span class="number">0x06</span>, </span><br><span class="line"><span class="number">0x07</span>, <span class="number">0xC7</span>, <span class="number">0x05</span>, <span class="number">0xC5</span>, <span class="number">0xC4</span>, <span class="number">0x04</span>, <span class="number">0xCC</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0xCD</span>, </span><br><span class="line"><span class="number">0x0F</span>, <span class="number">0xCF</span>, <span class="number">0xCE</span>, <span class="number">0x0E</span>, <span class="number">0x0A</span>, <span class="number">0xCA</span>, <span class="number">0xCB</span>, <span class="number">0x0B</span>, <span class="number">0xC9</span>, <span class="number">0x09</span>, </span><br><span class="line"><span class="number">0x08</span>, <span class="number">0xC8</span>, <span class="number">0xD8</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0xD9</span>, <span class="number">0x1B</span>, <span class="number">0xDB</span>, <span class="number">0xDA</span>, <span class="number">0x1A</span>, </span><br><span class="line"><span class="number">0x1E</span>, <span class="number">0xDE</span>, <span class="number">0xDF</span>, <span class="number">0x1F</span>, <span class="number">0xDD</span>, <span class="number">0x1D</span>, <span class="number">0x1C</span>, <span class="number">0xDC</span>, <span class="number">0x14</span>, <span class="number">0xD4</span>, </span><br><span class="line"><span class="number">0xD5</span>, <span class="number">0x15</span>, <span class="number">0xD7</span>, <span class="number">0x17</span>, <span class="number">0x16</span>, <span class="number">0xD6</span>, <span class="number">0xD2</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0xD3</span>, </span><br><span class="line"><span class="number">0x11</span>, <span class="number">0xD1</span>, <span class="number">0xD0</span>, <span class="number">0x10</span>, <span class="number">0xF0</span>, <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0xF1</span>, <span class="number">0x33</span>, <span class="number">0xF3</span>, </span><br><span class="line"><span class="number">0xF2</span>, <span class="number">0x32</span>, <span class="number">0x36</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0x37</span>, <span class="number">0xF5</span>, <span class="number">0x35</span>, <span class="number">0x34</span>, <span class="number">0xF4</span>, </span><br><span class="line"><span class="number">0x3C</span>, <span class="number">0xFC</span>, <span class="number">0xFD</span>, <span class="number">0x3D</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x3E</span>, <span class="number">0xFE</span>, <span class="number">0xFA</span>, <span class="number">0x3A</span>, </span><br><span class="line"><span class="number">0x3B</span>, <span class="number">0xFB</span>, <span class="number">0x39</span>, <span class="number">0xF9</span>, <span class="number">0xF8</span>, <span class="number">0x38</span>, <span class="number">0x28</span>, <span class="number">0xE8</span>, <span class="number">0xE9</span>, <span class="number">0x29</span>, </span><br><span class="line"><span class="number">0xEB</span>, <span class="number">0x2B</span>, <span class="number">0x2A</span>, <span class="number">0xEA</span>, <span class="number">0xEE</span>, <span class="number">0x2E</span>, <span class="number">0x2F</span>, <span class="number">0xEF</span>, <span class="number">0x2D</span>, <span class="number">0xED</span>, </span><br><span class="line"><span class="number">0xEC</span>, <span class="number">0x2C</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x25</span>, <span class="number">0xE5</span>, <span class="number">0x27</span>, <span class="number">0xE7</span>, <span class="number">0xE6</span>, <span class="number">0x26</span>, </span><br><span class="line"><span class="number">0x22</span>, <span class="number">0xE2</span>, <span class="number">0xE3</span>, <span class="number">0x23</span>, <span class="number">0xE1</span>, <span class="number">0x21</span>, <span class="number">0x20</span>, <span class="number">0xE0</span>, <span class="number">0xA0</span>, <span class="number">0x60</span>, </span><br><span class="line"><span class="number">0x61</span>, <span class="number">0xA1</span>, <span class="number">0x63</span>, <span class="number">0xA3</span>, <span class="number">0xA2</span>, <span class="number">0x62</span>, <span class="number">0x66</span>, <span class="number">0xA6</span>, <span class="number">0xA7</span>, <span class="number">0x67</span>, </span><br><span class="line"><span class="number">0xA5</span>, <span class="number">0x65</span>, <span class="number">0x64</span>, <span class="number">0xA4</span>, <span class="number">0x6C</span>, <span class="number">0xAC</span>, <span class="number">0xAD</span>, <span class="number">0x6D</span>, <span class="number">0xAF</span>, <span class="number">0x6F</span>, </span><br><span class="line"><span class="number">0x6E</span>, <span class="number">0xAE</span>, <span class="number">0xAA</span>, <span class="number">0x6A</span>, <span class="number">0x6B</span>, <span class="number">0xAB</span>, <span class="number">0x69</span>, <span class="number">0xA9</span>, <span class="number">0xA8</span>, <span class="number">0x68</span>, </span><br><span class="line"><span class="number">0x78</span>, <span class="number">0xB8</span>, <span class="number">0xB9</span>, <span class="number">0x79</span>, <span class="number">0xBB</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0xBA</span>, <span class="number">0xBE</span>, <span class="number">0x7E</span>, </span><br><span class="line"><span class="number">0x7F</span>, <span class="number">0xBF</span>, <span class="number">0x7D</span>, <span class="number">0xBD</span>, <span class="number">0xBC</span>, <span class="number">0x7C</span>, <span class="number">0xB4</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0xB5</span>, </span><br><span class="line"><span class="number">0x77</span>, <span class="number">0xB7</span>, <span class="number">0xB6</span>, <span class="number">0x76</span>, <span class="number">0x72</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0x73</span>, <span class="number">0xB1</span>, <span class="number">0x71</span>, </span><br><span class="line"><span class="number">0x70</span>, <span class="number">0xB0</span>, <span class="number">0x50</span>, <span class="number">0x90</span>, <span class="number">0x91</span>, <span class="number">0x51</span>, <span class="number">0x93</span>, <span class="number">0x53</span>, <span class="number">0x52</span>, <span class="number">0x92</span>, </span><br><span class="line"><span class="number">0x96</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x97</span>, <span class="number">0x55</span>, <span class="number">0x95</span>, <span class="number">0x94</span>, <span class="number">0x54</span>, <span class="number">0x9C</span>, <span class="number">0x5C</span>, </span><br><span class="line"><span class="number">0x5D</span>, <span class="number">0x9D</span>, <span class="number">0x5F</span>, <span class="number">0x9F</span>, <span class="number">0x9E</span>, <span class="number">0x5E</span>, <span class="number">0x5A</span>, <span class="number">0x9A</span>, <span class="number">0x9B</span>, <span class="number">0x5B</span>, </span><br><span class="line"><span class="number">0x99</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x98</span>, <span class="number">0x88</span>, <span class="number">0x48</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0x4B</span>, <span class="number">0x8B</span>, </span><br><span class="line"><span class="number">0x8A</span>, <span class="number">0x4A</span>, <span class="number">0x4E</span>, <span class="number">0x8E</span>, <span class="number">0x8F</span>, <span class="number">0x4F</span>, <span class="number">0x8D</span>, <span class="number">0x4D</span>, <span class="number">0x4C</span>, <span class="number">0x8C</span>, </span><br><span class="line"><span class="number">0x44</span>, <span class="number">0x84</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0x87</span>, <span class="number">0x47</span>, <span class="number">0x46</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x42</span>, </span><br><span class="line"><span class="number">0x43</span>, <span class="number">0x83</span>, <span class="number">0x41</span>, <span class="number">0x81</span>, <span class="number">0x80</span>, <span class="number">0x40</span> </span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">crc16HiLo</span><span class="params">(<span class="keyword">uint8_t</span> *puchMsg, <span class="keyword">uint16_t</span> usDataLen)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">uint16_t</span> uchCRCHi = <span class="number">0xFF</span> ;  <span class="comment">/* 高 CRC 字节初始化 */</span> </span><br><span class="line">	<span class="keyword">uint16_t</span> uchCRCLo = <span class="number">0xFF</span> ;  <span class="comment">/* 低 CRC 字节初始化 */</span> </span><br><span class="line">	<span class="keyword">uint16_t</span> uIndex ;           <span class="comment">/* CRC 循环中的索引 */</span> </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> (usDataLen--)         <span class="comment">/* 传输消息缓冲区 */</span> </span><br><span class="line">    &#123;</span><br><span class="line">        uIndex = uchCRCHi ^ (*puchMsg++) ;    <span class="comment">/* 计算 CRC */</span> </span><br><span class="line">        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ; </span><br><span class="line">        uchCRCLo = auchCRCLo[uIndex] ; </span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> (uchCRCHi &lt;&lt; <span class="number">8</span> | uchCRCLo) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UART通用异步收发器配置"><a class="header-anchor" href="#UART通用异步收发器配置">¶</a>UART通用异步收发器配置</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uartInit</span></span><br><span class="line"><span class="comment">** Descriptions:        串口初始化，设置为8位数据位，1位停止位，无奇偶校验，波特率为9600</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT16U ulFdiv;</span><br><span class="line">    </span><br><span class="line">    U0LCR  = <span class="number">0x83</span>;                                  <span class="comment">/*  允许设置波特率              */</span></span><br><span class="line">    ulFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;               <span class="comment">/*  设置波特率                  */</span></span><br><span class="line">    U0DLM  = ulFdiv / <span class="number">256</span>;</span><br><span class="line">    U0DLL  = ulFdiv % <span class="number">256</span>; </span><br><span class="line">    U0LCR  = <span class="number">0x03</span>;                                  <span class="comment">/*  锁定波特率                  */</span></span><br><span class="line">    U0FCR  = <span class="number">0x87</span>;                                  <span class="comment">/*  使能FIFO，设置8个字节触发点  */</span></span><br><span class="line">    U0IER  = <span class="number">0x01</span>;                                  <span class="comment">/*  使能接收中断                */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendByte</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字节数据，并等待数据发送完成，使用查询方式</span></span><br><span class="line"><span class="comment">** input parameters:    uiDat:   要发送的数据</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendByte</span> <span class="params">(INT8U ucDat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U0THR = ucDat;                                   <span class="comment">/*  写入数据                   */</span></span><br><span class="line">    <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x20</span>) == <span class="number">0</span>);                     <span class="comment">/*  等待数据发送完毕            */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendStr</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字符串</span></span><br><span class="line"><span class="comment">** input parameters:    pucStr:  要发送的字符串指针</span></span><br><span class="line"><span class="comment">**                      ulNum:   要发送的数据个数</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendStr</span> <span class="params">(INT8U <span class="keyword">const</span> *pucStr, INT32U ulNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ulNum; i++) &#123;                    <span class="comment">/*  发送指定个字节数据           */</span></span><br><span class="line">        uart0SendByte(*pucStr++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/************************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name:        uart0Isr</span></span><br><span class="line"><span class="comment">* Description:          UART0 中断处理函数</span></span><br><span class="line"><span class="comment">* Input:                None</span></span><br><span class="line"><span class="comment">* Output:               None</span></span><br><span class="line"><span class="comment">* Return:               None</span></span><br><span class="line"><span class="comment">**************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT8U i;</span><br><span class="line">    <span class="keyword">while</span> ((U0IIR &amp; <span class="number">0x01</span>) == <span class="number">0</span>)&#123;                       <span class="comment">/*  判断是否有中断挂起          */</span></span><br><span class="line">        <span class="keyword">switch</span> (U0IIR &amp; <span class="number">0x0E</span>)&#123;                         <span class="comment">/*  判断中断标志                */</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x04</span>:                                 <span class="comment">/*  接收数据中断                */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;               <span class="comment">/*  连续接收七个字节            */</span></span><br><span class="line">                    GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">                    GulNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0C</span>:                                 <span class="comment">/*  字符超时中断                */</span></span><br><span class="line">                <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)&#123;        <span class="comment">/*  判断数据是否接收完毕         */</span> </span><br><span class="line">                    GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">                    GulNum++;</span><br><span class="line">                    <span class="keyword">if</span>(GulNum&gt;=<span class="number">128</span>)	GulNum=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;GulNum;i++)</span><br><span class="line">                    GucProcessBuf[i]=GucRcvBuf[i];</span><br><span class="line">                GucRcvfinishFlag=<span class="number">1</span>;                    <span class="comment">/* 接收新数据标志置1 */</span></span><br><span class="line">                GucRcvLen=GulNum;</span><br><span class="line">                GulNum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main函数设计"><a class="header-anchor" href="#main函数设计">¶</a>main函数设计</h2>
<p>EEPROM 代码没调通，main 函数中只体现了 03 功能码的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">/***** 初始化部分 *****/</span>  </span><br><span class="line">    INT8U cnt;</span><br><span class="line">    targetInit();                                                   <span class="comment">/* 初始化目标板              */</span></span><br><span class="line">    pinInit();                                                      <span class="comment">/* 引脚初始化                */</span>   </span><br><span class="line">    adcInit();                                                      <span class="comment">/* adc初始化                 */</span></span><br><span class="line">    uartInit ();                                                    <span class="comment">/* uart初始化                */</span></span><br><span class="line">    GucRcvfinishFlag = <span class="number">0</span>;                                           <span class="comment">/* 接收新数据标志初始化       */</span></span><br><span class="line">    zyIsrSet(NVIC_UART0,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)uart0Isr,PRIO_ONE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/***** 循环部分 *****/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (GucRcvfininshFlag == <span class="number">1</span>) &#123;                                   <span class="comment">/* 接收到新数据即进行处理       */</span></span><br><span class="line">        getAdcData();                                               <span class="comment">/* adc 数据采集函数            */</span></span><br><span class="line">                                                                    <span class="comment">/* 将4个通道的adc数据存入AD数组 */</span>    </span><br><span class="line">        GucRcvfinishFlag = <span class="number">0</span>;                                       <span class="comment">/* 接收新数据标志重新置零       */</span></span><br><span class="line">        <span class="keyword">if</span>(GucRcvBuf[<span class="number">0</span>] == addr)                                    <span class="comment">/* 从机地址判断 */</span> </span><br><span class="line">        &#123;                                                                   </span><br><span class="line">            <span class="keyword">if</span>(GucRcvBuf[<span class="number">1</span>] == <span class="number">0x03</span>)                                <span class="comment">/* 功能码判断 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                start = GucRcvBuf[<span class="number">3</span>];                               <span class="comment">/* 寄存器起始地址，此处为取数组的起始地址 */</span></span><br><span class="line">                len = GucRcvBuf[<span class="number">5</span>];                                 <span class="comment">/* 取数据个数 */</span> </span><br><span class="line">                Index = <span class="number">3</span>;                                          <span class="comment">/* 数组下标 */</span></span><br><span class="line">										</span><br><span class="line">                SendBuf[<span class="number">0</span>] = addr;                                  <span class="comment">/* 从机回应：从机地址 */</span> </span><br><span class="line">                SendBuf[<span class="number">1</span>] = <span class="number">0x03</span>;                                  <span class="comment">/* 从机回应：功能码 */</span></span><br><span class="line">                SendBuf[<span class="number">2</span>] = GucRcvBuf[<span class="number">5</span>] * <span class="number">2</span>;                      <span class="comment">/* 从机回应：数据区字节数 */</span></span><br><span class="line">										</span><br><span class="line">                <span class="keyword">for</span>(cnt = <span class="number">0</span>; cnt &lt; len; cnt++)                      <span class="comment">/* 数据区 */</span></span><br><span class="line">                &#123;                                                   <span class="comment">/* for循环中通过cnt变量的迭代控制数据长度 */</span>            </span><br><span class="line">                    SendBuf[Index] = AD[start + cnt] &gt;&gt; <span class="number">8</span>;          <span class="comment">/* start变量控制数据起始位 */</span></span><br><span class="line">                    SendBuf[Index + <span class="number">1</span>] = AD[start + cnt] &amp; <span class="number">0xff</span>;</span><br><span class="line">                    Index += <span class="number">2</span>;                                     <span class="comment">/* 数组下标更新 */</span></span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">                CRC16 = crc16HiLo(SendBuf, <span class="number">3</span> + SendBuf[<span class="number">2</span>]);         <span class="comment">/* 生成 CRC 校验码 */</span></span><br><span class="line">                SendBuf[Index] = CRC16 &gt;&gt; <span class="number">8</span>;</span><br><span class="line">                SendBuf[Index + <span class="number">1</span>] = CRC16 &amp; <span class="number">0xff</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        uart0SendStr (SendBuf, <span class="number">5</span> + SendBuf[<span class="number">2</span>]);                     <span class="comment">/* 向串口发送数据 */</span>		</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DIGITAL</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：Icarus Verilog和GTKwave使用简析</title>
    <url>/2020/06/10/Icarus%20Verilog%E5%92%8CGTKwave%E4%BD%BF%E7%94%A8%E7%AE%80%E6%9E%90/</url>
    <content><![CDATA[<h1 class="title-article">Icarus Verilog和GTKwave使用简析</h1>
<blockquote>
<p>上一篇转载文章的参考文章，整理得更加细致，更有参考价值<a id="more"></a></p>
</blockquote>
<p>本文简要介绍Icarus Verilog和GTKwave的使用，使用iverilog（Icarus Verilog）编译仿真verilog而使用GTKWave查看仿真数据波形</p>
<p></p><div class="toc"><div class="toc">
<ul>
<ul>
<li><a href="#下载安装" rel="nofollow" target="_self">下载安装</a></li>
<li><a href="#基本使用" rel="nofollow" target="_self">基本使用</a><ul>
<li><a href="#iverilog使用" rel="nofollow" target="_self">iverilog使用</a></li>
<li><a href="#gtkwave使用" rel="nofollow" target="_self">GTKWave使用</a></li>
</ul>
</li>
<li><a href="#iverilog常用选项" rel="nofollow" target="_self">iverilog常用选项</a><ul>
<li><a href="#选项-g" rel="nofollow" target="_self">选项-g</a></li>
<li><a href="#选项-o" rel="nofollow" target="_self">选项-o</a></li>
<li><a href="#选项-y" rel="nofollow" target="_self">选项-y</a></li>
<li><a href="#选项-i" rel="nofollow" target="_self">选项-I</a></li>
<li><a href="#选项-d" rel="nofollow" target="_self">选项-D</a></li>
<li><a href="#选项-t" rel="nofollow" target="_self">选项-t</a></li>
</ul>
</li>
<li><a href="#使用库" rel="nofollow" target="_self">使用库</a><ul>
<li><a href="#xilinx" rel="nofollow" target="_self">Xilinx</a><ul>
<li><a href="#vivado" rel="nofollow" target="_self">vivado</a></li>
</ul>
</li>
<li><a href="#lattice" rel="nofollow" target="_self">Lattice</a><ul>
<li><a href="#ecp3" rel="nofollow" target="_self">ECP3</a></li>
<li><a href="#machox2" rel="nofollow" target="_self">MachOX2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#注意事项" rel="nofollow" target="_self">注意事项</a><ul>
<li><a href="#verilog源码" rel="nofollow" target="_self">verilog源码</a></li>
<li><a href="#编译命令" rel="nofollow" target="_self">编译命令</a></li>
<li><a href="#其它" rel="nofollow" target="_self">其它</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p></p>
<p>最近看一本书中有提到GTKwave这个软件，所以就去了解下，发现都是讲iverilog+GTKWave的使用，索性就再解了一下iverilog。这两个软件都是开源软件，而且两个软件安装包总共不足10MB，而且基本的verilog仿真都支持，普通FPGA设计的仿真完全够用。 <br>
由于其他文章都只是很简单的介绍了hello world的一个简单的例子，没有对使用各FPGA公司库的使用做介绍，所以才有本文的产生。本文从安装开始介绍；然后基本使用，最终给出包含Xilinx或Lattice IP的verilog设计的仿真方法；最后给出一些注意事项和使用技巧</p>
<p>本文测试文件在windows10和windows7上测试通过，其它平台请参考官方文档</p>
<h2 id="下载安装"><a name="t0"></a><a name="t0"></a>下载安装</h2>
<p>由于Icarus Verilog中已经包含了GTKWave所以直接从<a href="http://bleyer.org/icarus/" target="_blank" rel="nofollow noopener">http://bleyer.org/icarus/</a>下载安装，这里提供的为Windows版，我下载的为当前时间最新版：iverilog-10.1.1-x64_setup.exe，整个安装包才9.77MB，安装后也只有不到50MB。经测试，其实安装后只要把安装所在目录打包复制到其它电脑也可以用，即下载的这个安装类似一个自解压文件，但会增加两个路径到PATH。所以将安装目录打包复制到其它电脑后只要将以下两个目录（iverilog和gtkwave可执行文件所在目录）加入系统PATH环境变量中即可（这里假设放入其它电脑的目录为E:\iverilog）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E:\iverilog\bin</span><br><span class="line">E:\iverilog\gtkwave\bin</span><br></pre></td></tr></table></figure>
<p>或者在运行批处理文件前加入如下代码即可（即使用前将这两个路径临时加入PATH）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">set iverilog_path=d:\iverilog\bin;</span><br><span class="line">set gtkwave_path=d:\iverilog\gtkwave\bin;</span><br><span class="line">set path=%iverilog_path%%gtkwave_path%%path%</span><br></pre></td></tr></table></figure>
<p>下面给出可能会用到的网址：</p>
<ul>
<li>iverilog 官网：<a href="http://iverilog.icarus.com/" target="_blank" rel="nofollow noopener">http://iverilog.icarus.com/</a></li>
<li>iverilog windows版本：<a href="http://bleyer.org/icarus/" target="_blank" rel="nofollow noopener">http://bleyer.org/icarus/</a></li>
<li>iverilog User Guide：<a href="http://iverilog.wikia.com/wiki/User_Guide" target="_blank" rel="nofollow noopener">http://iverilog.wikia.com/wiki/User_Guide</a></li>
<li>iverilog GitHub：<a href="https://github.com/steveicarus/iverilog" target="_blank" rel="noopener">https://github.com/steveicarus/iverilog</a></li>
<li>GTKWave 官网：<a href="http://gtkwave.sourceforge.net/" target="_blank" rel="nofollow noopener">http://gtkwave.sourceforge.net/</a></li>
<li>GTKWave 手册：<a href="http://gtkwave.sourceforge.net/gtkwave.pdf" target="_blank" rel="nofollow noopener">http://gtkwave.sourceforge.net/gtkwave.pdf</a></li>
</ul>
<h2 id="基本使用"><a name="t1"></a><a name="t1"></a>基本使用</h2>
<p>这里给出一个简单的hello world例程，先对使用方法有一个大概的了解</p>
<h3 id="iverilog使用"><a name="t2"></a><a name="t2"></a>iverilog使用</h3>
<p>仿真当然首先要提供verilog源代码，这里简单的实现了一个打印”hello world!”的例子，由于涉及到GTKWave的使用所以加入了clk和rst_n两个信号，以便介绍GTKWave的使用</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">**  文件名称：hello_world_tb.v</span></span><br><span class="line"><span class="comment">**  创 建 人：hsp</span></span><br><span class="line"><span class="comment">**  创建日期：2017-03-05</span></span><br><span class="line"><span class="comment">**  功能描述：一个iverilog和GTKWave使用方式介绍的hello world例子</span></span><br><span class="line"><span class="comment">*****/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// synopsys translate_off</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns / 1 ps</span></span><br><span class="line"><span class="comment">// synopsys translate_on</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> hello_world_tb;</span><br><span class="line">    <span class="keyword">parameter</span> PERI = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst_n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> <span class="variable">#(PERI/2)</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$dumpfile</span>(<span class="string">"hello_world_tb.vcd"</span>);</span><br><span class="line">        <span class="built_in">$dumpvars</span>(<span class="number">0</span>,hello_world_tb);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"hello world!"</span>);</span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        rst_n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">10</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">        rst_n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">repeat</span>(<span class="number">100</span>) @(<span class="keyword">posedge</span> clk);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>以上verilog:</p>
<ul>
<li>首先定义了一个参数<code>PERI</code>，用于指定<code>clk</code>输出周期</li>
<li>然后定义了用于观察的两个<code>reg</code>：<code>clk</code>和<code>rst_n</code></li>
<li>然后一个<code>always</code>给出了时钟信号<code>clk</code>的输出</li>
<li>之后一个<code>initial</code> <br>
<ul><li>通过<code>$dumpfile</code>指定要保存仿真波形数据需要存储到的文件，指定保存在当前目录中<code>hello_world_tb.vcd</code>文件中（GTKWave还支持LXT,LXT2,VZT,FST和GHW等类型文件）</li>
<li>通过<code>$dumpvars</code>指定要保存仿真波形数据的信号，这里指定为<code>hello_world_tb</code>模块（即本模块）之下及其子模块中的所有信号，当然这个例子中没有子模块，所以仿真数据被存储的为本模块中仅有的两个信号：<code>clk</code>和<code>rst_n</code></li>
<li><code>$display</code>打印<code>hello world!</code></li>
<li>之后就是对<code>clk</code>和<code>rst_n</code>的赋值操作</li>
<li>最后结束仿真，这里要注意最好用<code>$finish</code>而不是<code>$stop</code>，因为若使用<code>$stop</code>在iverilog仿真完后需要手动停止，而用<code>$finish</code>则会自动停止</li></ul></li>
</ul>
<p><strong>注意：</strong>以上代码最好保存为名称为<code>hello_world_tb.v</code>的文件，即模块名和文件名（不包括后缀）相同</p>
<p>之后就是仿真命令的问题，可使用以下批处理使用iverilog执行仿真并最后使用GTKWave打开仿真波形（将以下代码保存为xxx.bat或.cmd后缀的文件并放入以上verilog相同目录即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">rem 若没有设置路径到PATH则关闭以下注释</span><br><span class="line">rem set iverilog_path=d:\iverilog\bin;</span><br><span class="line">rem set gtkwave_path=d:\iverilog\gtkwave\bin;</span><br><span class="line">rem set path=%iverilog_path%%gtkwave_path%%path%</span><br><span class="line"></span><br><span class="line">set testbentch_module=hello_world_tb</span><br><span class="line">set testbentch_file="./%testbentch_module%.v"</span><br><span class="line"></span><br><span class="line">iverilog -o "%testbentch_module%.vvp" %testbentch_file%</span><br><span class="line">vvp "%testbentch_module%.vvp"</span><br><span class="line"></span><br><span class="line">set gtkw_file="%testbentch_module%.gtkw"</span><br><span class="line">if exist %gtkw_file% (gtkwave %gtkw_file%) else (gtkwave "%testbentch_module%.vcd")</span><br></pre></td></tr></table></figure>
<p>以上批处理:</p>
<ul>
<li>第一行关闭显示包括本行，非必须，不要也可以</li>
<li>设置iverilog和GTKWave可执行文件路径到PATH，若没有加入到PATH才需要，这里直接注释</li>
<li>然后设置两个变量，后面会使用 <br>
<ul><li><code>testbentch_module</code>设置为前面verilog模块名相同</li>
<li><code>testbentch_file</code>设置为verilog文件名，即模块名+.v</li></ul></li>
<li>然后使用<code>iverilog</code>编译verilog <br>
<ul><li><code>-o</code>指定输出文件名，这里使用模块名+.vvp</li>
<li>之后指定源文件</li></ul></li>
<li>然后使用<code>vvp</code>开始仿真，参数为上面<code>iverilog</code>的输出文件</li>
<li>之后开始仿真数据波形显示 <br>
<ul><li>设置了一个变量，为GTKWave保存文件的文件名，这里使用模块名+.gtkw</li>
<li>然后判断GTKWave保存文件是否存在，若存在则直接使用GTKWave打开该.gtkw文件，否则打开刚仿真生成的.vcd文件（原因请参考下一节）</li></ul></li>
</ul>
<h3 id="gtkwave使用"><a name="t3"></a><a name="t3"></a>GTKWave使用</h3>
<p>通过上面批处理最后一条中<code>gtkwave</code>命令即可打开GTKWave软件，同时打开了对应的.gtkw或.vcd文件；首次运行打开的为.vcd文件，此时可以看到GTKWave软件界面的Signals和Waves窗口并没有信号显示，需要：</p>
<ul>
<li>在左上角的SST窗口选中一个模块，此时在其下面窗口就可以看到对应模块的所有信号</li>
<li>在显示信号的窗口选中要查看的信号（ctrl+a全选，ctrl和shift可多选），然后点击其下面的Append按钮即可将这些信号显示到Signals和Waves窗口</li>
<li>在Signals窗口选中各信号，然后按<code>G</code>可以将信号分组，推荐将不同模块的信号分为不同的组，这样方便查看</li>
<li>这样操作后若不保存（类似modelsim也需要保存），下次再次打开.vcd文件仍然为初次打开一样Signals和Waves窗口都没有信号，所以此时ctrl+s将其保存，保存文件名推荐为模块名+.gtkw（配合上面的批处理），这样下次上面的批处理发现存在.gtkw文件则直接打开这个.gtkw文件，这样上面添加显示的信号和分组都存在，而波形数据也为最新的仿真数据</li>
</ul>
<p><strong>注：</strong>查看.gtkw文件可以发现其保存的内容不包括波形数据而只包括.vcd文件路径和GTKWave的一些设置（如添加的信号和分组等）</p>
<h2 id="iverilog常用选项"><a name="t4"></a><a name="t4"></a>iverilog常用选项</h2>
<p>直接运行<code>iverilog -help</code>或<code>iverilog</code>则会显示以下帮助信息，显示了iverilog支持的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage: iverilog [-ESvV] [-B base] [-c cmdfile|-f cmdfile]</span><br><span class="line">                [-g1995|-g2001|-g2005|-g2005-sv|-g2009|-g2012] [-g&lt;feature&gt;]</span><br><span class="line">                [-D macro[=defn]] [-I includedir]</span><br><span class="line">                [-M [mode=]depfile] [-m module]</span><br><span class="line">                [-N file] [-o filename] [-p flag=value]</span><br><span class="line">                [-s topmodule] [-t target] [-T min|typ|max]</span><br><span class="line">                [-W class] [-y dir] [-Y suf] source_file(s)</span><br></pre></td></tr></table></figure>
<p>下面简单列举几个常用的参数的简单说明，详细参数列表请查看<a href="http://iverilog.wikia.com/wiki/Iverilog_Flags" target="_blank" rel="nofollow noopener">http://iverilog.wikia.com/wiki/Iverilog_Flags</a></p>
<h3 id="选项-g"><a name="t5"></a><a name="t5"></a>选项-g</h3>
<p>指定使用verilog的版本，推荐使用最新的<code>-g2012</code>基本的SystemVerilog语法都支持（不完全支持），方便使用SV仿真。如上帮助信息显示支持：</p>
<ul>
<li>-g1995</li>
<li>-g2001</li>
<li>-g2005</li>
<li>-g2005</li>
<li>-g2009</li>
<li>-g2012</li>
</ul>
<p>还支持：</p>
<ul>
<li>verilog-ams</li>
<li>assertions/no-assertions</li>
<li>relative-include/no-relative-include</li>
<li>specify/no-specify</li>
<li>strict-ca-eval/no-strict-ca-eval</li>
<li>strict-expr-width/no-scrict-expr-width</li>
<li>xtypes/no-xtypes</li>
<li>io-range-error/no-io-range-error</li>
</ul>
<h3 id="选项-o"><a name="t6"></a><a name="t6"></a>选项-o</h3>
<p>指定编译后输出文件，若不指定默认为<code>a.out</code></p>
<h3 id="选项-y"><a name="t7"></a><a name="t7"></a>选项-y</h3>
<p>指定库的目录，编译时发现了一个没有定义的模块时会到这个参数指定的目录中查找，此选项在使用Xilinx和Lattice库时会用到</p>
<h3 id="选项-i"><a name="t8"></a><a name="t8"></a>选项-I</h3>
<p>指定verilog中<code>`include</code>包含文件的搜索目录，会按<code>-I</code>出现顺序查找</p>
<h3 id="选项-d"><a name="t9"></a><a name="t9"></a>选项-D</h3>
<p>传递一个宏定义，如<code>-DIS_DEF</code>同<code>-DIS_DEF=1</code>，则在verilog中就可以用IS_DEF这个宏定义</p>
<h3 id="选项-t"><a name="t10"></a><a name="t10"></a>选项-t</h3>
<p>使用<code>-tvhdl</code>可将verilog转换为VHDL，如将上面的例子转换为VHDL：<code>iverilog -tvhdl -o hello_world_tb.vhd hello_world_tb.v</code></p>
<h2 id="使用库"><a name="t11"></a><a name="t11"></a>使用库</h2>
<p>若要仿真使用了各FPGA公司IP的设计则需要支持对应公司的库，这里简单介绍使用Xilinx和Lattice公司库的方法</p>
<h3 id="xilinx"><a name="t12"></a><a name="t12"></a>Xilinx</h3>
<h4 id="vivado">vivado</h4>
<p>本人安装的为vivado 2015.3，安装在E盘：<code>E:\Xilinx\Vivado\2015.3</code>；则在使用iverilog编译时使用以下命令即可（替换上面例子中iverilog命令那行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set vivado_dir=E:\Xilinx\Vivado\2015.3\data\verilog\src</span><br><span class="line">set vivado_lib="-y%vivado_dir%" "-y%vivado_dir%\retarget" "-y%vivado_dir%\unifast" "-y%vivado_dir%\unimacro" "-y%vivado_dir%\unisims" "-y%vivado_dir%\xeclib"</span><br><span class="line"></span><br><span class="line">iverilog -g2012 -o "%testbentch_module%.vvp" %vivado_lib% %rtl_file% %testbentch_file% %vivado_dir%/glbl.v</span><br></pre></td></tr></table></figure>
<p>以上命令：</p>
<ul>
<li>设置vivado 2015.3仿真库目录</li>
<li>并通过<code>-y</code>选项列出仿真库各子目录： <br>
<ul><li>retarget</li>
<li>unifast</li>
<li>unimacro</li>
<li>unisims</li>
<li>xeclib</li></ul></li>
<li>在iverilog命令中增加了<code>%vivado_dir%/glbl.v</code>，否则IP编译出错</li>
</ul>
<p><strong>注意：</strong>以上iverilog中还增加了一个<code>%rtl_file%</code>，为要仿真RTL文件，类似<code>%testbentch_file%</code>的变量需要在之前设置</p>
<h3 id="lattice"><a name="t13"></a><a name="t13"></a>Lattice</h3>
<p>Lattice的库仿真，编译较简单只要指定使用到的芯片的库即可（不同于Xilinx，Lattice各芯片的仿真库不同），只是在仿真测试文件中（如上面例子中的hello_world_tb.v文件）模块中需要例化两个模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//  lattice库使用testbentch模块中要加</span><br><span class="line">GSR GSR_INST(.GSR(1'b1));</span><br><span class="line">PUR PUR_INST(.PUR(1'b1));</span><br></pre></td></tr></table></figure>
<p>本机安装Diamond3.5，安装目录在E盘</p>
<h4 id="ecp3">ECP3</h4>
<p>则在使用iverilog编译时使用以下命令即可（替换上面例子中iverilog命令那行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set lattice_dir=E:\lscc\diamond\3.5_x64\cae_library\simulation\verilog</span><br><span class="line">set ecp3_lib="-y%lattice_dir%\ecp3" "-y%lattice_dir%\pmi"</span><br><span class="line">iverilog -g2012 -o "%testbentch_module%.vvp" %ecp3_lib% %rtl_file% %testbentch_file%</span><br></pre></td></tr></table></figure>
<p>以上命令：</p>
<ul>
<li>diamond 3.5仿真库目录</li>
<li>并通过<code>-y</code>选项列出ECP3芯片仿真库子目录： <br>
<ul><li>pmi</li>
<li>ecp3</li></ul></li>
</ul>
<h4 id="machox2">MachOX2</h4>
<p>则在使用iverilog编译时使用以下命令即可（替换上面例子中iverilog命令那行）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set lattice_dir=E:\lscc\diamond\3.5_x64\cae_library\simulation\verilog</span><br><span class="line">set machxo2_lib="-y%lattice_dir%\machxo2" "-y%lattice_dir%\pmi"</span><br><span class="line">iverilog -g2012 -o "%testbentch_module%.vvp" %machxo2_lib% %rtl_file% %testbentch_file%</span><br></pre></td></tr></table></figure>
<p>以上命令：</p>
<ul>
<li>diamond 3.5仿真库目录</li>
<li>并通过<code>-y</code>选项列出MachOX2芯片仿真库子目录： <br>
<ul><li>pmi（同ECP3）</li>
<li>machxo2</li></ul></li>
</ul>
<h2 id="注意事项"><a name="t14"></a><a name="t14"></a>注意事项</h2>
<p>这里列出我在使用中遇到的一些问题或建议</p>
<h3 id="verilog源码"><a name="t15"></a><a name="t15"></a>verilog源码</h3>
<ul>
<li>代码文件名最好为模块名+.v方式，因为通过<code>-y</code>方式指定目录时查找模块时iverilog要求模块名和文件名要相同，否则可能导致无法找到对应模块（这个要求也是平时写verilog应该有的好习惯）</li>
<li>testbentch中结束仿真推荐用<code>$finish</code>而不用<code>$stop</code>；因为<code>$finish</code>可以直接结束仿真并退出，而不需要手动退出，这样运行类似以上例子批处理后可以直接打开GTKWave窗口</li>
</ul>
<h3 id="编译命令"><a name="t16"></a><a name="t16"></a>编译命令</h3>
<ul>
<li><code>iverilog</code>命令中通过<code>-y</code>指定目录时，需要放在源文件参数之前，否则提示有错</li>
<li><code>iverilog</code>命令中通过<code>-D</code>传递宏包含引号的方法：<code>-DIN_FILE="\"xxx.v\""</code>，这在verilog有<code>`include IN_FILE</code>时需要使用；而iverilog命令中使用<code>-DIN_FILE="xxx.v"</code>方式有错误</li>
<li>指定源文件时可以用通配符<code>*</code>，如本人用的批处理中通常使用这种方式指定RTL文件：<code>set rtl_file="../rtl/*.v"</code></li>
</ul>
<h3 id="其它"><a name="t17"></a><a name="t17"></a>其它</h3>
<ul>
<li>加大DOS窗口高度。由于运行批处理需要在DOS窗口查看verilog中<code>$display</code>的打印，有时iverilog编译打印的信息较多时会导致部分信息无法查看，所以需要加大DOS窗口的高度：在DOS窗口标题栏右键-&gt;默认值-&gt;布局中设置屏幕缓冲区中高度为较大的值(如1000)即可</li>
<li>iverilog即使指定为<code>-g2012</code>也不支持break、static等（测试得到）</li>
</ul>
<hr>
<p>转自：<a href="https://blog.csdn.net/husipeng86/article/details/60469543" target="_blank" rel="noopener">https://blog.csdn.net/husipeng86/article/details/60469543</a></p>
<hr>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>DIGITAL</tag>
        <tag>Verilog HDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 入门</title>
    <url>/2020/08/25/Ubuntu%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>又开新坑了。。。</p>
<h2 id="使用-VMware-安装-Ubuntu（保姆级教学）"><a class="header-anchor" href="#使用-VMware-安装-Ubuntu（保姆级教学）">¶</a>使用 VMware 安装 Ubuntu（保姆级教学）</h2>
<a id="more"></a>
<h3 id="先作一点小准备"><a class="header-anchor" href="#先作一点小准备">¶</a>先作一点小准备</h3>
<h4 id="Download-the-latest-LTS-version-of-Ubuntu"><a class="header-anchor" href="#Download-the-latest-LTS-version-of-Ubuntu">¶</a>Download the latest LTS version of Ubuntu</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/Ubuntu%2020.04.1%20LTS.PNG" alt="avatar"></p>
<p>官方下载地址：<a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">https://ubuntu.com/download/desktop</a><br>
<strong>Ubuntu 20.04.1 LTS</strong><br>
Download the latest LTS version of Ubuntu, for desktop PCs and laptops. LTS stands for long-term support — which means five years, until April 2025, of free security and maintenance updates, guaranteed.</p>
<h4 id="Download-VMware-Workstation-Pro"><a class="header-anchor" href="#Download-VMware-Workstation-Pro">¶</a>Download VMware Workstation Pro</h4>
<p>借助 VMware Workstation Pro，您可以在同一台 Windows 或 Linux PC 上同时运行多个操作系统。创建真实的 Linux 和 Windows 虚拟机以及其他桌面、服务器和平板电脑环境（包括可配置的虚拟网络连接和网络条件模拟），用于代码开发、解决方案构建、应用测试、产品演示等。</p>
<p>官方下载地址：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p>
<p>我个人用的版本是 <strong>VMware Workstation Pro 15</strong><br>
百度网盘链接：<a href="https://pan.baidu.com/s/1JbZvplLjTp3SHym7c2QpIA" target="_blank" rel="noopener">https://pan.baidu.com/s/1JbZvplLjTp3SHym7c2QpIA</a><br>
提取码：13da</p>
<p>附：VMware Workstation Pro 15 许可证密钥</p>
<p>UA5DR-2ZD4H-089FY-6YQ5T-YPRX6<br>
FY1N0-AJZ9N-H89KQ-EXX59-MFUED<br>
VF5T0-4RW1H-H818Q-UMQEX-ZPHXA<br>
UG5J2-0ME12-M89WY-NPWXX-WQH88<br>
YC34H-6WWDK-085MQ-JYPNX-NZRA2</p>
<p>这都是网上找来的，也可以自己随便百度一个，只要能用就行</p>
<h3 id="开始安装-Ubuntu"><a class="header-anchor" href="#开始安装-Ubuntu">¶</a>开始安装 Ubuntu</h3>
<p>可以直接去看 <a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/15.0/com.vmware.ws.using.doc/GUID-0EE752F8-C159-487A-9159-FE1F646EE4CA.html" target="_blank" rel="noopener">VMware Workstation Pro 产品文档</a> ，下面给出我的安装流程，仅作为参考</p>
<h4 id="1-打开-VMware-Workstation-Pro-选择创建新的虚拟机"><a class="header-anchor" href="#1-打开-VMware-Workstation-Pro-选择创建新的虚拟机">¶</a>1. 打开 VMware Workstation Pro 选择创建新的虚拟机</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/1.PNG" alt="avatar"></p>
<h4 id="2-选择自定义（高级）类型的配置"><a class="header-anchor" href="#2-选择自定义（高级）类型的配置">¶</a>2. 选择自定义（高级）类型的配置</h4>
<p>其实选典型（推荐）类型的配置好像更方便</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/2.PNG" alt="avatar"></p>
<h4 id="3-硬件兼容性默认"><a class="header-anchor" href="#3-硬件兼容性默认">¶</a>3. 硬件兼容性默认</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/3.PNG" alt="avatar"></p>
<h4 id="4-安装来源选择稍后安装操作系统"><a class="header-anchor" href="#4-安装来源选择稍后安装操作系统">¶</a>4. 安装来源选择稍后安装操作系统</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/4.PNG" alt="avatar"></p>
<h4 id="5-客户机操作系统：Linux-版本：Ubuntu-64-位（如果电脑是-32-位的请选择-Ubuntu）"><a class="header-anchor" href="#5-客户机操作系统：Linux-版本：Ubuntu-64-位（如果电脑是-32-位的请选择-Ubuntu）">¶</a>5. 客户机操作系统：Linux / 版本：Ubuntu 64 位（如果电脑是 32 位的请选择 Ubuntu）</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/5.PNG" alt="avatar"></p>
<h4 id="6-确定虚拟机的名称与位置"><a class="header-anchor" href="#6-确定虚拟机的名称与位置">¶</a>6. 确定虚拟机的名称与位置</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/6.PNG" alt="avatar"></p>
<h4 id="7-指定处理器数量"><a class="header-anchor" href="#7-指定处理器数量">¶</a>7. 指定处理器数量</h4>
<p>这里的设定与性能有关，视情况而定，可以直接按默认的来，也可以适当增加，反正之后是可以再去修改的</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/7.PNG" alt="avatar"></p>
<h4 id="8-虚拟机的内存：2048-MB-即推荐内存-2GB"><a class="header-anchor" href="#8-虚拟机的内存：2048-MB-即推荐内存-2GB">¶</a>8. 虚拟机的内存：2048 MB 即推荐内存 2GB</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/8.PNG" alt="avatar"></p>
<h4 id="9-网络类型选择使用网络地址转换（NAT）"><a class="header-anchor" href="#9-网络类型选择使用网络地址转换（NAT）">¶</a>9. 网络类型选择使用网络地址转换（NAT）</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/9.PNG" alt="avatar"></p>
<h4 id="10-I-O-控制器类型：默认-虚拟磁盘类型：默认"><a class="header-anchor" href="#10-I-O-控制器类型：默认-虚拟磁盘类型：默认">¶</a>10. I/O 控制器类型：默认 / 虚拟磁盘类型：默认</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/10.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/11.PNG" alt="avatar"></p>
<h4 id="11-选择磁盘：创建新虚拟磁盘"><a class="header-anchor" href="#11-选择磁盘：创建新虚拟磁盘">¶</a>11. 选择磁盘：创建新虚拟磁盘</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/12.PNG" alt="avatar"></p>
<h4 id="12-最大磁盘大小：自定义-将虚拟磁盘存储为单个文件"><a class="header-anchor" href="#12-最大磁盘大小：自定义-将虚拟磁盘存储为单个文件">¶</a>12. 最大磁盘大小：自定义 / 将虚拟磁盘存储为单个文件</h4>
<p>选项里面作了一些说明，按自己的需求来就好</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/13.PNG" alt="avatar"></p>
<h4 id="13-确定磁盘文件的地址"><a class="header-anchor" href="#13-确定磁盘文件的地址">¶</a>13. 确定磁盘文件的地址</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/14.PNG" alt="avatar"></p>
<h4 id="14-自定义硬件"><a class="header-anchor" href="#14-自定义硬件">¶</a>14. 自定义硬件</h4>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/15.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/16.PNG" alt="avatar"></p>
<p>在设备栏中点击 <strong>新 CD/DVD(SATA)</strong><br>
在连接一栏中选择 <strong>使用 ISO 映像文件</strong><br>
点击浏览，找到之前在准备过程中下载的 <strong>Ubuntu 20.04.1 LTS</strong><br>
文件名：ubuntu-20.04.1-desktop-amd64.iso</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/17.PNG" alt="avatar"></p>
<p>可以删掉（移除）打印机</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/18.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/19.PNG" alt="avatar"></p>
<p>设置好后点击 <strong>关闭</strong><br>
回到 <strong>新建虚拟机向导</strong> ，点击 <strong>完成</strong></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/20.PNG" alt="avatar"></p>
<p>此时回到了 <strong>VMware Workstation 界面</strong><br>
发现其已为我们创建好了一个虚拟机<br>
点击 <strong>开启此虚拟机</strong> ，然后开始安装 Ubuntu 前的配置</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/21.PNG" alt="avatar"></p>
<p>一路向前，有继续的点继续</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/22.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/23.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/24.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/25.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/26.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/27.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/28.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/29.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/30.PNG" alt="avatar"></p>
<p>放在这儿，让它慢慢整（指直接睡到四点）</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/31.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/32.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/33.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/34.PNG" alt="avatar"></p>
<p>有号上号</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/35.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/36.PNG" alt="avatar"></p>
<p>设置 Livepatch 的同时顺便创了一个 Ubuntu One 的号</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/37.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/38.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/39.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/40.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/41.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/42.PNG" alt="avatar"></p>
<p>基本完事，但是会发现全屏效果感人，于是继续</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/43.PNG" alt="avatar"></p>
<h3 id="安装-VMware-Tools"><a class="header-anchor" href="#安装-VMware-Tools">¶</a>安装 VMware Tools</h3>
<p>可以直接点击其下方提示中的 <strong>安装 Tools</strong><br>
也可以点击位于界面上方的 <strong>虚拟机(M)</strong> -&gt; <strong>安装 VMware Tools(T)…</strong><br>
下载完成后，找到图片中对应的文件并打开，将其中文件提取至桌面<br>
在桌面上打开提取过来的文件，并进入终端<br>
输入命令：sudo ./vmware-install.pl 并输入密码（输入时不显示）<br>
然后在需要输入 yes 或 no 的时候总输入 yes<br>
[yes] 是默认 yes，可以直接回车<br>
其余要输入的都是选默认，也可以直接回车</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/44.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/45.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/46.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/47.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/48.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/49.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/50.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/51.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/52.PNG" alt="avatar"></p>
<p>安装完成，在上方点击 <strong>进入全屏模式</strong> 即可占满你的整个桌面</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/53.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Ubuntu%E5%85%A5%E9%97%A8/54.PNG" alt="avatar"></p>
<hr>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p>VMware虚拟机快速安装Ubuntu教程<br>
<a href="https://blog.csdn.net/weixin_43465312/article/details/100233930" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43465312/article/details/100233930</a></p>
<p>VMware Ubuntu安装详细过程<br>
<a href="https://blog.csdn.net/u013142781/article/details/50529030" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50529030</a></p>
<p>VMWare中处理器和内存配置含义<br>
<a href="https://blog.csdn.net/TSZ0000/article/details/81478099" target="_blank" rel="noopener">https://blog.csdn.net/TSZ0000/article/details/81478099</a></p>
<p>安装虚拟机时如何选择处理器数量？<br>
<a href="https://blog.csdn.net/liugongfeng/article/details/45046481" target="_blank" rel="noopener">https://blog.csdn.net/liugongfeng/article/details/45046481</a></p>
<p>VMware Workstation Pro 15 许可证密钥<br>
<a href="https://www.cnblogs.com/Chan94/p/12702278.html" target="_blank" rel="noopener">https://www.cnblogs.com/Chan94/p/12702278.html</a></p>
<hr>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：Windows上使用iverilog+gtkwave仿真</title>
    <url>/2020/06/10/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8iverilog+gtkwave%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<h1>Windows上使用iverilog+gtkwave仿真</h1>
<a id="more"></a>
<div id="cnblogs_post_body" class="blogpost-body ">
    <p>主要参考了：</p>
<p>https://www.cnblogs.com/lsgxeva/p/8280662.html</p>
<p>谢谢！</p><!--more-->
<p>&nbsp;</p>
<hr>
<p>使用Verilog编写好了功能模块以及对应的testbench之后，一般需要对其功能进行仿真测试。由于工作场合、必须使用正版软件，然而ModelSim的license又非常有限、经常出现的状况是一方在使用其进行仿真、另一方就不能够进行仿真了。</p>
<p>在这个情况下，可以有的选择包括：</p>
<p>1、继续等待别人用完，然后再使用ModelSim进行仿真；</p>
<p>2、使用集成在VIVADO里的simulation工具（ISE下自带的是ISim），基本可以胜任绝大多数的功能仿真任务；操作也很简单，直接Run Simulation就可以了；</p>
<p>3、使用开源的工具：iverilog+gtkwave工具。</p>
<p>下面对第三种方式的操作流程进行记录。系统环境为Windows7</p>
<p>从官网下载包含iverilog+GTKWave的安装包，地址为<a href="http://bleyer.org/icarus/" target="_blank" rel="noopener">http://bleyer.org/icarus/</a> 。安装好之后开始逐步执行命令。（或者也可以将命令编写在一个脚本文件中。）</p>
<p>本文所仿真的verilog小实例如下，是一个简单的loadable四位加一计数器：（代码来自在学习testbench期间在网上找到的Lattice公司的“A Verilog HDL Test Bench Primer”手册中的示例代码）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">// File: count16.v</span></span><br><span class="line"><span class="comment">// Purpose: Verilog Simulation Example</span></span><br><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns / 100 ps</span></span><br><span class="line"><span class="keyword">module</span> count16 (count, count_tri, clk, rst_l, load_l, enable_l, cnt_in,</span><br><span class="line">oe_l);</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count_tri;</span><br><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span> rst_l;</span><br><span class="line"><span class="keyword">input</span> load_l;</span><br><span class="line"><span class="keyword">input</span> enable_l;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_in;</span><br><span class="line"><span class="keyword">input</span> oe_l;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"><span class="comment">// tri-state buffers</span></span><br><span class="line"><span class="keyword">assign</span> count_tri = (!oe_l) ? count : <span class="number">4'bZZZZ</span>;</span><br><span class="line"><span class="comment">// synchronous 4 bit counter</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_l)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (!rst_l) <span class="keyword">begin</span></span><br><span class="line">            count &lt;= #<span class="number">1</span> <span class="number">4'b0000</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!load_l) <span class="keyword">begin</span></span><br><span class="line">            count &lt;= #<span class="number">1</span> cnt_in;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!enable_l) <span class="keyword">begin</span></span><br><span class="line">            count &lt;= #<span class="number">1</span> count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span> <span class="comment">//of count16</span></span><br></pre></td></tr></table></figure>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"></span></div></div>
<p>为其编写的testbench文件如下：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"></span></div>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------</span></span><br><span class="line"><span class="comment">// File: cnt16_tb.v</span></span><br><span class="line"><span class="comment">// Purpose: Verilog Simulation Example</span></span><br><span class="line"><span class="comment">// Test Bench</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns / 100 ps</span></span><br><span class="line"><span class="keyword">module</span> cnt16_tb ();</span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="comment">// inputs to the DUT are reg type</span></span><br><span class="line"><span class="keyword">reg</span> clk_50;</span><br><span class="line"><span class="keyword">reg</span> rst_l, load_l, enable_l;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count_in;</span><br><span class="line"><span class="keyword">reg</span> oe_l;</span><br><span class="line"><span class="comment">//--------------------------------------------------------</span></span><br><span class="line"><span class="comment">// outputs from the DUT are wire type</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] count_tri;</span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="comment">// instantiate the Device Under Test (DUT)</span></span><br><span class="line"><span class="comment">// using named instantiation</span></span><br><span class="line">count16 U1 ( <span class="variable">.count</span>(cnt_out),</span><br><span class="line"><span class="variable">.count_tri</span>(count_tri),</span><br><span class="line"><span class="variable">.clk</span>(clk_50),</span><br><span class="line"><span class="variable">.rst_l</span>(rst_l),</span><br><span class="line"><span class="variable">.load_l</span>(load_l),</span><br><span class="line"><span class="variable">.cnt_in</span>(count_in),</span><br><span class="line"><span class="variable">.enable_l</span>(enable_l),</span><br><span class="line"><span class="variable">.oe_l</span>(oe_l)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// create a 50Mhz clock</span></span><br><span class="line"><span class="keyword">always</span></span><br><span class="line">#<span class="number">10</span> clk_50 = ~clk_50; <span class="comment">// every ten nanoseconds invert</span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// initial blocks are sequential and start at time 0</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$dumpfile</span>(<span class="string">"cnt16_tb.vcd"</span>);</span><br><span class="line">            <span class="built_in">$dumpvars</span>(<span class="number">0</span>,cnt16_tb);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; Starting the Simulation &gt;&gt;"</span>);</span><br><span class="line">clk_50 = <span class="number">1'b0</span>;</span><br><span class="line"><span class="comment">// at time 0</span></span><br><span class="line">rst_l = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// reset is active</span></span><br><span class="line">enable_l = <span class="number">1'b1</span>;</span><br><span class="line"><span class="comment">// disabled</span></span><br><span class="line">load_l = <span class="number">1'b1</span>;</span><br><span class="line"><span class="comment">// disabled</span></span><br><span class="line">count_in = <span class="number">4'h0</span>;</span><br><span class="line">oe_l = <span class="number">4'b0</span>;</span><br><span class="line"><span class="comment">// enabled</span></span><br><span class="line">#<span class="number">20</span> rst_l = <span class="number">1'b1</span>;</span><br><span class="line"><span class="comment">// at time 20 release reset</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; Coming out of reset &gt;&gt;"</span>);</span><br><span class="line">@(<span class="keyword">negedge</span> clk_50); <span class="comment">// wait till the negedge of</span></span><br><span class="line"><span class="comment">// clk_50 then continue</span></span><br><span class="line">load_count(<span class="number">4'hA</span>);</span><br><span class="line"><span class="comment">// call the load_count task</span></span><br><span class="line"><span class="comment">// and pass 4'hA</span></span><br><span class="line">@(<span class="keyword">negedge</span> clk_50);</span><br><span class="line"><span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; Turning ON the count enable &gt;&gt;"</span>);</span><br><span class="line">enable_l = <span class="number">1'b0</span>;</span><br><span class="line"><span class="comment">// turn ON enable</span></span><br><span class="line"><span class="comment">// let the simulation run,</span></span><br><span class="line"><span class="comment">// the counter should roll</span></span><br><span class="line"><span class="keyword">wait</span> (cnt_out == <span class="number">4'b0001</span>); <span class="comment">// wait until the count</span></span><br><span class="line"><span class="comment">// equals 1 then continue</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; count = %d - Turning OFF the count enable &gt;&gt;"</span>,</span><br><span class="line">cnt_out);</span><br><span class="line">enable_l = <span class="number">1'b1</span>;</span><br><span class="line">#<span class="number">40</span>;</span><br><span class="line"><span class="comment">// let the simulation run for 40ns</span></span><br><span class="line"><span class="comment">// the counter shouldn't count</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; Turning OFF the OE &gt;&gt;"</span>);</span><br><span class="line">oe_l = <span class="number">1'b1</span>;</span><br><span class="line"><span class="comment">// disable OE, the outputs of</span></span><br><span class="line"><span class="comment">// count_tri should go high Z.</span></span><br><span class="line">#<span class="number">20</span>;</span><br><span class="line"><span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; Simulation Complete &gt;&gt;"</span>);</span><br><span class="line"><span class="built_in">$stop</span>;</span><br><span class="line"><span class="comment">// stop the simulation</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// This initial block runs concurrently with the other</span></span><br><span class="line"><span class="comment">// blocks in the design and starts at time 0</span></span><br><span class="line"><span class="comment">/*initial</span></span><br><span class="line"><span class="comment">begin</span></span><br><span class="line"><span class="comment">// $monitor will print whenever a signal changes</span></span><br><span class="line"><span class="comment">// in the design</span></span><br><span class="line"><span class="comment">$monitor($time, " clk_50=%b, rst_l=%b, enable_l=%b, load_l=%b,</span></span><br><span class="line"><span class="comment">count_in=%h, cnt_out=%h, oe_l=%b, count_tri=%h", clk_50, rst_l,</span></span><br><span class="line"><span class="comment">enable_l, load_l, count_in, cnt_out, oe_l, count_tri);</span></span><br><span class="line"><span class="comment">end*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// The load_count task loads the counter with the value passed</span></span><br><span class="line"><span class="keyword">task</span> load_count;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] load_value;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        @(<span class="keyword">negedge</span> clk_50);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="built_in">$time</span>, <span class="string">" &lt;&lt; Loading the counter with %h &gt;&gt;"</span>, load_value);</span><br><span class="line">        load_l = <span class="number">1'b0</span>;</span><br><span class="line">        count_in = load_value;</span><br><span class="line">        @(<span class="keyword">negedge</span> clk_50);</span><br><span class="line">        load_l = <span class="number">1'b1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span> <span class="comment">//of load_count</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> <span class="comment">//of cnt16_tb</span></span><br></pre></td></tr></table></figure>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"></span></div></div>
<p>为了方便执行，编写了批处理脚本，如下：</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"></span></div>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">set iverilog_path=C:\iverilog\bin;</span><br><span class="line">set gtkwave_path=C:\iverilog\gtkwave\bin;</span><br><span class="line">set path=%iverilog_path%%gtkwave_path%%path%</span><br><span class="line"></span><br><span class="line">set source_module=count16</span><br><span class="line">set testbentch_module=cnt16_tb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iverilog -o <span class="string">"%testbentch_module%.vvp"</span> %testbentch_module%<span class="variable">.v</span> %source_module%<span class="variable">.v</span></span><br><span class="line">vvp -n <span class="string">"%testbentch_module%.vvp"</span></span><br><span class="line"></span><br><span class="line">set gtkw_file=<span class="string">"%testbentch_module%.gtkw"</span></span><br><span class="line"><span class="keyword">if</span> exist %gtkw_file% (gtkwave %gtkw_file%) <span class="keyword">else</span> (gtkwave <span class="string">"%testbentch_module%.vcd"</span>)</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"></span></div></div>
<p>首先，设置iverilog和GTKWave可执行文件路径到PATH。由于工作场合下、本人只是所使用电脑系统的普通用户权限、而不是管理员权限，所以不方便为本机系统添加环境变量，所以需要在开始执行上述操作。</p>
<p>然后设置两个变量，后面会使用</p>
<p>  testbentch_module设置为testbench文件的模块名</p>
<p>  source_module设置为DUT模块名</p>
<p>然后使用iverilog编译verilog</p>
<p>  -o指定输出文件名，这里使用模块名+.vvp</p>
<p>  之后指定源文件</p>
<p>在制定源文件的时候可以用通配符*，如本人用的批处理中通常使用这种方式指定RTL文件：set rtl_file=&quot;…/rtl/*.v&quot;。</p>
<p>然后使用vvp开始仿真，参数为上面iverilog的输出文件</p>
<p>之后开始仿真数据波形显示</p>
<p>  设置了一个变量，为GTKWave保存文件的文件名，这里使用模块名+.gtkw</p>
<p>  然后判断GTKWave保存文件是否存在，若存在则直接使用GTKWave打开该.gtkw文件，否则打开刚仿真生成的.vcd文件。</p>
<p>这里有两点需要注意：</p>
<p>1.vvp命令使用了-n选项是为了让testbench在执行完测试流程之后自动结束，也可以不在执行命令这里使用-n、而通过在testbench文件的initial块中添加&quot;\$finish&quot;命令来结束。（testbentch中结束仿真推荐用\$finish而不用\$stop；因为\$finish可以直接结束仿真并退出，而不需要手动退出，这样运行类似以上例子批处理后可以直接打开GTKWave窗口）</p>
<p>2.为了让vvp命令有输出，需要在testbench文件中额外添加一个initial块，在上面的代码中为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$dumpfile</span>(<span class="string">"cnt16_tb.vcd"</span>);</span><br><span class="line">            <span class="built_in">$dumpvars</span>(<span class="number">0</span>,cnt16_tb);</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>dumpfile的内容为输出的vcd文件名，可以随意指定，这里指定为testbench模块名；</p>
<p>dumpvar的参数需要为testbench的模块名。</p>
<p>添加了这两个命令之后就可以将生成的波性文件保存在本地。</p>
<p>在GTKWave中打开的仿真波形结果如下图所示：</p>
<p><img src="https://img2018.cnblogs.com/blog/1456363/201903/1456363-20190313155127239-1334147191.png" alt="" width="920" height="259"></p>
<p>&nbsp;</p>
<p>&nbsp;直接运行<code>iverilog -help</code>或<code>iverilog</code>则会显示以下帮助信息，显示了iverilog支持的参数</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Usage: iverilog [-ESvV] [-B base] [-c cmdfile|-f cmdfile]</span><br><span class="line">                [-g1995|-g2001|-g2005|-g2005-sv|-g2009|-g2012] [-g&lt;feature&gt;]</span><br><span class="line">                [-D macro[=defn]] [-I includedir]</span><br><span class="line">                [-M [mode=]depfile] [-m <span class="keyword">module</span>]</span><br><span class="line">                [-N file] [-o filename] [-p flag=value]</span><br><span class="line">                [-s topmodule] [-t target] [-T min|typ|max]</span><br><span class="line">                [-W <span class="keyword">class</span>] [-y dir] [-Y suf] source_file(s)</span><br></pre></td></tr></table></figure>
<p>详细参数列表请查看<a href="http://iverilog.wikia.com/wiki/Iverilog_Flags" target="_blank">http://iverilog.wikia.com/wiki/Iverilog_Flags</a></p>
<p>此外，如果运行批处理需要在DOS窗口查看verilog中$display的打印，有时iverilog编译打印的信息较多时会导致部分信息无法查看，所以需要加大DOS窗口的高度：在DOS窗口标题栏右键-&gt;默认值-&gt;布局中设置屏幕缓冲区中高度为较大的值(如1000)即可。</p>
<p>&nbsp;</p>
<p>最后是可能会用到的网址：</p>
<p>iverilog 官网：http://iverilog.icarus.com/</p>
<p>iverilog windows版本：http://bleyer.org/icarus/</p>
<p>iverilog User Guide：http://iverilog.wikia.com/wiki/User_Guide</p>
<p>iverilog GitHub：https://github.com/steveicarus/iverilog</p>
<p>GTKWave 官网：http://gtkwave.sourceforge.net/</p>
<p>GTKWave 手册：http://gtkwave.sourceforge.net/gtkwave.pdf&nbsp;</p>
<hr>
<p>转自：<a href="https://www.cnblogs.com/lazypigwhy/p/10523712.html" target="_blank" rel="noopener">https://www.cnblogs.com/lazypigwhy/p/10523712.html</a></p>
<hr>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>DIGITAL</tag>
        <tag>Verilog HDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2>
<h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<a id="more"></a>
<h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>关于gdb使用的练习与gdb简介</title>
    <url>/2021/03/10/gdb%E8%B0%83%E8%AF%95%E5%99%A8/</url>
    <content><![CDATA[<h2 id="gdb简介"><a class="header-anchor" href="#gdb简介">¶</a>gdb简介</h2>
<p>gdb 是一个文本界面的调试器，功能强大，适合与 gcc/g++ 搭配使用。</p>
<p>一般来说，GDB主要帮助你完成下面四个方面的功能：<br>
1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。<br>
2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）<br>
3、当程序被停住时，可以检查此时你的程序中所发生的事。<br>
4、你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。<a id="more"></a></p>
<p>下面是一个 gdb 常见命令的表格</p>
<table>
<thead>
<tr>
<th>简写</th>
<th>全称</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>list</td>
<td>显示指定行号或者指定函数附近的源代码</td>
</tr>
<tr>
<td>b</td>
<td>break</td>
<td>在指定行号或者指定函数开头处设置断点。如 <code>b main</code></td>
</tr>
<tr>
<td>r</td>
<td>run</td>
<td>运行程序，直到程序结束或者遇到断点而停下</td>
</tr>
<tr>
<td>c</td>
<td>continue</td>
<td>在程序中断后继续执行程序，直到程序结束或者遇到断点而停下。注意在程序开始执行前只能用 r，不能用 c</td>
</tr>
<tr>
<td>n</td>
<td>next</td>
<td>执行一条语句。如果有函数调用，则把它作为一个整体</td>
</tr>
<tr>
<td>s</td>
<td>step</td>
<td>执行一条语句。如果有函数调用，则进入函数内部</td>
</tr>
<tr>
<td>u</td>
<td>until</td>
<td>执行到指定行号或者指定函数的开头</td>
</tr>
<tr>
<td>p</td>
<td>print</td>
<td>显示变量或表达式的值</td>
</tr>
<tr>
<td>disp</td>
<td>display</td>
<td>把一个表达式设置为 display，当程序每次停下来时都会显示其值</td>
</tr>
<tr>
<td>cl</td>
<td>clear</td>
<td>取消断点，和 b 的格式相同。如果该位置有多个断点，将同时取消</td>
</tr>
<tr>
<td>i</td>
<td>info</td>
<td>显示各种信息。如 <code>i b</code> 显示所有断点，<code>i disp</code> 显示 display，而 <code>i lo</code> 显示所有局部变量</td>
</tr>
</tbody>
</table>
<br>
<p>如果希望逐条语句地执行程序，最常用的是 next(n) 与 step(s)，其作用都是执行当前行，但如果涉及函数调用，next 会将函数作为一个整体执行完毕，而 step 将进入函数内部。如果需要连续执行 n 或 s，只需第一次输入后连续按 Enter 键，在 gdb 中，如果在提示符下直接按 Enter 键，等价于再次执行上一条指令。</p>
<p>如果想要详细了解某个命令的具体作用，可以在提示符下键入 help + 命令名或其缩写，来获取帮助信息，如 <code>help finish</code></p>
<blockquote>
<p>Execute until selected stack frame returns.<br>
Usage: finish<br>
Upon return, the value returned is printed and put in the value history.</p>
</blockquote>
<h2 id="高级应用"><a class="header-anchor" href="#高级应用">¶</a>高级应用</h2>
<p>关于栈帧的相关命令，最常用的是 bt，用于查看函数堆栈。</p>
<p>关于断点控制的相关命令：</p>
<ul>
<li>commands(comm) 命令可以指定在某个断点处停下来后所执行的 gdb 命令；</li>
<li>ignore(ig) 命令可以让断点在前 count 次到达时都不停下来；</li>
<li>condition(cond) 命令可以给断点加一个条件；</li>
</ul>
<p>断点控制的一个例子：</p>
<div align=left><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/gdbtest/advance.PNG"/></div><br>
<p>一种特殊的断点：watchpoint</p>
<ul>
<li>watch a : 在 a 修改时停下显示 a 修改前后的值</li>
<li>awatch a : 在 a 读写时都停</li>
<li>rwatch a : 在 a 被读时停下</li>
</ul>
<p>在 gdb 中还能自由（不太自由地）调用函数（程序中新定义的函数与库函数），可以用 call、print、condition、display 命令来调用。</p>
<h2 id="这是一个关于gdb使用的简单练习的示例"><a class="header-anchor" href="#这是一个关于gdb使用的简单练习的示例">¶</a>这是一个关于gdb使用的简单练习的示例</h2>
<p>示例环境为：ubuntu 20.04</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/gdbtest/touch_gdbtest.png"/></div><br>
<p>注意，若要使用 gdb 调试，用 gcc 编译时应加上 -g 选项，生成调试用的符号表。</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/gdbtest/program.png"/></div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/gdbtest/gdb_1.png"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/gdbtest/gdb_2.png"/></div>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<p><a href="https://baike.baidu.com/item/gdb" target="_blank" rel="noopener">百度百科：gdb</a><br>
算法竞赛入门经典/刘汝佳编著. ——2 版. ——北京：清华大学出版社，2014</p>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day4</title>
    <url>/2023/03/14/leetcodeDay4/</url>
    <content><![CDATA[<p>LeetCode Day4<a id="more"></a></p>
<h1>数组</h1>
<h2 id="有序数组的平方"><a class="header-anchor" href="#有序数组的平方">¶</a>有序数组的平方</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day4_977.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 其实昨天已经写过了 */</span></span><br><span class="line"><span class="comment">/* 这里就看看不同的方法吧 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 暴力排序 */</span></span><br><span class="line"><span class="comment">/* 时间复杂度为 O(nlogn) */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            nums[i] *= nums[i];</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 快速排序</span></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 双指针法，但是换个思路 */</span></span><br><span class="line"><span class="comment">/* 先找最大的 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt;= j;) &#123; <span class="comment">// 注意这里要i &lt;= j，因为最后要处理两个元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j])  &#123;</span><br><span class="line">                result[k--] = A[j] * A[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[k--] = A[i] * A[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="长度最小的子数组"><a class="header-anchor" href="#长度最小的子数组">¶</a>长度最小的子数组</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day4_209.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 暴力实现 */</span></span><br><span class="line"><span class="comment">/* 两个 for 循环，其时间复杂度为 O(n^2) */</span></span><br><span class="line"><span class="comment">/* 此代码不能通过，超时了（TLE） */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> newRES = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    newRES = j - i + <span class="number">1</span>;</span><br><span class="line">                    result = result &gt; newRES ? newRES : result;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不超时的方法：滑动窗口法 */</span></span><br><span class="line"><span class="comment">/* 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对暴力方法的改进：</span></span><br><span class="line"><span class="comment">只用一个 for 循环，且循环的索引表示滑动窗口的终止位置</span></span><br><span class="line"><span class="comment">看上去其实和双指针法没有什么区别</span></span><br><span class="line"><span class="comment">消除了暴力方法中的一些不必要的计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">须明确：</span></span><br><span class="line"><span class="comment">窗口内是什么？</span></span><br><span class="line"><span class="comment">如何移动窗口的起始位置？</span></span><br><span class="line"><span class="comment">如何移动窗口的结束位置？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">窗口：满足其和 ≥ target 的长度最小的连续子数组</span></span><br><span class="line"><span class="comment">起始位置移动：如果当前窗口的值大于 target，窗口向前移动</span></span><br><span class="line"><span class="comment">结束位置如何移动：窗口的结束位置就是遍历数组的指针即for循环里的索引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 来具体实现一下 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> result = INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">int</span> newRES = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; endIndex &lt; len; endIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[endIndex];</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                sum -= nums[startIndex];</span><br><span class="line">                startIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            newRES = endIndex - startIndex + <span class="number">2</span>;</span><br><span class="line">            result = result &gt; newRES ? newRES : result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 看看正规的滑动窗口代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 滑动窗口起始位置</span></span><br><span class="line">    <span class="keyword">int</span> subLength = <span class="number">0</span>; <span class="comment">// 滑动窗口的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            subLength = (j - i + <span class="number">1</span>); <span class="comment">// 取子序列的长度</span></span><br><span class="line">            result = result &lt; subLength ? result : subLength;</span><br><span class="line">            sum -= nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">    <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这份代码把每个和大于 target 的子数组长度都去与 result 比较</span></span><br><span class="line"><span class="comment">代码精简，我的想法是用 flag 去控制一下，减少计算次数</span></span><br><span class="line"><span class="comment">重要的是理解其核心代码</span></span><br><span class="line"><span class="comment">while (sum &gt;= target) &#123;</span></span><br><span class="line"><span class="comment">    subLength = (j - i + 1); </span></span><br><span class="line"><span class="comment">    result = result &lt; subLength ? result : subLength;</span></span><br><span class="line"><span class="comment">    sum -= nums[i++]; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day4_904.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自己写的费拉不堪的代码 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">整个过程就是模拟出题目描述的过程</span></span><br><span class="line"><span class="comment">然后加了一点滑动窗口（双指针） </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">basket</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> number == <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxfruits = INT32_MIN;</span><br><span class="line">        <span class="keyword">int</span> len = fruits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pushElem, popElem;</span><br><span class="line">        <span class="keyword">int</span> newResult;</span><br><span class="line">        basket B1, B2;</span><br><span class="line">        <span class="keyword">for</span> (; endIndex &lt; len; endIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            pushElem = fruits[endIndex];</span><br><span class="line">            <span class="keyword">if</span> (B1.isempty() &amp;&amp; B2.isempty()) &#123; B1.type = pushElem; B1.number++; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (B1.isempty()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pushElem != B2.type) &#123; B1.type = pushElem; B1.number++; &#125;</span><br><span class="line">                <span class="keyword">else</span> B2.number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (B2.isempty()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pushElem != B1.type) &#123; B2.type = pushElem; B2.number++; &#125;</span><br><span class="line">                <span class="keyword">else</span> B1.number++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pushElem == B1.type) B1.number++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pushElem == B2.type) B2.number++;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    newResult = B1.number + B2.number;</span><br><span class="line">                    maxfruits = maxfruits &gt; newResult ? maxfruits : newResult;</span><br><span class="line">                    <span class="keyword">while</span> (!B1.isempty() &amp;&amp; !B2.isempty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        popElem = fruits[startIndex];</span><br><span class="line">                        <span class="keyword">if</span> (popElem == B1.type) B1.number--;</span><br><span class="line">                        <span class="keyword">if</span> (popElem == B2.type) B2.number--;</span><br><span class="line">                        startIndex++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (B1.isempty()) &#123; B1.type = pushElem; B1.number++; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (B2.isempty()) &#123; B2.type = pushElem; B2.number++; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        newResult = B1.number + B2.number;</span><br><span class="line">        maxfruits = maxfruits &gt; newResult ? maxfruits : newResult;</span><br><span class="line">        <span class="keyword">return</span> maxfruits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么自己写的这么复杂，其实写的时候就发现了</span></span><br><span class="line"><span class="comment">没有想出用什么数据结构来写，所以就硬写</span></span><br><span class="line"><span class="comment">看了官方的题解才知道用哈希表</span></span><br><span class="line"><span class="comment">哈希表可以同时存储窗口内的数（代表水果类型）以及出现的次数</span></span><br><span class="line"><span class="comment">哈希表中出现超过两个键值对时就不满足条件了</span></span><br><span class="line"><span class="comment">此时开始移动窗口的起始位置，并进行删除</span></span><br><span class="line"><span class="comment">直至哈希表中只有两个键值对</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 官方题解 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">            ++cnt[fruits[right]];</span><br><span class="line">            <span class="keyword">while</span> (cnt.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(fruits[left]);</span><br><span class="line">                --it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.erase(it);</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day1</title>
    <url>/2023/03/11/leetcodeDay1/</url>
    <content><![CDATA[<p>LeetCode Day1<a id="more"></a></p>
<p>万般皆下品，刷题才是真</p>
<h1>数组</h1>
<p><a href="https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">数组理论基础</a></p>
<h2 id="二分查找"><a class="header-anchor" href="#二分查找">¶</a>二分查找</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day1_704.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid, midvalue;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            midvalue = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(midvalue == target)  <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(midvalue &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(midvalue &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前提：数组为有序数组，数组中无重复元素</span></span><br><span class="line"><span class="comment">代码区间的定义：[low, high]，左闭右闭区间</span></span><br><span class="line"><span class="comment">mid = (low + high) / 2;</span></span><br><span class="line"><span class="comment">可替换为</span></span><br><span class="line"><span class="comment">mid = low + (high - low) / 2;</span></span><br><span class="line"><span class="comment">防止溢出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day1_35.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid, midvalue;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            midvalue = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(midvalue == target)  <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(midvalue &lt; target)   low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(midvalue &gt; target)   high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15行的</span></span><br><span class="line"><span class="comment">return low;</span></span><br><span class="line"><span class="comment">可以改成：</span></span><br><span class="line"><span class="comment">if(midvalue &lt; target) return mid + 1;</span></span><br><span class="line"><span class="comment">else return mid;</span></span><br><span class="line"><span class="comment">本题在二分法的基础上加了一个判断插入位置的思考</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day1_34.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid, midvalue;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            midvalue = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(midvalue == target) &#123;flag = <span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(midvalue &lt; target) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(midvalue &gt; target) high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> leftlow = <span class="number">0</span>, lefthigh = mid;</span><br><span class="line">            <span class="keyword">int</span> rightlow = mid, righthigh = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> leftmid, leftmidvalue;</span><br><span class="line">            <span class="keyword">int</span> rightmid, rightmidvalue;</span><br><span class="line">            <span class="keyword">while</span>(leftlow &lt;= lefthigh)</span><br><span class="line">            &#123;</span><br><span class="line">                leftmid = leftlow + (lefthigh - leftlow) / <span class="number">2</span>;</span><br><span class="line">                leftmidvalue = nums[leftmid];</span><br><span class="line">                <span class="keyword">if</span>(leftmidvalue == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftmid == <span class="number">0</span>) &#123;left = leftmid; <span class="keyword">break</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(leftmid &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[leftmid - <span class="number">1</span>] &lt; target) &#123;left = leftmid; <span class="keyword">break</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span> lefthigh = leftmid - <span class="number">1</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(leftmidvalue &lt; target) leftlow = leftmid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(rightlow &lt;= righthigh)</span><br><span class="line">            &#123;</span><br><span class="line">                rightmid = rightlow + (righthigh - rightlow) / <span class="number">2</span>;</span><br><span class="line">                rightmidvalue = nums[rightmid];</span><br><span class="line">                <span class="keyword">if</span>(rightmidvalue == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(rightmid == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;right = rightmid; <span class="keyword">break</span>;&#125;</span><br><span class="line">                    <span class="keyword">if</span>(rightmid &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[rightmid + <span class="number">1</span>] &gt; target) &#123;right = rightmid; <span class="keyword">break</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span> rightlow = rightmid + <span class="number">1</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rightmidvalue &gt; target) righthigh = rightmid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result[<span class="number">0</span>] = left; result[<span class="number">1</span>] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这题数组中出现了重复元素，想法是用三个二分法</span></span><br><span class="line"><span class="comment">先用一个二分法判断数组中有无目标元素</span></span><br><span class="line"><span class="comment">若有，其位置为mid，再在 [0, mid] 与 [mid, nums.size()-1]</span></span><br><span class="line"><span class="comment">这两个区间内分别用二分法找到目标元素与其它元素的边界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 官方代码 */</span></span><br><span class="line"><span class="comment">/* 更简洁，将二分的过程封装成了函数，实际只用了两个二分找出左右边界 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">bool</span> lower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>, ans = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIdx = binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightIdx = binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day1_69.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> low = <span class="number">1</span>, high = x / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> mid, power2;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            power2 = mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(power2 &gt; x) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(power2 &lt; x) low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> power2 &gt; x ? mid - <span class="number">1</span> : mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">简单二分</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day1_367.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = num / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &gt; num) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意 1 这种特殊情况</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day5</title>
    <url>/2023/05/30/leetcodeDay5/</url>
    <content><![CDATA[<p>LeetCode Day5<a id="more"></a></p>
<p>复健一天，继续刷题</p>
<h1>数组</h1>
<h2 id="长度最小的子数组"><a class="header-anchor" href="#长度最小的子数组">¶</a>长度最小的子数组</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day5_76(1).PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day5_76(2).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 过了，但是很low */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; tcnt;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; scnt;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tcnt[t[i]]++;</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> newSize = INT32_MAX;</span><br><span class="line">        <span class="keyword">int</span> windowSize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> subStr;</span><br><span class="line">        <span class="keyword">for</span> (; endIndex &lt; m; endIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcnt.<span class="built_in">find</span>(s[endIndex]) != tcnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                scnt[s[endIndex]]++;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it = tcnt.<span class="built_in">begin</span>(); it != tcnt.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (scnt.<span class="built_in">find</span>(it-&gt;first) == scnt.<span class="built_in">end</span>() || scnt[it-&gt;first] &lt; it-&gt;second) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (tcnt.<span class="built_in">find</span>(s[startIndex]) == tcnt.<span class="built_in">end</span>()) startIndex++;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (scnt[s[startIndex]] &gt; tcnt[s[startIndex]]) &#123;</span><br><span class="line">                            scnt[s[startIndex]]--; startIndex++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowSize = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (windowSize &lt; newSize) &#123;</span><br><span class="line">                        newSize = windowSize;</span><br><span class="line">                        subStr = s.substr(startIndex, windowSize);</span><br><span class="line">                    &#125;</span><br><span class="line">                    scnt[s[startIndex]]--; </span><br><span class="line">                    <span class="keyword">if</span> (scnt[s[startIndex]] == <span class="number">0</span>) scnt.erase(s[startIndex]);</span><br><span class="line">                    startIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subStr;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 思路是这样：</span></span><br><span class="line"><span class="comment">* 创建两个哈希表</span></span><br><span class="line"><span class="comment">* 用其中一个把 t 串中的字符统计一下</span></span><br><span class="line"><span class="comment">* 另一个代表 s 串中与 t 串相同的那些字符在滑动窗口中的个数（没有不是 0，要 erase 掉）</span></span><br><span class="line"><span class="comment">* 然后用滑动窗口过一遍</span></span><br><span class="line"><span class="comment">* 窗口：满足是覆盖字串，但不保证是最小</span></span><br><span class="line"><span class="comment">* 起始位置移动：</span></span><br><span class="line"><span class="comment">* 1. 找到满足条件的子串时，为保证是当前最小，把串从起始位置开始的多余部分剪掉</span></span><br><span class="line"><span class="comment">* 剪的同时要同步更新代表滑动窗口中字符状态的哈希表</span></span><br><span class="line"><span class="comment">* 此时起始位置一定会移动到一个在 t 串中也有的字符的位置</span></span><br><span class="line"><span class="comment">* 2. 在确定成功找到一个子串后，向前移动一个位置</span></span><br><span class="line"><span class="comment">* 结束位置移动：</span></span><br><span class="line"><span class="comment">* 窗口的结束位置就是遍历 s 的指针即 for 循环里的索引</span></span><br><span class="line"><span class="comment">* 结束位置每向前移动一次，更新哈希表，判断当前字串是否满足“覆盖”的条件</span></span><br><span class="line"><span class="comment">* 满足“覆盖”，再考虑“最小”（可行解到局部最优解）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day5_76s.gif" alt="avatar"></p>
<div align=center>LeetCode 滑动窗口演示</div><br>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 考虑优化，s 串中的无关字符使得我们做了一些无用操作</span></span><br><span class="line"><span class="comment">* 我们实际只关心 t 串中出现的字符</span></span><br><span class="line"><span class="comment">* 那么可以先预处理 s 串，丢掉 s 串中在 t 串没有出现的字符</span></span><br><span class="line"><span class="comment">* 再做滑动窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 先预处理 s 串，压缩存储 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; tcnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matchS; <span class="built_in">string</span> newS;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>(), n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tcnt[t[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcnt.<span class="built_in">find</span>(s[i]) != tcnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                newS += s[i];</span><br><span class="line">                matchS.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newSLength = newS.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>, endIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; wcnt;</span><br><span class="line">        <span class="keyword">int</span> windowLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> newSize = INT32_MAX;</span><br><span class="line">        <span class="built_in">string</span> subStr;</span><br><span class="line">        <span class="keyword">for</span> (; endIndex &lt; newSLength; endIndex++) &#123;</span><br><span class="line">            wcnt[newS[endIndex]]++;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = tcnt.<span class="built_in">begin</span>(); it != tcnt.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wcnt.<span class="built_in">find</span>(it-&gt;first) == wcnt.<span class="built_in">end</span>() || wcnt[it-&gt;first] &lt; it-&gt;second) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">while</span> (wcnt[newS[startIndex]] &gt; tcnt[newS[startIndex]]) &#123;</span><br><span class="line">                    wcnt[newS[startIndex]]--; startIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                windowLength = matchS[endIndex] - matchS[startIndex] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (windowLength &lt; newSize) &#123;</span><br><span class="line">                    newSize = windowLength;</span><br><span class="line">                    subStr = s.substr(matchS[startIndex], windowLength);</span><br><span class="line">                &#125;</span><br><span class="line">                wcnt[newS[startIndex]]--;</span><br><span class="line">                <span class="keyword">if</span> (wcnt[newS[startIndex]] == <span class="number">0</span>) wcnt.erase(wcnt[startIndex]);</span><br><span class="line">                startIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subStr;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 自己写的逻辑自己看着舒服一些</span></span><br><span class="line"><span class="comment">* 所以也不想看题解了</span></span><br><span class="line"><span class="comment">* 贴一个评论区模板在这里</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) </span><br><span class="line">        need.<span class="built_in">put</span>(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    	<span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">   	 	<span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">    	<span class="comment">// 右移窗口</span></span><br><span class="line">    	right++;</span><br><span class="line">    	<span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">    	...</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">    	System.out.<span class="built_in">println</span>(<span class="string">"window: ["</span>+left+<span class="string">","</span>+ right+<span class="string">")"</span>);</span><br><span class="line">    	<span class="comment">/********************/</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">    	<span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        	<span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">        	<span class="keyword">char</span> d = s[left];</span><br><span class="line">        	<span class="comment">// 左移窗口</span></span><br><span class="line">        	left++;</span><br><span class="line">        	<span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        	...</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day6</title>
    <url>/2023/05/31/leetcodeDay6/</url>
    <content><![CDATA[<p>LeetCode Day6<a id="more"></a></p>
<h1>数组</h1>
<h2 id="螺旋矩阵"><a class="header-anchor" href="#螺旋矩阵">¶</a>螺旋矩阵</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day6_59.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 头一次感觉比题解写的好 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkborder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isborder = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; <span class="built_in">size</span> - <span class="number">1</span> || y &gt; <span class="built_in">size</span> - <span class="number">1</span> || m[x][y] != <span class="number">0</span>) isborder = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isborder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, down = <span class="number">1</span>, left = <span class="number">2</span>, up = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> direction = right;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrix</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> elem = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nextx, nexty;</span><br><span class="line">        <span class="keyword">while</span> (elem &lt;= n * n) &#123;</span><br><span class="line">            matrix[x][y] = elem;</span><br><span class="line">            nextx = x + dx[direction], nexty = y + dy[direction];</span><br><span class="line">            <span class="keyword">if</span> (checkborder(matrix, nextx, nexty)) &#123;</span><br><span class="line">                direction++;</span><br><span class="line">                <span class="keyword">if</span> (direction &gt; up) direction = right;</span><br><span class="line">                nextx = x + dx[direction], nexty = y + dy[direction];</span><br><span class="line">            &#125;</span><br><span class="line">            x = nextx, y = nexty;</span><br><span class="line">            elem++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 思路</span></span><br><span class="line"><span class="comment">* 模拟将数字一个个填入矩阵的过程</span></span><br><span class="line"><span class="comment">* 在矩阵中，假设当前坐标为 (x, y)</span></span><br><span class="line"><span class="comment">* 向上为 (x, y) + (-1, 0) 向下为 (x, y) + (1, 0)</span></span><br><span class="line"><span class="comment">* 向左为 (x, y) + (0, -1) 向右为 (x, y) + (0, 1)</span></span><br><span class="line"><span class="comment">* 基于此，定义 dx[] 与 dy[]</span></span><br><span class="line"><span class="comment">* 再按顺时针排列为右下左上</span></span><br><span class="line"><span class="comment">* 现在就只缺一个边界检查函数了，于是定义 checkborder 函数</span></span><br><span class="line"><span class="comment">* 用来检测四个边界和已经填过的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 代码随想录的题解 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>; <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="keyword">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 时间复杂度 O(n^2): 模拟遍历二维矩阵的时间</span></span><br><span class="line"><span class="comment">* 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day6_54(1).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day6_54(2).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 加一个 visited 二维数组来判断是否访问过 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leq;</span><br><span class="line">        <span class="keyword">int</span> sizex = matrix.<span class="built_in">size</span>(), sizey = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(sizex, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(sizey, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, down = <span class="number">1</span>, left = <span class="number">2</span>, up = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> direction = right;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nx, ny;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, xy = sizex * sizey;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; xy) &#123;</span><br><span class="line">            leq.push_back(matrix[x][y]);</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            nx = x + dx[direction], ny = y + dy[direction];</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt; sizex - <span class="number">1</span> || ny &gt; sizey - <span class="number">1</span> || visited[nx][ny]) &#123;</span><br><span class="line">                direction++;</span><br><span class="line">                <span class="keyword">if</span> (direction &gt; up) direction = right;</span><br><span class="line">                nx = x + dx[direction], ny = y + dy[direction];</span><br><span class="line">            &#125;</span><br><span class="line">            x = nx, y = ny;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day6_TheSwordReferstotheOffer29.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 与上题同 */</span></span><br><span class="line"><span class="comment">/* 但得在开始加上下面这句：考虑空矩阵 */</span></span><br><span class="line"><span class="keyword">if</span> (matrix.empty()) <span class="keyword">return</span> leq;</span><br></pre></td></tr></table></figure>
<h2 id="数组总结篇"><a class="header-anchor" href="#数组总结篇">¶</a>数组总结篇</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day6_summarize(1).PNG" alt="avatar"></p>
<div align=center>个人总结</div><br>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day6_summarize(2).PNG" alt="avatar"></p>
<div align=center>来自代码随想录</div><br>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day9</title>
    <url>/2023/06/07/leetcodeDay9/</url>
    <content><![CDATA[<p>LeetCode Day9<a id="more"></a></p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day7</title>
    <url>/2023/06/03/leetcodeDay7/</url>
    <content><![CDATA[<p>LeetCode Day7<a id="more"></a></p>
<h1>链表</h1>
<p><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" target="_blank" rel="noopener">链表理论基础</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数初始化节点</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="移除链表元素"><a class="header-anchor" href="#移除链表元素">¶</a>移除链表元素</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day7_203.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* del = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(del);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 注意题设中的 head 头结点</span></span><br><span class="line"><span class="comment">* 不是真正的头结点，而是链表的第一个结点</span></span><br><span class="line"><span class="comment">* 考虑到可能删掉所有的结点，有必要设置一个头结点</span></span><br><span class="line"><span class="comment">* 但是返回的时候是返回题设所要求的头结点</span></span><br><span class="line"><span class="comment">* 然后就是注意手动释放内存</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day7_203s.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 直接用题设的 head，那么涉及到 head 的操作就要单独处理 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意这里不是if</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="设计链表"><a class="header-anchor" href="#设计链表">¶</a>设计链表</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day7_707(1).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day7_707(2).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表结点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkedNode</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        LinkedNode(<span class="keyword">int</span> val) : val(val), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> LinkedNode(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到第 index 个结点数值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size - <span class="number">1</span> || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">        LinkedNode* temp = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; index) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头插</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> LinkedNode(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾插</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* temp = _dummyHead;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> LinkedNode(val);</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个结点之前插入一个新结点，例如 index 为 0，那么新插入的结点为链表的新头结点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的结点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="comment">// 如果 index 小于 0，则在头部插入结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == _size) &#123;</span><br><span class="line">            addAtTail(val); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* temp = _dummyHead;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> LinkedNode(val);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; index) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第 index 个结点，如果 index 大于等于链表的长度，直接 return</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode* temp = _dummyHead;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; index) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* del = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(del);</span><br><span class="line">        <span class="comment">// delete 命令指示释放了 del 指针原本所指的那部分内存，</span></span><br><span class="line">        <span class="comment">// 被 delete 后的指针 del 的值（地址）并非就是 NULL，而是随机值。也就是被 delete 后，</span></span><br><span class="line">        <span class="comment">// 如果不再加上一句 del = nullptr，del 会成为乱指的野指针</span></span><br><span class="line">        <span class="comment">// 如果之后的程序不小心使用了 del，会指向难以预想的内存空间</span></span><br><span class="line">        del = <span class="literal">nullptr</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line">    <span class="comment">// 这里的 _dummyHead 才是一般数据结构中描述的头结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyLinkedList* myLinkedList = <span class="keyword">new</span> MyLinkedList();</span><br><span class="line">    myLinkedList-&gt;addAtHead(<span class="number">1</span>);</span><br><span class="line">    myLinkedList-&gt;addAtTail(<span class="number">3</span>);</span><br><span class="line">    myLinkedList-&gt;addAtIndex(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 链表变为 1-&gt;2-&gt;3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myLinkedList-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 返回 2</span></span><br><span class="line">    myLinkedList-&gt;deleteAtIndex(<span class="number">1</span>);         <span class="comment">// 现在，链表变为 1-&gt;3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myLinkedList-&gt;<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 返回 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day8</title>
    <url>/2023/06/05/leetcodeDay8/</url>
    <content><![CDATA[<p>LeetCode Day8<a id="more"></a></p>
<h1>链表</h1>
<h2 id="翻转链表"><a class="header-anchor" href="#翻转链表">¶</a>翻转链表</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_206.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* tail = dummyHead-&gt;next;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = tail-&gt;next;</span><br><span class="line">            tail-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = dummyHead-&gt;next;</span><br><span class="line">            dummyHead-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 思路：</span></span><br><span class="line"><span class="comment">* 先构造头结点</span></span><br><span class="line"><span class="comment">* 不断把后面的元素前插到单链表头结点的后面</span></span><br><span class="line"><span class="comment">* 使得反转过程就是前插的一个过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 随想录中的思路：</span></span><br><span class="line"><span class="comment">* 改变链表的next指针的指向，直接将链表反转 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_206s.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双指针法 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null</span></span><br><span class="line"><span class="comment">* 把 cur-&gt;next 节点用 tmp 指针保存一下，也就是保存一下这个节点</span></span><br><span class="line"><span class="comment">* 为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了</span></span><br><span class="line"><span class="comment">* 将 cur-&gt;next 指向 pre ，此时已经反转了第一个节点了</span></span><br><span class="line"><span class="comment">* 接下来，就是循环走如下代码逻辑了，继续移动 pre 和 cur 指针</span></span><br><span class="line"><span class="comment">* 最后，cur 指针已经指向了 null，循环结束，链表也反转完毕了</span></span><br><span class="line"><span class="comment">* 此时我们 return pre 指针就可以了，pre 指针就指向了新的头结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* temp;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = cur-&gt;next;   <span class="comment">// 保存 cur-&gt;next，作更新 cur 之用</span></span><br><span class="line">        cur-&gt;next = pre;    <span class="comment">// 翻转操作</span></span><br><span class="line">        pre = cur;          <span class="comment">// 先更新 pre</span></span><br><span class="line">        cur = temp;         <span class="comment">// 后更新 cur</span></span><br><span class="line">    &#125;</span><br><span class="line">    head = pre; <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度: O(n) 空间复杂度: O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归法 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把双指针法中两个指针的更新写成递归 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;   <span class="comment">// 递归出口</span></span><br><span class="line">    ListNode* temp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = pre;              <span class="comment">// 翻转操作</span></span><br><span class="line">    <span class="comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></span><br><span class="line">    <span class="comment">// pre = cur;</span></span><br><span class="line">    <span class="comment">// cur = temp;</span></span><br><span class="line">    <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和双指针法初始化是一样的逻辑</span></span><br><span class="line">    <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">    <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">    <span class="keyword">return</span> reverse(<span class="literal">NULL</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度: O(n), 要递归处理链表的每个节点</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n), 递归调用了 n 层栈空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从后往前翻转的递归 */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边缘条件判断</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用，翻转第二个节点开始往后的链表</span></span><br><span class="line">    ListNode *last = reverseList(head-&gt;next);</span><br><span class="line">    <span class="comment">// 翻转头节点与第二个节点的指向</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 此时的 head 节点为尾节点，next 需要指向 NULL</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度: O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n)</span></span><br></pre></td></tr></table></figure>
<h2 id="两两交换链表中的节点"><a class="header-anchor" href="#两两交换链表中的节点">¶</a>两两交换链表中的节点</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_24(1).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_24(2).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* pre, * cur1, * cur2;</span><br><span class="line">        pre = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur1 = pre-&gt;next;</span><br><span class="line">            cur2 = cur1-&gt;next;</span><br><span class="line"></span><br><span class="line">            pre-&gt;next = cur2;</span><br><span class="line">            cur1-&gt;next = cur2-&gt;next;</span><br><span class="line">            cur2-&gt;next = cur1;</span><br><span class="line"></span><br><span class="line">            pre = cur1;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 画图，分清步骤先后即可 </span></span><br><span class="line"><span class="comment">* 注意不要非法内存引用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_24s.PNG" alt="avatar"></p>
<h2 id="删除链表的倒数第N个节点"><a class="header-anchor" href="#删除链表的倒数第N个节点">¶</a>删除链表的倒数第N个节点</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_19(1).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_19(2).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(ListNode* pre)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findN</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        findN(node-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (!(cnt--)) removeNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt = n;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        findN(cur);</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Solution::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 能过，但很拉</span></span><br><span class="line"><span class="comment">* 想到了回溯和静态变量</span></span><br><span class="line"><span class="comment">* 通过这俩结合找到要删除元素的前一个元素</span></span><br><span class="line"><span class="comment">* 然后执行删除</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 比较合适的是用快慢指针法 */</span></span><br><span class="line"><span class="comment">/* 快慢指针还可以检测链表是否有环，即答qwq */</span></span><br><span class="line"><span class="comment">/* 快指针走慢指针的两倍速，相遇即有环（无环不可能相遇） */</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_19s1.PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_19s2.PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_19s3.PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_19s4.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 快慢指针法来解</span></span><br><span class="line"><span class="comment">* 就是让 fastIndex 先走 n 步， 然后 slowIndex 再和其一起走</span></span><br><span class="line"><span class="comment">* 直到 fastIndex 走到链表的最后一个结点</span></span><br><span class="line"><span class="comment">* 即 fastIndex-&gt;next == nullptr 时</span></span><br><span class="line"><span class="comment">* 此时 slowIndex 就走到了倒数第 n 个结点的前一个结点</span></span><br><span class="line"><span class="comment">* 开始删除操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fastIndex, * slowIndex;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        fastIndex = dummyHead; slowIndex = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123; fastIndex = fastIndex-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span> (fastIndex-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fastIndex = fastIndex-&gt;next;</span><br><span class="line">            slowIndex = slowIndex-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = slowIndex-&gt;next;</span><br><span class="line">        slowIndex-&gt;next = slowIndex-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(temp);</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="相交链表"><a class="header-anchor" href="#相交链表">¶</a>相交链表</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_160(1).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_160(2).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_160(3).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* IntersectionNode = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* dummyHeadA = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        dummyHeadA-&gt;next = headA;</span><br><span class="line">        ListNode* dummyHeadB = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHeadB-&gt;next = headB;</span><br><span class="line">        ListNode* indexA = dummyHeadA, * indexB = dummyHeadB;</span><br><span class="line">        <span class="keyword">int</span> sizeA = <span class="number">0</span>, sizeB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (indexA-&gt;next != <span class="literal">nullptr</span>) &#123; sizeA++; indexA = indexA-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span> (indexB-&gt;next != <span class="literal">nullptr</span>) &#123; sizeB++; indexB = indexB-&gt;next; &#125;</span><br><span class="line">        indexA = dummyHeadA, indexB = dummyHeadB;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">abs</span>(sizeA - sizeB);</span><br><span class="line">        <span class="keyword">if</span> (sizeA &gt; sizeB) <span class="keyword">while</span> (n--) &#123; indexA = indexA-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">if</span> (sizeA &lt; sizeB) <span class="keyword">while</span> (n--) &#123; indexB = indexB-&gt;next; &#125;</span><br><span class="line">        <span class="keyword">while</span> (indexA != <span class="literal">nullptr</span> &amp;&amp; indexB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexA == indexB) &#123;</span><br><span class="line">                IntersectionNode = indexA;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexA = indexA-&gt;next, indexB = indexB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IntersectionNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 是指针相等而不是数值相等</span></span><br><span class="line"><span class="comment">* 让较长的链表的指针先走一个长度差</span></span><br><span class="line"><span class="comment">* 这样两边对齐后就可以一起走</span></span><br><span class="line"><span class="comment">* 边走边判断两边指针是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_160s.PNG" alt="avatar"></p>
<h2 id="环形链表"><a class="header-anchor" href="#环形链表">¶</a>环形链表</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_142(1).PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_142(2).PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* firstnodeofcycle = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head, * slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，说明链表有环</span></span><br><span class="line">            <span class="comment">// 此时从 head 和相遇点同时出发两个指针</span></span><br><span class="line">            <span class="comment">// 其相遇时即找到环入口</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                firstnodeofcycle = index1;</span><br><span class="line">                <span class="keyword">return</span> firstnodeofcycle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstnodeofcycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试程序 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* firstNodeOfCycle = detectCycle(head);</span><br><span class="line">    <span class="comment">// if (firstNodeOfCycle != NULL) printf("%d\n", firstNodeOfCycle-&gt;val);</span></span><br><span class="line">    <span class="keyword">if</span> (firstNodeOfCycle == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">"No Cycle\n"</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line">    ListNode* temp = firstNodeOfCycle;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;val);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (temp != firstNodeOfCycle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* node_1 = <span class="keyword">new</span> ListNode(<span class="number">-4</span>);</span><br><span class="line">    ListNode* node_2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>, node_1);</span><br><span class="line">    ListNode* node_3 = <span class="keyword">new</span> ListNode(<span class="number">2</span>, node_2);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">3</span>, node_3);</span><br><span class="line">    <span class="comment">// printList(head);</span></span><br><span class="line"></span><br><span class="line">    node_1-&gt;next = node_3;</span><br><span class="line">    <span class="comment">// printList(head);</span></span><br><span class="line"></span><br><span class="line">    printCycle(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 分解成两个问题</span></span><br><span class="line"><span class="comment">* 先判断链表是否有环</span></span><br><span class="line"><span class="comment">* 若有环，找到这个环的入口</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_142s1.PNG" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_142s.gif" alt="avatar"></p>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_142s2.PNG" alt="avatar"></p>
<p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E8%A1%A5%E5%85%85" target="_blank" rel="noopener"><strong>补充</strong>：为什么第一次在环中相遇，slow的 步数 是 x + y 而不是 x + 若干环的长度 + y</a></p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_summarize(1).PNG" alt="avatar"></p>
<div align=center>个人总结</div><br>
<p><img src="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E9%93%BE%E8%A1%A8/day8_summarize(2).PNG" alt="avatar"></p>
<div align=center>来自代码随想录</div><br>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day3</title>
    <url>/2023/03/13/leetcodeDay3/</url>
    <content><![CDATA[<p>LeetCode Day3<a id="more"></a></p>
<h1>数组</h1>
<h2 id="移除元素"><a class="header-anchor" href="#移除元素">¶</a>移除元素</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day3_283.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 复习一下双指针法 */</span></span><br><span class="line"><span class="comment">/* 添加一个 cnt 计数，最后再补上 cnt 个 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (; fastIndex &lt; len; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fastIndex != slowIndex) nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = slowIndex; i &lt; slowIndex + cnt; i++) nums[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day3_844.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用双指针法 */</span></span><br><span class="line"><span class="comment">/* 时间复杂度 O(n)，空间复杂度 O(1) */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dealwithString</span><span class="params">(<span class="built_in">string</span> Str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> back = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; fastIndex &lt; Str.length(); fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Str[fastIndex] != back)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fastIndex != slowIndex) Str[slowIndex] = Str[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(slowIndex &gt; <span class="number">0</span>) slowIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Str.substr(<span class="number">0</span>, slowIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dealwithString(s) == dealwithString(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也可以用栈来实现 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dealwithString</span><span class="params">(<span class="built_in">string</span> Str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> back = <span class="string">'#'</span>;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; StrS;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Str[i] == back) &#123; <span class="keyword">if</span>(!StrS.empty()) StrS.pop(); &#125;</span><br><span class="line">            <span class="keyword">else</span> StrS.push(Str[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!StrS.empty()) &#123; result += StrS.top(); StrS.pop(); &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dealwithString(s) == dealwithString(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day3_977.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双指针法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> border = len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) &#123; border = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> negIndex = border - <span class="number">1</span>, posIndex = border;</span><br><span class="line">        <span class="keyword">int</span> negpower, pospower;</span><br><span class="line">        <span class="keyword">while</span> (negIndex &gt;= <span class="number">0</span> || posIndex &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (negIndex &gt;= <span class="number">0</span>) negpower = nums[negIndex] * nums[negIndex];</span><br><span class="line">            <span class="keyword">if</span> (posIndex &lt; len) pospower = nums[posIndex] * nums[posIndex];</span><br><span class="line">            <span class="keyword">if</span> (negIndex &lt; <span class="number">0</span>) &#123; ans.push_back(pospower); posIndex++; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (posIndex == len) &#123; ans.push_back(negpower); negIndex--; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (negpower &lt; pospower) &#123; ans.push_back(negpower); negIndex--; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; ans.push_back(pospower); posIndex++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找到正负数交界的数组索引，将数组分为两段</span></span><br><span class="line"><span class="comment">用双指针法，将两个数组中指针指向的值较小的那一个放入结果数组中去</span></span><br><span class="line"><span class="comment">（类似并归排序）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>上机实验的一些事儿</title>
    <url>/2020/10/30/%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h1>上机实验的一些事儿</h1>
<h2 id="C语言中当指针作为函数的参数传递"><a class="header-anchor" href="#C语言中当指针作为函数的参数传递">¶</a>C语言中当指针作为函数的参数传递</h2>
<p>在写二叉树的先序创建时遇到的一个问题，刚开始写的时候，总想着传指针到函数里，然后递归创建二叉树，但实际上只创建了根结点，其他节点都没有连上，导致后面的先序遍历一直抛出异常，其他的地方不大可能出错，一定是传参的问题，但是它看起来也挺正常啊，一时间笔者感到深深的迷惑<a id="more"></a></p>
<blockquote>
<p>下面是错误的代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span>                       <span class="comment">// 创建结构体</span></span><br><span class="line">    <span class="keyword">int</span> data;                       <span class="comment">// 数据域</span></span><br><span class="line">    tree* lchild;                   <span class="comment">// 左孩子结点 指针域</span></span><br><span class="line">    tree* rchild;                   <span class="comment">// 右孩子结点 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line">tree* root = <span class="literal">NULL</span>;                  <span class="comment">// 全局定义树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_tree</span><span class="params">(tree* p)</span> </span>&#123;          <span class="comment">// 先序创建二叉树</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="number">0</span>) p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) root = p;</span><br><span class="line">        p-&gt;data = data;</span><br><span class="line">        creat_tree(p-&gt;lchild);  </span><br><span class="line">        creat_tree(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，万能的哥们跟我讲，指针创建链式结构不要像下面这么写，这么写基本上是要出问题的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_tree</span><span class="params">(tree* p)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 省略 */</span></span><br><span class="line">    creat_tree(p-&gt;lchild);</span><br><span class="line">    <span class="comment">/* 省略 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该这么写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tree* <span class="title">creat_tree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 省略 */</span></span><br><span class="line">    p-&gt;lchild = creat_tree();</span><br><span class="line">    <span class="comment">/* 省略 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样马上就看出了区别，在前一种写法中，实参即传进函数的指针 <code>p-&gt;lchild</code> 原来指向一个 <code>地址1</code>，于是进入函数后，形参，也就是指针 <code>p</code> ，也只是指向 <code>地址1</code> 罢了，对此时的指针 <code>p</code> 的赋值操作 <code>p-&gt;data = data;</code> 根本与之前的 <code>p-&gt;lchild</code> 无关，更不用说此时的 <code>p-&gt;lchild</code> 了，这样子写来创建二叉树根本是无效的，应当采用函数返回值的方式</p>
<blockquote>
<p>于是将上述错误代码修改并补全成以下代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 先序创建二叉树 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span>                       <span class="comment">// 创建结构体</span></span><br><span class="line">    <span class="keyword">int</span> data;                       <span class="comment">// 数据域</span></span><br><span class="line">    tree* lchild;                   <span class="comment">// 左孩子结点 指针域</span></span><br><span class="line">    tree* rchild;                   <span class="comment">// 右孩子结点 指针域</span></span><br><span class="line">&#125;;</span><br><span class="line">tree* root = <span class="literal">NULL</span>;                  <span class="comment">// 全局定义树的根结点</span></span><br><span class="line"><span class="function">tree* <span class="title">creat_tree</span><span class="params">()</span> </span>&#123;                <span class="comment">// 先序创建二叉树</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    tree* p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="number">0</span>) p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) root = p;</span><br><span class="line">        p-&gt;data = data;</span><br><span class="line">        p-&gt;lchild = creat_tree();  </span><br><span class="line">        p-&gt;rchild = creat_tree();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre_Order_Traverse</span><span class="params">(tree* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">        Pre_Order_Traverse(p-&gt;lchild);</span><br><span class="line">        Pre_Order_Traverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    creat_tree();</span><br><span class="line">    Pre_Order_Traverse(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试样例：</p>
<p>先序创建二叉树后先序遍历输出<br>
15 98 20 30 0 0 40 0 0 10 0 0 6 45 0 60 70 0 0 0 0</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/%E5%85%88%E5%BA%8F%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B7%E4%BE%8B.png" alt="avatar"></p>
<p>测试结果：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/%E5%85%88%E5%BA%8F%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.PNG" alt="avatar"></p>
<h2 id="层次遍历的优化"><a class="header-anchor" href="#层次遍历的优化">¶</a>层次遍历的优化</h2>
<p>C语言中没有队列，不能使用常规的 BFS（广度优先搜索）来进行层次遍历，于是想到了运用二叉树的一个性质：即，若当前结点为编号为 $i$ ，则其 lchild 结点的编号应为 $2i$ ，其 rchild 结点的编号应为 $2i+1$，那么就可以先建立一个足够大的数组 <code>Tree</code> ，先将其全部初始化为 $0$ ，在先序创建二叉树的时候以 <code>Tree[结点编号] = 结点的数值</code> 的方式更新数组，相当于将这颗树按编号顺序存储到Tree数组里，最后依序输出数组的非零值即可完成二叉树的层次遍历。</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Cpp/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91_1.png" alt="avatar"></p>
<p>实现的部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BiTNode* lchild, * rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Tree[maxn];                 <span class="comment">// 全局定义一个数组存储结点，以便层次遍历</span></span><br><span class="line"><span class="keyword">int</span> index;                      <span class="comment">// 全局定义Tree数组的索引</span></span><br><span class="line"><span class="keyword">int</span> index_max;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">Create_BiTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/* 省略 */</span></span><br><span class="line">    Node-&gt;data = data;</span><br><span class="line">    Tree[index] = data;</span><br><span class="line">    index *= <span class="number">2</span>; <span class="keyword">if</span> (index &gt; index_max) index_max = index;</span><br><span class="line">    Node-&gt;lchild = Create_BiTree();</span><br><span class="line">    index++;    <span class="keyword">if</span> (index &gt; index_max) index_max = index;</span><br><span class="line">    Node-&gt;rchild = Create_BiTree();</span><br><span class="line">    index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 省略 */</span></span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Level_Traversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Level Traversal:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= index_max; i++)</span><br><span class="line">        <span class="keyword">if</span> (Tree[i] != <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, Tree[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然完成了层次遍历，但是一旦结点个数多起来，就需要一个巨大的数组来存储，并且如果树还比较稀疏，浪费的空间占所有存储的空间的比例就会很高，这显然不是一个好的算法。</p>
<p>这时，万能的哥们又及时提供了帮助：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(BiTNode* p, <span class="keyword">int</span> lev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lev &lt; <span class="number">1</span> || p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; lev == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">    level(p-&gt;lchild, lev - <span class="number">1</span>);</span><br><span class="line">    level(p-&gt;rchild, lev - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _Level_Fraversal(BiTNode* p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Level Traversal:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= DeepMax; i++) level(p, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完美地去掉了数组</p>
<hr>
<h1>附</h1>
<h2 id="二叉树程序设计完整代码"><a class="header-anchor" href="#二叉树程序设计完整代码">¶</a>二叉树程序设计完整代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***** 二叉树及其遍历的C语言实现 *****/</span></span><br><span class="line"><span class="comment">/*****   实验二 二叉树程序设计   *****/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一、实验目的及要求</span></span><br><span class="line"><span class="comment">1．掌握二叉树的定义及其链式存储结构。</span></span><br><span class="line"><span class="comment">2．掌握二叉树的先序遍历、中序遍历和后序遍历，并将结果序列输出。</span></span><br><span class="line"><span class="comment">二、实验内容</span></span><br><span class="line"><span class="comment">1. 先序创建二叉树。</span></span><br><span class="line"><span class="comment">2. 计算树的层次、先序、中序和后序遍历。</span></span><br><span class="line"><span class="comment">3. 并输出叶子结点个数以及二叉树的高度。</span></span><br><span class="line"><span class="comment">三、实验步骤和要求</span></span><br><span class="line"><span class="comment">以下图所示的二叉树为例编制程序，实现实验内容中所述功能。</span></span><br><span class="line"><span class="comment">Undirected</span></span><br><span class="line"><span class="comment">Node Count:</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">Graph Data:</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">98</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">45</span></span><br><span class="line"><span class="comment">30</span></span><br><span class="line"><span class="comment">40</span></span><br><span class="line"><span class="comment">60</span></span><br><span class="line"><span class="comment">70</span></span><br><span class="line"><span class="comment">15 98</span></span><br><span class="line"><span class="comment">15 6</span></span><br><span class="line"><span class="comment">6 45</span></span><br><span class="line"><span class="comment">45 60</span></span><br><span class="line"><span class="comment">60 70</span></span><br><span class="line"><span class="comment">98 20</span></span><br><span class="line"><span class="comment">98 10</span></span><br><span class="line"><span class="comment">20 30</span></span><br><span class="line"><span class="comment">20 40</span></span><br><span class="line"><span class="comment">四、实验结果分析</span></span><br><span class="line"><span class="comment">对实验结果进行检验，如结果出现错误，分析产生错误的原因并修改程序、改正错误。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span>                    <span class="comment">// 二叉树的二叉链表存储</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BiTNode* lchild, * rchild;              <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BiTNode* BT = <span class="literal">NULL</span>;                         <span class="comment">// 全局定义树的根结点</span></span><br><span class="line"><span class="keyword">int</span> LeafNodecnt = <span class="number">0</span>;                        <span class="comment">// 全局定义树的叶子结点数</span></span><br><span class="line"><span class="keyword">int</span> Deep = <span class="number">0</span>;                               <span class="comment">// 全局定义当前深度</span></span><br><span class="line"><span class="keyword">int</span> DeepMax = <span class="number">0</span>;                            <span class="comment">// 全局定义二叉树深度</span></span><br><span class="line"><span class="keyword">int</span> Tree[maxn];                             <span class="comment">// 全局定义一个数组存储结点，以便层次遍历</span></span><br><span class="line"><span class="keyword">int</span> index;                                  <span class="comment">// 全局定义Tree数组的索引</span></span><br><span class="line"><span class="keyword">int</span> index_max;</span><br><span class="line">FILE* fin = fopen(<span class="string">"In.txt"</span>, <span class="string">"r+"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">BiTNode* <span class="title">Create_BiTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    BiTNode* Node;</span><br><span class="line">    <span class="built_in">fscanf</span>(fin,<span class="string">"%d"</span>, &amp;data);</span><br><span class="line">    <span class="comment">//scanf("%d",&amp;data);</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0</span>) Node = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(Node = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)))) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR!"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (BT == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            BT = Node;</span><br><span class="line">        &#125;</span><br><span class="line">        Node-&gt;data = data;</span><br><span class="line">        Tree[index] = data;</span><br><span class="line">        Deep++;</span><br><span class="line">        <span class="keyword">if</span> (Deep &gt; DeepMax) DeepMax = Deep;</span><br><span class="line">        index *= <span class="number">2</span>; <span class="keyword">if</span> (index &gt; index_max) index_max = index;</span><br><span class="line">        Node-&gt;lchild = Create_BiTree();</span><br><span class="line">        index++;    <span class="keyword">if</span> (index &gt; index_max) index_max = index;</span><br><span class="line">        Node-&gt;rchild = Create_BiTree();</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        Deep--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pre_Order_Traverse</span><span class="params">(BiTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">        Pre_Order_Traverse(p-&gt;lchild);</span><br><span class="line">        Pre_Order_Traverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">In_Order_Traverse</span><span class="params">(BiTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        In_Order_Traverse(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">        In_Order_Traverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Post_Order_Traverse</span><span class="params">(BiTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Post_Order_Traverse(p-&gt;lchild);</span><br><span class="line">        Post_Order_Traverse(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Level_Traversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Level Traversal:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= index_max; i++)</span><br><span class="line">        <span class="keyword">if</span> (Tree[i] != <span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"%d\t"</span>, Tree[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(BiTNode* p, <span class="keyword">int</span> lev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lev &lt; <span class="number">1</span> || p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; lev == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, p-&gt;data);</span><br><span class="line">    level(p-&gt;lchild, lev - <span class="number">1</span>);</span><br><span class="line">    level(p-&gt;rchild, lev - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _Level_Fraversal(BiTNode* p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Level Traversal:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= DeepMax; i++) level(p, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pretrav_fln</span><span class="params">(BiTNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) LeafNodecnt++;</span><br><span class="line">        pretrav_fln(p-&gt;lchild);</span><br><span class="line">        pretrav_fln(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_leaf_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTNode* p = BT;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Leaf Node:"</span>);</span><br><span class="line">    pretrav_fln(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LeafNodecnt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Count_Deepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Deepth:%d\n"</span>, DeepMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(Tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    Create_BiTree();                    <span class="comment">// 先序创建二叉树</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Pre-Order:\n"</span>);             <span class="comment">// 先序遍历</span></span><br><span class="line">    Pre_Order_Traverse(BT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In-Order:\n"</span>);              <span class="comment">// 中序遍历</span></span><br><span class="line">    In_Order_Traverse(BT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Post-Order:\n"</span>);            <span class="comment">// 后序遍历</span></span><br><span class="line">    Post_Order_Traverse(BT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    Level_Traversal();                  <span class="comment">// 层次遍历 法1</span></span><br><span class="line"></span><br><span class="line">    _Level_Fraversal(BT);               <span class="comment">// 层次遍历 法2</span></span><br><span class="line"></span><br><span class="line">    Find_leaf_node();                   <span class="comment">// 叶子结点个数</span></span><br><span class="line"></span><br><span class="line">    Count_Deepth();                     <span class="comment">// 二叉树高度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二分三分快速幂矩阵快速幂</title>
    <url>/2022/06/22/%E4%BA%8C%E5%88%86%E4%B8%89%E5%88%86%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=7" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356175" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-二分三分快速幂矩阵快速幂</a> Password: bitacm2020<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>二分三分快速幂矩阵快速幂</h1>
<h2 id="二分法"><a class="header-anchor" href="#二分法">¶</a>二分法</h2>
<ul>
<li>思想简单，主要讲实现</li>
<li>写法多种多样</li>
<li>lower_bound upper_bound(begin, end, val)</li>
</ul>
<h3 id="解决问题"><a class="header-anchor" href="#解决问题">¶</a>解决问题</h3>
<ul>
<li>具有单调性 / 连续性的问题二分查找</li>
<li>最大最小问题  / 最小最大问题二分答案</li>
<li>判断前缀的合法性二分前缀长度</li>
<li>分数规划问题二分答案</li>
</ul>
<h3 id="小数"><a class="header-anchor" href="#小数">¶</a>小数</h3>
<ul>
<li>规定精度 eps = 1e-6 or 1e-8</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> left, right, mid;</span><br><span class="line"><span class="keyword">while</span> (right - left &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">    mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (judge(mid)) left = mid;</span><br><span class="line">    <span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure>
<h3 id="二分答案"><a class="header-anchor" href="#二分答案">¶</a>二分答案</h3>
<ul>
<li>适用情况：求最值，可能答案区间有限且单调，检验答案合理性复杂度低</li>
</ul>
<p>一个例子</p>
<p>如果一个数列中 2*K 的元素中前 K 个元素和与后 K 个元素和都不大于 S。那么我们说这些元素是有趣的。给定 S，给你一个长度为 N 的数列，求各个元素从本身开始能构成的最长有趣元素的长度。</p>
<p>二分答案的写法模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (judge(mid))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = mid;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
<p>【例】aggressive cows</p>
<ul>
<li>
<p>有 n 个牛栏，分别位于 X1，X2，…Xn。选 m 个放进牛，使得相邻牛之间的最小距离值最大。<br>
其中，m &lt;= n &lt;= 1e5，0 &lt;= Xi &lt;= 1e9</p>
</li>
<li>
<p>二分答案的标志：最小值最大 / 最大值最小</p>
</li>
</ul>
<p>【例】Multiplication Table</p>
<ul>
<li>
<p>有 n * m 乘法表，将 n * m 个数从小到大依次排列，第 K 个数是多少？<br>
其中，K &lt;= n, m &lt;= 5e5</p>
</li>
<li>
<p>二分的过程很简单，重点是判断答案的合理性</p>
</li>
</ul>
<h2 id="三分法"><a class="header-anchor" href="#三分法">¶</a>三分法</h2>
<ul>
<li>
<p>二分：单调区间</p>
</li>
<li>
<p>三分：凸性函数</p>
</li>
</ul>
<p>以求最大值为例</p>
<ul>
<li>对比 f(lmid) 与 f(rmid)</li>
<li>若 f(lmid) &lt; f(rmid) 那么区间变为 lmid ~ r</li>
<li>否则变为 l ~ rmid</li>
</ul>
<p>（图解）</p>
<h2 id="快速幂"><a class="header-anchor" href="#快速幂">¶</a>快速幂</h2>
<ul>
<li>
<p>求 $a^b \bmod p$</p>
</li>
<li>
<p>$a^{2i} = a^i \cdot a^i$<br>
快速求出 $a<sup>2$，$a</sup>4$，$a<sup>8$，$a</sup>{16} \dots$<br>
将 $b$ 做二进制拆分<br>
$a^b = a^{b_1} \cdot a^{b_2} \cdot \dots \cdot a^{b_k}$</p>
</li>
<li>
<p>$O(\log b)$</p>
</li>
</ul>
<h3 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>; a = a % mod;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a class="header-anchor" href="#矩阵快速幂">¶</a>矩阵快速幂</h2>
<h3 id="矩阵乘法"><a class="header-anchor" href="#矩阵乘法">¶</a>矩阵乘法</h3>
<ul>
<li>
<p>$c_{ij} = \sum a_{ik} \times b_{kj}$</p>
</li>
<li>
<p>第一个矩阵是 $n \times m$，第二个矩阵是 $m \times p$</p>
</li>
<li>
<p>$O(nmp)$</p>
</li>
</ul>
<h3 id="矩阵快速幂-v2"><a class="header-anchor" href="#矩阵快速幂-v2">¶</a>矩阵快速幂</h3>
<ul>
<li>
<p>将快速幂中的底数变为矩阵</p>
</li>
<li>
<p>优势：线性递推式</p>
</li>
</ul>
<p>【例】斐波那契数列</p>
<ul>
<li>求斐波那契数列的第 n 项，n &lt;= 1e18<br>
$F_i = F_{i-1} + F_{i-2}$，$F_1, F_0 = 1$</li>
</ul>
<p>$\begin{pmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{pmatrix} \times \begin{pmatrix} F_{i-1} \ F_{i-2} \end{pmatrix} = \begin{pmatrix} F_i \ F_{i-1} \end{pmatrix}$</p>
<p>$\begin{pmatrix} F_n \ F_{n-1} \end{pmatrix} = \begin{pmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{pmatrix}^{n-1} \times \begin{pmatrix} F_1 \ F_0 \end{pmatrix}$</p>
<p>$\begin{pmatrix} F_{i-2} &amp; F_{i-1} \ a &amp; b \end{pmatrix} \times \begin{pmatrix} 0 &amp; 1 \ 1 &amp; 1 \end{pmatrix} = \begin{pmatrix} F_{i-2} &amp; F_{i-1} \ b &amp; a + b \end{pmatrix}$</p>
<h3 id="一些递推式"><a class="header-anchor" href="#一些递推式">¶</a>一些递推式</h3>
<p>推广，根据状态逆推系数矩阵</p>
<p>$F_i = a * F_{i-1} + b * F_{i-2}$</p>
<p>$\begin{pmatrix} a &amp; b \ 1 &amp; 0 \end{pmatrix} \times \begin{pmatrix} F_{i-1} \ F_{i-2} \end{pmatrix} = \begin{pmatrix} F_i \ F_{i-1} \end{pmatrix}$</p>
<p>$\begin{pmatrix} F_n \ F_{n-1} \end{pmatrix} = \begin{pmatrix} a &amp; b \ 1 &amp; 0 \end{pmatrix}^{n-1} \times \begin{pmatrix} F_1 \ F_0 \end{pmatrix}$</p>
<p>$F_i = a * F_{i-1} + i$</p>
<p>$\begin{pmatrix} a &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 1 \ 0 &amp; 0 &amp; 1 \end{pmatrix} \times \begin{pmatrix} F_{i-1} \ i-1 \ 1 \end{pmatrix} = \begin{pmatrix} F_i \ i \ 1 \end{pmatrix}$</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>使用数据对齐以提高内存系统的性能</title>
    <url>/2022/04/10/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90%E4%BB%A5%E6%8F%90%E9%AB%98%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h2 id="原理介绍"><a class="header-anchor" href="#原理介绍">¶</a>原理介绍</h2>
<p>计算机系统对基本数据类型的合法地址做出了对齐限制，要求某种类型对象的地址必须是某个值 K 的倍数，K 值通常取 2、4 或者 8，这就叫做数据对齐<a id="more"></a></p>
<p>数据对齐的作用是，简化形成处理器和内存系统之间接口的硬件设计，减少内存操作，降低内存访问的次数</p>
<p>数据对齐的原则：<br>
1）任何 K 字节的基本对象的地址必须是 K 的倍数，即每种类型的对象都需要满足它的对齐限制<br>
2）为了实现数据对齐，编译器在字段的分配中插入间隙<br>
3）结构本身对它的起始地址也有一些对齐要求<br>
4）编译器需要保证指向结构体的指针也满足对齐要求<br>
5）为了使得结构体数组中的每个元素也满足它的对齐要求，编译器在结构体的末尾也进行一些填充，其填充的字节数由结构体中的元素的最大 K 值决定</p>
<p>在 64 位机器上 K 作如下取值</p>
<table>
<thead>
<tr>
<th>K</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>char</td>
</tr>
<tr>
<td>2</td>
<td>short</td>
</tr>
<tr>
<td>4</td>
<td>int, float</td>
</tr>
<tr>
<td>8</td>
<td>long, double char*</td>
</tr>
</tbody>
</table>
<h2 id="实例分析"><a class="header-anchor" href="#实例分析">¶</a>实例分析</h2>
<h3 id="例-1"><a class="header-anchor" href="#例-1">¶</a>例 1</h3>
<p>考虑下面的结构体声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;      <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span> c;     <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> j;      <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设编译器用最小的 9 字节分配，则字段 i 的偏移为 0，字段 c 的偏移为 4，字段 j 的偏移为 5，这样的分配方式并不满足数据对齐的要求</p>
<p>我们可以在字段 c 和 j 之间插入一个 3 字节的间隙，这样就使得 j 的偏移增加到了 8，整个结构体的大小变为了 12 字节，这样就满足了数据对齐的要求</p>
<div align=center><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CSAPP/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90_3.PNG"/></div>
<div align=center>图示</div>
<h3 id="例-2"><a class="header-anchor" href="#例-2">¶</a>例 2</h3>
<p>考虑下面的结构体声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;      <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">int</span> j;      <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span> c;     <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若将这个结构体打包成 9 个字节，只要保证结构的起始地址满足 4 字节对齐要求，我们仍然能够保证满足字段 i 和 j 的对齐要求，但如果用 S2 作如下声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> <span class="title">d</span>[4];</span></span><br></pre></td></tr></table></figure>
<p>我们发现，只分配 9 个字节，使得 d[0] 的地址为 $x_d$，d[1]、d[2]、d[3] 的地址分别为 $x_d + 9$、$x_d + 18$、$x_d + 27$，不能满足结构体数组 d 中每个元素的对齐要求，于是编译器会在字段 c 后填充 3 个字节，即为结构体 S2 分配 12 个字节，使得 d[1]、d[2]、d[3] 的地址分别为 $x_d + 12$、$x_d + 24$、$x_d + 36$，那么只要 $x_d$ 是 4 的倍数，所有的对齐限制就都可以满足了</p>
<div align=center><img width = '630' height ='280' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CSAPP/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90_4.PNG"/></div>
<div align=center>图示</div>
<h3 id="练习题"><a class="header-anchor" href="#练习题">¶</a>练习题</h3>
<p>对下面每个结构体声明，确定每个字段的偏移量，结构体总的大小，以及在 x86-64 下它的对齐要求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A. <span class="class"><span class="keyword">struct</span> <span class="title">P1</span> &#123;</span> <span class="keyword">int</span> i; <span class="keyword">char</span> c; <span class="keyword">int</span> j; <span class="keyword">char</span> d; &#125;;</span><br><span class="line">B. <span class="class"><span class="keyword">struct</span> <span class="title">P2</span> &#123;</span> <span class="keyword">int</span> i; <span class="keyword">char</span> c; <span class="keyword">char</span> d; <span class="keyword">long</span> j; &#125;;</span><br><span class="line">C. <span class="class"><span class="keyword">struct</span> <span class="title">P3</span> &#123;</span> short w[<span class="number">3</span>]; <span class="keyword">char</span> c[<span class="number">3</span>]; &#125;;</span><br><span class="line">D. <span class="class"><span class="keyword">struct</span> <span class="title">P4</span> &#123;</span> short w[<span class="number">5</span>]; <span class="keyword">char</span> *c[<span class="number">3</span>]; &#125;;</span><br><span class="line">E. <span class="class"><span class="keyword">struct</span> <span class="title">P5</span> &#123;</span> <span class="class"><span class="keyword">struct</span> <span class="title">P3</span> <span class="title">a</span>[2];</span> <span class="class"><span class="keyword">struct</span> <span class="title">P2</span> <span class="title">t</span>;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>A.<br>
字段 i 偏移量为 0<br>
字段 c 偏移量为 4<br>
字段 j 偏移量为 8<br>
字段 d 偏移量为 12<br>
结构体总的大小为 16 字节<br>
对齐要求为 4 字节对齐</p>
<p>B.<br>
字段 i 偏移量为 0<br>
字段 c 偏移量为 4<br>
字段 d 偏移量为 5<br>
字段 j 偏移量为 8<br>
结构体总的大小为 16 字节<br>
对齐要求为 8 字节对齐</p>
<p>C.<br>
字段 w 的偏移量为 0<br>
字段 c 的偏移量为 6<br>
结构体总的大小为 10 字节<br>
对齐要求为 2 字节对齐</p>
<p>D.<br>
字段 w 的偏移量为 0<br>
字段 c 的偏移量为 16<br>
结构体总的大小为 40 字节<br>
对齐要求为 8 字节对齐</p>
<p>E.<br>
字段 a 的偏移量为 0<br>
字段 t 的偏移量为 24<br>
结构体总的大小为 40 字节<br>
对齐要求为 8 字节对齐</p>
<p>对于下列结构声明回答后续问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    *a;         <span class="comment">// 8</span></span><br><span class="line">    short    b;         <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">double</span>   c;         <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">char</span>     d;         <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">float</span>    e;         <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span>     f;         <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">long</span>     g;         <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">int</span>      h;         <span class="comment">// 4</span></span><br><span class="line">&#125; rec;</span><br></pre></td></tr></table></figure>
<p>这个结构体中所有的字段的字节偏移量是多少？<br>
这个结构体总的大小是多少？<br>
重新排列这个结构中的字段，以最小化浪费的空间，然后再给出重排过的结构的字节偏移量和总的大小</p>
<p>字段 a 的偏移量为 0<br>
字段 b 的偏移量为 8<br>
字段 c 的偏移量为 16<br>
字段 d 的偏移量为 24<br>
字段 e 的偏移量为 28<br>
字段 f 的偏移量为 32<br>
字段 g 的偏移量为 40<br>
字段 h 的偏移量为 48</p>
<p>填充 4 个字节以满足对 8 字节对齐的要求<br>
结构体总的大小为 56 个字节</p>
<p>重新排列后为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    *a;         <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">double</span>   c;         <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">long</span>     g;         <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">float</span>    e;         <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">int</span>      h;         <span class="comment">// 4</span></span><br><span class="line">    short    b;         <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">char</span>     d;         <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">char</span>     f;         <span class="comment">// 1</span></span><br><span class="line">&#125; rec;</span><br></pre></td></tr></table></figure>
<p>字段 a 的偏移量为 0<br>
字段 c 的偏移量为 8<br>
字段 g 的偏移量为 16<br>
字段 e 的偏移量为 24<br>
字段 h 的偏移量为 28<br>
字段 b 的偏移量为 32<br>
字段 d 的偏移量为 34<br>
字段 f 的偏移量为 35</p>
<p>填充 4 个字节以满足对 8 字节对齐的要求<br>
重新排列后结构体总的大小为 40 个字节</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>Computer Systems：A Programmer&#39;s Perspective</tag>
      </tags>
  </entry>
  <entry>
    <title>一些机器学习问题的数学求解参考</title>
    <url>/2021/05/03/%E4%B8%80%E4%BA%9B%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B0%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<p>本文将要介绍的这些问题涉及到的机器学习方法如下</p>
<blockquote>
<p>线性回归 $~~~~$ 逻辑回归 $~~~~$ 朴素贝叶斯分类器 $~~~~$ 决策树<br>
对偶问题 $~~~~$ 支持向量机 $~~~~$ 神经网络的反向传播</p>
</blockquote>
<a id="more"></a>
<h2 id="多元线性回归求解"><a class="header-anchor" href="#多元线性回归求解">¶</a>多元线性回归求解</h2>
<p>多元线性回归试图学得 $h(x^{(i)}) = \sum\limits^{n}_{j=0} \theta_j x^{(i)}_j $，$\text{where } x^{(i)}_0 = 1$，使得 $h(x^{(i)}) \simeq y^{(i)}$，其中，$j = 1,2,…,n$，$n$ 为样本的特征数，$i = 1,2,…,m$，$m$ 为训练集的样本个数，采用最小二乘法，将代价函数矩阵化并对其求导，令导数等于 $0$，化简得到最小二乘估计的正规方程为</p>
$$\boldsymbol{X}^\mathrm{T} \boldsymbol{X} \boldsymbol{\theta} = \boldsymbol{X}^\mathrm{T} \boldsymbol{y}\tag{1 - 1}$$
<p>求解正规方程，得到最终学得的多元线性回归模型的参数为</p>
$$\boldsymbol{\theta} = (\boldsymbol{X}^\mathrm{T} \boldsymbol{X})^{-1} \boldsymbol{X}^\mathrm{T} \boldsymbol{y}\tag{1 - 2}$$
<p>其中，矩阵 $\boldsymbol{X}$ 与 矩阵 $\boldsymbol{y}$ 的结构为</p>
$$
\boldsymbol{X}=
\begin{bmatrix}
x_0^{(1)} & x_1^{(1)} & \cdots & x_n^{(1)} \\
x_0^{(2)} & x_1^{(2)} & \cdots & x_n^{(2)} \\
\vdots & \vdots & \ddots & \vdots \\
x_0^{(m)} & x_1^{(m)} & \cdots & x_n^{(m)} \\
\end{bmatrix}
,
~~
\boldsymbol{y} =
\begin{bmatrix}
y^{(1)} \\
y^{(2)} \\
\vdots \\
y^{(m)} 
\end{bmatrix}
\tag{1 - 3}
$$
<p><strong>矩阵求逆</strong></p>
<p>矩阵求逆常用的有三种方法，分别为待定系数法，初等行变换法，伴随矩阵法</p>
<p>待定系数法：<br>
待定逆矩阵的所有元素，将原矩阵与逆矩阵作矩阵乘法，使其结果为单位矩阵</p>
<p>初等行变换法：<br>
利用初等行变换，将 $(\boldsymbol A, \boldsymbol E)$ 变换为 $(\boldsymbol E, \boldsymbol B)$，矩阵 $\boldsymbol B$ 即为 $\boldsymbol A^{-1}$</p>
<p>伴随矩阵法：<br>
利用公式 $\boldsymbol A^{-1} = \dfrac{1}{|\boldsymbol A|} \boldsymbol A^{*}$ 求得逆矩阵，其中伴随矩阵 $\boldsymbol A^{*} = [(-1)^{i+j}M_{ij}]^{\mathrm{T}}$，$M$ 为矩阵 $\boldsymbol A$ 中元素 $a_{ij}$ 的余子式</p>
<p><strong>问题 1</strong></p>
<p>给定某大学若干名学生身高（Height，单位：英寸 inch）与体重（Weight，单位：磅 pound）的数据，要求根据样本数据求得以身高预测体重的线性回归模型，并根据另一位同学的身高预测出他/她的体重（为了简化运算，给出示例，此处为单变量线性回归）</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>$i$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>Height/inch</td>
<td>$x_i$</td>
<td>63</td>
<td>64</td>
<td>66</td>
<td>69</td>
<td>69</td>
<td>71</td>
<td>71</td>
<td>72</td>
<td>73</td>
<td>75</td>
</tr>
<tr>
<td>Weight/pound</td>
<td>$y_i$</td>
<td>127</td>
<td>121</td>
<td>142</td>
<td>157</td>
<td>162</td>
<td>156</td>
<td>169</td>
<td>165</td>
<td>181</td>
<td>208</td>
</tr>
</tbody>
</table>
<br>
<p>将这 $10$ 组数据代入多元线性回归模型的参数公式进行计算，注意：$x^{(i)}_0 = 1$</p>
<p>根据数据得到</p>
$$
\boldsymbol X = 
\begin{bmatrix}
1 & 63 \\ 
1 & 69 \\ 
\vdots & \vdots \\
1 & 75 
\end{bmatrix}
,
~~
\boldsymbol X^{\mathrm{T}} =
\begin{bmatrix}
1 & 1 & \cdots & 1 \\ \\
63 & 69 & \cdots & 75
\end{bmatrix}
,
~~
\boldsymbol{y} =
\begin{bmatrix}
127 \\
121 \\
\vdots \\
208
\end{bmatrix}
\tag{P1 - 1}
$$
<p>作矩阵乘法</p>
$$
\boldsymbol{X}^\mathrm{T} \boldsymbol{X} =
\begin{bmatrix}
10 & 693 \\ \\
693 & 48163
\end{bmatrix}
\tag{P1 - 2}
$$
<p>对矩阵求逆</p>
$$
(\boldsymbol{X}^\mathrm{T} \boldsymbol{X})^{-1} =
\dfrac{1}{10 \times 48163 - 693^2}
\begin{bmatrix}
48163 & -693 \\ \\
-693 & 10
\end{bmatrix}
= \dfrac{1}{1381}
\begin{bmatrix}
48163 & -693 \\ \\
-693 & 10
\end{bmatrix}
\tag{P1 - 3}
$$
<p>两次矩阵乘法</p>
$$
(\boldsymbol{X}^\mathrm{T} \boldsymbol{X})^{-1} \boldsymbol{X}^\mathrm{T} =
\dfrac{1}{1381}
\begin{bmatrix}
4504 & 3811 & \cdots & -3812 \\ \\
-63 & -53 & \cdots & 57
\end{bmatrix}
\tag{P1 - 4}
$$
<br>
$$
\boldsymbol\theta =
(\boldsymbol{X}^\mathrm{T} \boldsymbol{X})^{-1} \boldsymbol{X}^\mathrm{T} \boldsymbol{y} =
\dfrac{1}{1381}
\begin{bmatrix}
-368084 \\ \\
8476
\end{bmatrix}=
\begin{bmatrix}
-266.5344 \\ \\
6.1376
\end{bmatrix}
\tag{P1 - 5}
$$
<p>求得结果</p>
$$
w = -266.5344 + 6.1376 \cdot h \tag{P1 - 6}
$$
<p>其中，$w$ 代表体重，$h$ 代表身高</p>
<h2 id="二分类逻辑回归问题求解"><a class="header-anchor" href="#二分类逻辑回归问题求解">¶</a>二分类逻辑回归问题求解</h2>
<p>设二分类问题的输出标记 $y \in \{0, 1\}$，用 $\text{sigmoid}$ 函数将线性回归模型的预测值转化为 $(0,1)$ 之间的值，即得到逻辑回归模型，可以认为逻辑回归模型的预测值是可能为 “1” 情况或者 “0” 情况的概率，若该概率大于 $0.5$ 即判定模型预测结果为其对应的情况</p>
<p>$\text{sigmoid}$ 函数</p>
$$\text{sigmoid}(z) = \dfrac{1}{1 + e^{-z}} \tag{2 - 1}$$
<p>逻辑回归预测模型为</p>
$$h_\theta(x) = g(\theta^T x) = \dfrac{1}{1 + e^{-\theta^T x}} \tag{2 - 2}$$
<p>我们选择用梯度下降法求得最大似然估计中 $\theta$ 的最优解，其迭代一次的操作为</p>
$$
\begin{array}{lcl} 
& \text{(1)} & \boldsymbol H = \text{sigmoid}(\boldsymbol X \cdot \boldsymbol \theta) \\ 
& \text{(2)} & \boldsymbol\nabla = \boldsymbol X^{\mathrm{T}} (\boldsymbol H - \boldsymbol Y) ~~~~ \text{or} ~~~~ \boldsymbol\nabla = \dfrac{1}{m} \boldsymbol X^{\mathrm{T}} (\boldsymbol H - \boldsymbol Y) \\
& \text{(3)} & \boldsymbol \theta := \boldsymbol \theta - \alpha \cdot \boldsymbol\nabla \\
\end{array}\tag{2 - 3}
$$
<br>
<p>其中，$\alpha$ 为预设的学习率，通常为 $0.01$、$0.001$ 等值</p>
<p>各矩阵的结构分别为</p>
$$
\boldsymbol{X}_{m \times (n+1)} =
\begin{bmatrix}
x_0^{(1)} & x_1^{(1)} & \cdots & x_n^{(1)} \\
x_0^{(2)} & x_1^{(2)} & \cdots & x_n^{(2)} \\
\vdots & \vdots & \ddots & \vdots \\
x_0^{(m)} & x_1^{(m)} & \cdots & x_n^{(m)} \\
\end{bmatrix}
,
~~
\boldsymbol{Y}_{m \times 1} =
\begin{bmatrix}
y^{(1)} \\
y^{(2)} \\
\vdots \\
y^{(m)} 
\end{bmatrix}\tag{2 - 4}
$$
<br>
$$
\boldsymbol{H}_{m \times 1} =
\begin{bmatrix}
H^{(1)} \\
H^{(2)} \\
\vdots \\
H^{(m)} 
\end{bmatrix}
,
~~
~~
~~
~~
\boldsymbol{\theta}_{(n+1) \times 1} =
\begin{bmatrix}
\theta_0 \\
\theta_1 \\
\vdots \\
\theta_n 
\end{bmatrix}\tag{2 - 5}
$$
<p><strong>问题 2</strong></p>
<p>给定某大学若干学生的 GPA 数值与其保研情况（只有 “是” 或 “否” 两种情况），请给出基于这些数据的逻辑回归模型，并根据该模型与另一位同学的 GPA 来预测他/她是否能够保研</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>$i$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPA</td>
<td>$x_i$</td>
<td>3.81</td>
<td>3.70</td>
<td>3.67</td>
<td>3.63</td>
<td>3.56</td>
<td>3.45</td>
<td>3.35</td>
<td>3.18</td>
<td>2.77</td>
<td>2.5</td>
</tr>
<tr>
<td>保研情况</td>
<td>是/否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是/否对应1/0</td>
<td>$y_i$</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<br>
<p>我们当然不会用梯度下降法手动迭代成千上万次直至收敛，但是我们可以聚焦于其中的一次迭代过程</p>
<p>根据数据得到</p>
$$
\boldsymbol X = 
\begin{bmatrix}
1 & 3.81 \\ 
1 & 3.70 \\
1 & 3.67 \\
\vdots & \vdots \\
1 & 2.50 
\end{bmatrix}
,
~~
\boldsymbol{Y} =
\begin{bmatrix}
1 \\
1 \\
0 \\
\vdots \\
0 
\end{bmatrix}\tag{P2 - 1}
$$
<p>设初始的 $\boldsymbol\theta$ 矩阵为</p>
$$
\boldsymbol{\theta} =
\begin{bmatrix}
0 \\ \\
0 
\end{bmatrix}\tag{P2 - 2}
$$
<p>则有</p>
$$
\boldsymbol X \cdot \boldsymbol{\theta} =
\begin{bmatrix}
0 \\
0 \\
\vdots \\
0 
\end{bmatrix}
,
~~
~~
~~
~~
\boldsymbol H =
\begin{bmatrix}
0.5 \\ 
0.5 \\ 
\vdots \\
0.5
\end{bmatrix}\tag{P2 - 3}
$$
<br>
$$
\boldsymbol\nabla = \boldsymbol X^{\mathrm{T}} (\boldsymbol H - \boldsymbol Y) =
\begin{bmatrix}
2.00 \\ \\
5.67
\end{bmatrix}\tag{P2 - 4}
$$
<p>设学习率 $\alpha$ 为 $0.01$，得到更新的 $\boldsymbol\theta$ 矩阵为</p>
$$
\boldsymbol{\theta} =
\begin{bmatrix}
-0.02000 \\ \\
-0.05670 
\end{bmatrix}\tag{P2 - 5}
$$
<p>在计算机中迭代一百万次后得到 $\boldsymbol\theta^{\mathrm{T}} = \begin{bmatrix}-82.78829 & 22.73134 \end{bmatrix}$，此时若有一位同学的GPA为 $3.60$，根据此逻辑回归模型有</p>
$$\text{hypothesis} = \dfrac{1}{1 + e^{-\theta^T x}} \approx 0.27779\tag{P2 - 6}$$
<p>可以预测，该同学不能保研</p>
<h2 id="运用贝叶斯判定准则进行分类"><a class="header-anchor" href="#运用贝叶斯判定准则进行分类">¶</a>运用贝叶斯判定准则进行分类</h2>
<p>对于分类任务来说，在所有相关概率都已知的理想情形下，贝叶斯决策论考虑如何基于这些概率和误判损失来选择最优的类别标记。假设有 $K$ 种可能的类别标记，即 $\gamma = \{ C_1, C_2, ... , C_K \}$，那么最小化分类器错误率的贝叶斯最优分类器为</p>
$$
h(\boldsymbol x) = \mathop{\arg\max}\limits_{k \in \{ 1, \dots, K \}} \mathrm P(C_k ~|~ \boldsymbol x) \tag{3 - 1}
$$
<p>即对每个样本 $\boldsymbol x$，选择能使后验概率 $\mathrm P(C_k ~|~ \boldsymbol x)$ 最大的类别标记</p>
<p>假设特征条件之间相互独立，上式基于贝叶斯公式推导得到的贝叶斯判定准则为</p>
$$
\widehat y = \mathop{\arg\max}\limits_{k \in \{ 1, \dots, K \}} \mathrm P(C_k)\prod^{n}_{i=1} \mathrm P(x_i~|~C_k) \tag{3 - 2}
$$
<p>其中，$n$ 为样本属性个数，$x_i$ 为 $\boldsymbol x$ 在第 $i$ 个属性上的取值</p>
<p>$p(C_k)$ 是好求的，当属性或者说特征为离散值时，$p(x_i~|~C_k)$ 亦不难求得，而当其为连续值时，则需考虑其概率密度函数，假定 $p(x_i~|~C_k) \sim \mathcal{N}(\mu_{C_k, i}, \sigma^2_{C_k, i})$，其中 $\mu_{C_k, i}, \sigma^2_{C_k, i}$ 分别是第 $k$ 类样本在第 $i$ 个属性上取值的均值和方差，则有</p>
$$p(x_i~|~C_k) = \dfrac{1}{\sqrt{2\pi}\sigma_{C_k, i}}\exp\Big( -\dfrac{(x_i - \mu_{C_k, i})^2}{2\sigma^2_{C_k, i}} \Big) \tag{3 - 3}$$
<p><strong>问题 3.1</strong></p>
<p>Given a dataset about the relationship between whether Xiao E plays outside or not and the weather and temperature that day, if the weather tomorrow is overcast, and the temperature is mild, will he go out to play tomorrow?</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
</tr>
</thead>
<tbody>
<tr>
<td>Weather</td>
<td>Sunny</td>
<td>Sunny</td>
<td>Overcast</td>
<td>Rainy</td>
<td>Rainy</td>
<td>Rainy</td>
<td>Overcast</td>
<td>Sunny</td>
<td>Sunny</td>
<td>Rainy</td>
<td>Sunny</td>
<td>Overcast</td>
<td>Overcast</td>
<td>Rainy</td>
</tr>
<tr>
<td>Temperature</td>
<td>Hot</td>
<td>Hot</td>
<td>Hot</td>
<td>Mild</td>
<td>Cool</td>
<td>Cool</td>
<td>Cool</td>
<td>Mild</td>
<td>Cool</td>
<td>Mild</td>
<td>Mild</td>
<td>Mild</td>
<td>Hot</td>
<td>Mild</td>
</tr>
<tr>
<td>Play</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<br>
<p>二分类问题，先求先验概率与似然</p>
$$\mathrm P(\text{play=Yes}) = \dfrac{9}{14}, ~~~~\mathrm P(\text{play=No}) = \dfrac{5}{14}\tag{P3.1 - 1}$$
<p>因为是离散值，很容易即可求得</p>
$$\mathrm P(\text{weather=Overcast | play=Yes}) = \dfrac{4}{9} \tag{P3.1 - 2}$$
$$\mathrm P(\text{Temperature=Mild | play=Yes}) = \dfrac{4}{9} \tag{P3.1 - 3}$$
$$\mathrm P(\text{weather=Overcast | play=No}) = \dfrac{0}{5} \tag{P3.1 - 4}$$
$$\mathrm P(\text{Temperature=Mild | play=No}) = \dfrac{2}{5} \tag{P3.1 - 5}$$
<p>根据贝叶斯判定准则有</p>
$$\mathrm P(\text{play=Yes | weather=Overcast, Temperature=Mild}) \\
\Longrightarrow \mathrm P(\text{play=Yes}) \cdot \mathrm P(\text{weather=Overcast | play=Yes})\cdot \mathrm P(\text{Temperature=Mild | play=Yes}) \\ 
= \dfrac{9}{14} \cdot \dfrac{4}{9} \cdot \dfrac{4}{9} = 0.1270 \tag{P3.1 - 6}$$
$$\mathrm P(\text{play=No | weather=Overcast, Temperature=Mild}) \\
\Longrightarrow \mathrm P(\text{play=No}) \cdot \mathrm P(\text{weather=Overcast | play=No})\cdot \mathrm P(\text{Temperature=Mild | play=No})  \\ 
= \dfrac{5}{14} \cdot \dfrac{0}{5} \cdot \dfrac{2}{5} = 0 \tag{P3.1 - 7}$$
<p>由于 $0.1270 &gt; 0$，结论是，根据天气与温度情况，我们推断小 E 明天将会出去玩</p>
<br>
<p>在上面的计算过程中，$\mathrm P(\text{weather=Overcast | play=No}) = 0$，使得乘积结果一定为 $0$，于是其他属性携带的信息都被抹去，产生了零概率问题，于是我们在估计概率值时进行拉普拉斯平滑来解决这个问题</p>
$$\mathrm P(\text{play=Yes}) = \dfrac{9+1}{14+2} = \dfrac{10}{16}, ~~~~\mathrm P(\text{play=No}) = \dfrac{5+1}{14+2} = \dfrac{6}{16} \tag{P3.1 - 7}$$
$$
\mathrm P(\text{weather=Overcast | play=Yes}) = \dfrac{4+1}{9+3} = \dfrac{5}{12} \tag{P3.1 - 8}
$$
$$
\mathrm P(\text{Temperature=Mild | play=Yes}) = \dfrac{4+1}{9+3} = \dfrac{5}{12} \tag{P3.1 - 9}
$$
$$
\mathrm P(\text{weather=Overcast | play=No}) = \dfrac{0+1}{5+3} = \dfrac{1}{8} \tag{P3.1 - 10}
$$
$$
\mathrm P(\text{Temperature=Mild | play=No}) = \dfrac{2+1}{5+3} = \dfrac{3}{8} \tag{P3.1 - 11}
$$
$$\mathrm P(\text{play=Yes | weather=Overcast, Temperature=Mild}) \\ \Longrightarrow \dfrac{10}{16} \cdot \dfrac{5}{12} \cdot \dfrac{5}{12} = 0.1085 \tag{P3.1 - 12}$$
$$\mathrm P(\text{play=No | weather=Overcast, Temperature=Mild}) \\ \Longrightarrow \dfrac{6}{16} \cdot \dfrac{1}{8} \cdot \dfrac{3}{8} = 0.0176 \tag{P3.1 - 13}$$
<p>结论一致</p>
<p><strong>问题 3.2</strong></p>
<p>给定一个西瓜数据集，请你用它训练一个朴素贝叶斯分类器，对测试例 “测一” 进行分类</p>
<div align=center><img width = '600' height ='400' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E8%A5%BF%E7%93%9C%E6%95%B0%E6%8D%AE%E9%9B%863.0.PNG"/></div>
<div align=center><img width = '600' height ='100' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E8%A5%BF%E7%93%9C1.png"/></div>
<br>
<p>首先估计类先验概率 $\mathrm P(C_k)$，显然有</p>
<div align=center><img width = '240' height ='80' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E7%B1%BB%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87.png"/></div>
<p>然后，为每个属性估计条件概率 $\mathrm P(x_i~|~C_k)$</p>
<div align=center><img width = '480' height ='540' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87.png"/></div>
<p>连续值处理，假设密度和含糖率满足正态分布，计算时应注意均值和方差</p>
<div align=center><img width = '600' height ='450' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%A4%84%E7%90%86.png"/></div>
<p>于是有</p>
<div align=center><img width = '600' height ='200' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87.png"/></div>
<p>由于 $0.038 &gt; 6.80\times 10^{-5}$，因此，朴素贝叶斯分类器将测试样本 “测一” 判别为 “好瓜”</p>
<p>在实践中，常通过取对数的方式将连乘转化为连加，以避免数值下溢</p>
<h2 id="构造决策树及其剪枝策略"><a class="header-anchor" href="#构造决策树及其剪枝策略">¶</a>构造决策树及其剪枝策略</h2>
<p>特征纯度的度量我们使用信息熵</p>
$$\text{Entropy}(x) = -\sum^{n}_{i=0}P(x_i)\log_2P(x_i) \tag{4 - 1}$$
<p>信息熵可以衡量一个数据集的信息“纯度”。信息越纯，熵就越低；信息越混杂，熵就越高。</p>
<p>于是可以用信息增益来表示特征纯度的提升</p>
$$\text{Information gain}(i) = \text{Entropy of parent table}~D~-\text{Sum}(\dfrac{n_k}{n} \cdot\\ \text{Entropy of each value}~k~\text{of subset table }S_i) \tag{4 - 2}$$
<p>即父亲节点的信息熵减去子节点上样本熵的加权平均数。在 $\text{ID3}$ 算法中，通过测量各种切分方案的信息增益，选择具有最大信息增益的切分方式，即可确定决策树上这一个父亲节点的切分。</p>
<p><strong>问题 4</strong></p>
<div align=center><img width = '625' height ='305' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_DT/%E5%86%B3%E7%AD%96%E6%A0%91_%E8%A1%A8.PNG"/></div>
<br>
<p>Based on above training data, we can induce a decision tree as the following:</p>
<div align=center><img width = '' height ='' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_DT/%E5%86%B3%E7%AD%96%E6%A0%91_%E5%9B%BE.PNG"/></div>
<br>
<p>CSDN 作者【天泽28】在关于周志华老师的《机器学习》（西瓜书）的笔记总结中对决策树模型介绍得很好，简单易懂，尽管文中有一些小错误，但是在评论区中都有提及，不影响整体阅读</p>
<p><a href="https://blog.csdn.net/u012328159/article/details/70184415" target="_blank" rel="noopener">决策树（decision tree）(一)——构造决策树方法</a><br>
<a href="https://blog.csdn.net/u012328159/article/details/79285214" target="_blank" rel="noopener">决策树（decision tree）(二)——剪枝</a><br>
<a href="https://blog.csdn.net/u012328159/article/details/79396893" target="_blank" rel="noopener">决策树（decision tree）(三)——连续值处理</a><br>
<a href="https://blog.csdn.net/u012328159/article/details/79413610" target="_blank" rel="noopener">决策树（decision tree）(四)——缺失值处理</a></p>
<h2 id="拉格朗日函数与对偶形式求解带约束优化问题"><a class="header-anchor" href="#拉格朗日函数与对偶形式求解带约束优化问题">¶</a>拉格朗日函数与对偶形式求解带约束优化问题</h2>
<p>对于优化问题</p>
$$
\begin{array}{lcl}
\min\limits_{\boldsymbol u} & & f(\boldsymbol u) \tag{5 - 1}\\
\text{ s. t.} & & g_i(\boldsymbol u) \le 0, ~~~~ i = 1,2,...,m~, \\
& & h_j(\boldsymbol u) = 0, ~~~~ j = 1,2,...,n~.
\end{array}
$$
<p>定义其拉格朗日函数为</p>
$$
\mathcal{L}(\boldsymbol u, \boldsymbol\alpha, \boldsymbol\beta) := f(\boldsymbol u) + \sum^{m}_{i=1} \alpha_i g_i(\boldsymbol u) + \sum^{n}_{j=1} \beta_j h_j(\boldsymbol u) \tag{5 - 2}
$$
<p>其中 $\alpha_i \ge 0$</p>
<p>式 (1) 描述的优化问题等价于</p>
$$
\begin{array}{lcl} 
\min\limits_{\boldsymbol u}\max\limits_{\boldsymbol\alpha, \boldsymbol\beta} & & \mathcal{L}(\boldsymbol u, \boldsymbol\alpha, \boldsymbol\beta) \tag{5 - 3} \\
~~~~\text{ s. t.} & & \alpha_i \ge 0, ~~~~ i = 1,2,...,m~. \\
\end{array}
$$
<p>式 (3) 描述的优化问题在最优值处必须满足如下条件 ($\text{KKT}$ 条件)</p>
<ul>
<li>主问题可行：$g_i(\boldsymbol u) \le 0, h_j(\boldsymbol u) = 0;$</li>
<li>对偶问题可行：$\alpha_i \ge 0;$</li>
<li>互补松弛：$\alpha_i g_i(\boldsymbol u) = 0.$</li>
</ul>
<p>定义式 (1) 描述的优化问题的对偶问题</p>
$$
\begin{array}{lcl} 
\max\limits_{\boldsymbol\alpha, \boldsymbol\beta}\min\limits_{\boldsymbol u} & & \mathcal{L}(\boldsymbol u, \boldsymbol\alpha, \boldsymbol\beta) \tag{5 - 4} \\
~~~~\text{ s. t.} & & \alpha_i \ge 0, ~~~~ i = 1,2,...,m~. \\
\end{array}
$$
<p>对偶问题是主问题的下界，即</p>
$$
\max\limits_{\boldsymbol\alpha, \boldsymbol\beta}\min\limits_{\boldsymbol u} \mathcal{L}(\boldsymbol u, \boldsymbol\alpha, \boldsymbol\beta)
\le
\min\limits_{\boldsymbol u}\max\limits_{\boldsymbol\alpha, \boldsymbol\beta} \mathcal{L}(\boldsymbol u, \boldsymbol\alpha, \boldsymbol\beta)
\tag{5 - 5}
$$
<p><strong>问题 5.1</strong></p>
<p>Problem</p>
$$
\begin{array}{lcl}
\text{minimize:} & & x^2 + y^2 + 2z^2 \\
\text{subject to:} & & 2x + 2y - 4z \ge 8 \\
\end{array}
$$
<p>$$2x + 2y - 4z \ge 8 \Longleftrightarrow 8 - 2x - 2y + 4z \le 0$$</p>
<p>The Lagrangian is:</p>
$$
\mathcal{L}(x, y, z, \alpha) = x^2 + y^2 + 2z^2 + \alpha(8 - 2x - 2y + 4z) \tag{P5.1 - 1}
$$
<p>Differentiating with respect to $x, y, z$</p>
$$
\dfrac{\partial{\mathcal{L}}}{\partial x} = 2x - 2\alpha = 0 \tag{P5.1 - 2}
$$
$$
\dfrac{\partial{\mathcal{L}}}{\partial y} = 2y - 2\alpha = 0 \tag{P5.1 - 3}
$$
$$
\dfrac{\partial{\mathcal{L}}}{\partial z} = 4z + 4\alpha = 0 \tag{P5.1 - 4}
$$
<p>We can conclude that</p>
$$x = y = \alpha, ~~ z = -\alpha \tag{P5.1 - 5}$$
<p>Substituting this into $2x + 2y - 4z = 8$ gives</p>
$$x = 1, ~~ y = 1, ~~ z = -1 \tag{P5.1 - 6}$$
<p>Optimal objective function value $ = 4$</p>
<p><strong>问题 5.2</strong></p>
$$
\begin{array}{lcl}
\text{minimize:} & & x_1^2 + x_2^2 \\
\text{subject to:} & & x_1 + x_2 \ge 4 \\
& & x_1, x_2 \ge 0
\end{array}
$$
<p>Let</p>
$$
X := \{ x \in \mathbb{R}^2 | x_1, x_2 \ge 0 \} = \mathbb{R}^+ \tag{P5.2 - 1}
$$
<p>The Lagrangian is:</p>
$$
\mathcal{L}(\boldsymbol x, \lambda) = x_1^2 + x_2^2 + \lambda(4 - x_1 - x_2) \tag{P5.2 - 2}
$$
<p>The Lagrangian dual function:</p>
$$
\begin{array}{lcl}
\theta(\lambda)
& = & \min\limits_{x \in X}\{ ~x_1^2 + x_2^2 + \lambda(4 - x_1 - x_2)~ \} \\
& = & 4\lambda + \min\limits_{x \in X}\{ ~x_1^2 + x_2^2 - \lambda x_1 - \lambda x_2~ \} \\
& = & 4\lambda + \min\limits_{x_1 \ge 0}\{ ~x_1^2 - \lambda x_1~ \} + \min\limits_{x_2 \ge 0}\{ ~x_2^2 - \lambda x_2~ \}
\end{array} \tag{P5.2 - 3}
$$
<p>For a fixed value of $\lambda \ge 0$，the minimum of $\mathcal{L}(\boldsymbol x, \lambda)$ over $x \in X$ is attained at</p>
$$x_1(\lambda) = \dfrac{\lambda}{2}, ~~~~ x_2(\lambda) = \dfrac{\lambda}{2} \tag{P5.2 - 4}$$ 
$$\Longrightarrow \mathcal{L}(\boldsymbol x(\lambda), \lambda) = 4 \lambda - \dfrac{\lambda^2}{2} ~~~~ \forall \lambda \ge 0 \tag{P5.2 - 5}$$ 
<p>The dual function is concave and differentiable</p>
<p>We want to maximize the value of the dual function</p>
$$
\dfrac{\partial{\mathcal{L}}}{\partial \lambda} = 4 - \lambda = 0 \tag{P5.2 - 6}
$$
<p>This implies</p>
$$
\lambda^* = 4, ~~~~ \theta(\lambda^*) = 8, ~~~~ \boldsymbol x(\lambda^*) = \boldsymbol x^* = (2, 2) \tag{P5.2 - 7}
$$
<h2 id="支持向量机求解线性二分类问题"><a class="header-anchor" href="#支持向量机求解线性二分类问题">¶</a>支持向量机求解线性二分类问题</h2>
<p>给定一组数据 $\{ (\boldsymbol x_1, y_1), (\boldsymbol x_2, y_2), ... , (\boldsymbol x_m, y_m) \}$，其中 $\boldsymbol x_i \in \mathbb{R}^{d}$，$y \in \{ -1, 1 \}$，二分类任务的目标是希望从数据中学得一个假设函数 $h: \mathbb{R} \rightarrow \{ -1, 1 \}$，使得 $h(\boldsymbol x_i) = y_i$，即，线性二分类模型希望在特征空间找到一个划分超平面，将属于不同标记的样本分开，而 $\text{SVM}$ 进一步希望找到离各样本都比较远的划分超平面。</p>
<p>线性二分类模型：<br>
找到一组合适的参数 $(\boldsymbol w, b)$，使得</p>
$$
\forall i. ~~ y_i(\boldsymbol w^{\mathrm T} \boldsymbol x_i + b) > 0 \tag{6 - 1}
$$
<p>线性支持向量机基本型</p>
$$
\begin{array}{lcl}
\mathop{\min}\limits_{\boldsymbol w, b} & & \dfrac{1}{2} \boldsymbol w^{\mathrm T} \boldsymbol w \\
\text{ s. t.} & & y_i(\boldsymbol w^{\mathrm T} \boldsymbol x_i + b) \ge 1, ~~~~ i = 1,2,...,m
\end{array} \tag{6 - 2}
$$
<p>线性支持向量机的拉格朗日函数为</p>
$$\mathcal{L}(\boldsymbol{w}, b, \boldsymbol\alpha) = \dfrac{1}{2}\boldsymbol{w}^{\mathrm T} \boldsymbol w + \sum^{m}_{i=1} \alpha_i \Big(1 - y_i(\boldsymbol{w}^\mathrm{T} \boldsymbol{x_i} + b)\Big) \tag{6 - 3} $$
<p>其对偶问题为</p>
$$
\begin{array}{lcl} 
\max\limits_{\boldsymbol\alpha}\min\limits_{\boldsymbol w, b} & & \dfrac{1}{2}\boldsymbol{w}^{\mathrm T} \boldsymbol w + \sum\limits^{m}_{i=1} \alpha_i \Big(1 - y_i(\boldsymbol{w}^\mathrm{T} \boldsymbol{x_i} + b)\Big) \\
~~~~\text{ s. t.} & & \alpha_i \ge 0, ~~~~ i = 1,2,...,m~. \\
\end{array} \tag{6 - 4}
$$
<p>因为式 $(6 - 4)$ 对 $(\boldsymbol w, b)$ 的优化属于无约束最小化问题，令偏导等于零，得到 $(\boldsymbol w, b)$ 的最优值</p>
$$
\dfrac{\partial \mathcal{L}}{\partial w} = 0 \Rightarrow \boldsymbol w = \sum^{m}_{i=1} \alpha_i y_i \boldsymbol x_i, \tag{6 - 5}
$$
$$
\dfrac{\partial \mathcal{L}}{\partial b} = 0 \Rightarrow \sum^{m}_{i=1} \alpha_i y_i = 0. \tag{6 - 6}
$$
<p>将其代入式 $(6 - 4)$，消去 $(\boldsymbol w, b)$，得到线性支持向量机的对偶型</p>
<p>线性支持向量机的对偶问题等价于找到一组合适的参数 $\boldsymbol \alpha$，使得</p>
$$
\begin{array}{lcl} 
\max\limits_{\boldsymbol\alpha} & & \sum\limits^{m}_{i=1} \alpha_i - \dfrac{1}{2}\sum\limits^{m}_{i=1}\sum\limits^{m}_{j=1} \alpha_i \alpha_j y_i y_j {\boldsymbol{x_i}}^\mathrm{T} \boldsymbol{x_j} \\
\text{ s. t.} & & \sum\limits^{m}_{i=1} \alpha_i y_i = 0, \\
& & \alpha_i \ge 0, ~~~~ i = 1,2,...,m. \\
\end{array} \tag{6 - 7}
$$
<p>线性支持向量机的 $\text{KKT}$ 条件</p>
<ul>
<li>主问题可行：$1 - y_i(\boldsymbol w^{\mathrm T} x_i + b) \le 0;$</li>
<li>对偶问题可行：$\alpha_i \ge 0;$</li>
<li>互补松弛：$\alpha_i(1 - y_i(\boldsymbol w^{\mathrm T} x_i + b)) = 0;$</li>
</ul>
<p>线性支持向量机中，支持向量是距离划分超平面最近的样本，落在最大间隔边界上（即对偶变量 $\alpha_i &gt; 0$ 对应的样本），支持向量机的参数 $(\boldsymbol w, b)$ 仅由支持向量决定，与其他样本无关</p>
<p><strong>问题 6</strong></p>
<p>给出</p>
$$x_1 = \begin{bmatrix} 1 \\ 2 \end{bmatrix}，y_1 = +1 \tag{P6 - 1}$$
$$x_2 = \begin{bmatrix} -1 \\ 2 \end{bmatrix}，y_2 = +1 \tag{P6 - 2}$$
$$x_3 = \begin{bmatrix} -1 \\ -2 \end{bmatrix}，y_3 = -1 \tag{P6 - 3}$$
<p>线性支持向量机的拉格朗日函数为</p>
$$\mathcal{L}(\boldsymbol{w}, b, \boldsymbol\alpha) = \dfrac{1}{2}{\left \| \boldsymbol{w} \right \|}^2 - \sum^{m}_{i=1} \alpha_i \Big(y_i(\boldsymbol{w}^\mathrm{T} \boldsymbol{x_i} + b) - 1\Big) \tag{P6 - 4}$$
<p>令 $\dfrac{\partial{\mathcal{L}}}{\partial{\boldsymbol{w}}} = \boldsymbol{0}$，$\dfrac{\partial{\mathcal{L}}}{\partial{b}} = 0$，可得</p>
$$\boldsymbol{w} = \sum^{m}_{i=1} \alpha_i y_i \boldsymbol{x_i} ~, \tag{P6 - 5}$$
$$\sum^{m}_{i=1} \alpha_i y_i = 0 ~. \tag{P6 - 6}$$
<p>由 (4) (5) (6) 式推导可知</p>
$$\mathcal{L} = \sum^{m}_{i=1} \alpha_i - \dfrac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1} \alpha_i \alpha_j y_i y_j {\boldsymbol{x_i}}^\mathrm{T} \boldsymbol{x_j} \tag{P6 - 7}$$
<p>将 (1) (2) (3) 式代入 (7) 式可得</p>
$$\mathcal{L} = \alpha_1 + \alpha_2 + \alpha_3 - \dfrac{1}{2}\sum^{3}_{i=1}\begin{bmatrix}
y_i(+1)\alpha_i \alpha_1 {\boldsymbol{x_i}}^\mathrm{T}\begin{bmatrix}1 \\2\end{bmatrix}\\ \\
+y_i(+1)\alpha_i \alpha_2 {\boldsymbol{x_i}}^\mathrm{T}\begin{bmatrix}-1 \\2\end{bmatrix}\\ \\
+y_i(-1)\alpha_i \alpha_3 {\boldsymbol{x_i}}^\mathrm{T}\begin{bmatrix}-1 \\-2\end{bmatrix}
\end{bmatrix}$$
<br>
$$\mathcal{L} = \alpha_1 + \alpha_2 + \alpha_3 - \dfrac{1}{2}
\begin{bmatrix}
{\alpha_1}^2 \begin{bmatrix}1,2\end{bmatrix} \begin{bmatrix}1 \\2\end{bmatrix}
+\alpha_1\alpha_2 \begin{bmatrix}-1,2\end{bmatrix} \begin{bmatrix}1 \\2\end{bmatrix}
-\alpha_1\alpha_3 \begin{bmatrix}-1,-2\end{bmatrix} \begin{bmatrix}1 \\2\end{bmatrix}
\\ \\
+\alpha_2\alpha_1 \begin{bmatrix}1,2\end{bmatrix} \begin{bmatrix}-1 \\2\end{bmatrix}
+{\alpha_2}^2 \begin{bmatrix}-1,2\end{bmatrix} \begin{bmatrix}-1 \\2\end{bmatrix}
-\alpha_2\alpha_3 \begin{bmatrix}-1,-2\end{bmatrix} \begin{bmatrix}-1 \\2\end{bmatrix}
\\ \\
-\alpha_3\alpha_1 \begin{bmatrix}1,2\end{bmatrix} \begin{bmatrix}-1 \\-2\end{bmatrix}
-\alpha_3\alpha_2 \begin{bmatrix}-1,2\end{bmatrix} \begin{bmatrix}-1 \\-2\end{bmatrix}
+{\alpha_3}^2 \begin{bmatrix}-1,-2\end{bmatrix} \begin{bmatrix}-1 \\-2\end{bmatrix}
\end{bmatrix}$$
<br>
$$\mathcal{L} = \alpha_1 + \alpha_2 + \alpha_3 - \dfrac{1}{2}\Big( 5{\alpha_1}^2 + 5{\alpha_2}^2 + 5{\alpha_3}^2 + 6\alpha_1\alpha_2 + 10\alpha_1\alpha_3 + 6\alpha_2\alpha_3 \Big) \tag{P6 - 8}$$
<br>
<p>对 (8) 式分别求偏导，并令偏导为零</p>
$$\dfrac{\partial{\mathcal{L}}}{\partial{\alpha_1}} = 1 - 5\alpha_1 - 3\alpha_2 - 5\alpha_3 = 0 \tag{P6 - 9}$$
$$\dfrac{\partial{\mathcal{L}}}{\partial{\alpha_2}} = 1 - 5\alpha_2 - 3\alpha_1 - 3\alpha_3 = 0 \tag{P6 - 10}$$
$$\dfrac{\partial{\mathcal{L}}}{\partial{\alpha_3}} = 1 - 5\alpha_3 - 5\alpha_1 - 3\alpha_2 = 0 \tag{P6 - 11}$$
<p>由 (6) (9) (10) (11) 求得</p>
$$\alpha_2 = \alpha_3 = \dfrac{1}{8} ~~,~~ \alpha_1 = 0 \tag{P6 - 12}$$
<p>将上式代入 (5) 式得</p>
$$
\begin{array}{lcl}
\boldsymbol{w}
& = & \sum\limits^{m}_{i=1} \alpha_i y_i \boldsymbol{x_i} \\
\boldsymbol{w}
& = &
0\begin{bmatrix} 1 \\ 2 \end{bmatrix}
+\dfrac{1}{8}\begin{bmatrix} -1 \\ 2 \end{bmatrix}
-\dfrac{1}{8}\begin{bmatrix} -1 \\ -2 \end{bmatrix}
& = &
\begin{bmatrix}~~ 0 ~~\\ \\ ~~\dfrac{1}{2}~~ \end{bmatrix}
\end{array}
$$
<p>可得</p>
$$\boldsymbol{w} = \begin{bmatrix}~~ 0 ~~\\ \\ \dfrac{1}{2} \end{bmatrix} \tag{P6 - 13}$$
<p>由线性支持向量机的 $\text{KKT}$ 条件</p>
$$\alpha_i \Big(y_i(\boldsymbol{w}^\mathrm{T} \boldsymbol{x_i} + b) - 1 \Big) = 0 \tag{P6 - 14}$$
<p>再将 (1) 式代入得</p>
$$
\begin{array}{r}
{y_i(\boldsymbol{w}^\mathrm{T} \boldsymbol{x_i} + b) - 1  =  0 }\\
{\boldsymbol{w}^\mathrm{T} \boldsymbol{x_i} + b - 1  =  0} \\
{\begin{bmatrix} 0, \dfrac{1}{2} \end{bmatrix}
\begin{bmatrix} 1 \\ 2 \end{bmatrix}
+b-1 = 0} \\ {b = 0}
\end{array}
$$
<p>可得</p>
$$b=0\tag{P6 - 15}$$
<br>
<p>由 (13) (15) 知该线性二分类模型的划分超平面为</p>
$$\boldsymbol{w}^\mathrm{T} \boldsymbol{x} + b = 0 ~, ~~~~~~~~\text{where}~~~~\boldsymbol{w} = \begin{bmatrix}~~ 0 ~~\\ \\ \dfrac{1}{2} \end{bmatrix}, ~b = 0 ~.\tag{P6 - 16}$$
<h2 id="神经网络的误差反向传播法"><a class="header-anchor" href="#神经网络的误差反向传播法">¶</a>神经网络的误差反向传播法</h2>
<ul>
<li>
<p>神经网络的前向传播（Forward Propagation）</p>
<ul>
<li>前向传播就是从input，经过一层层的layer，不断计算每一层的z和a，最后得到输出y^ 的过程，计算出了y^，就可以根据它和真实值y的差别来计算损失（loss）。</li>
</ul>
</li>
<li>
<p>神经网络的反向传播（Backward Propagation）</p>
<ul>
<li>反向传播就是根据损失函数L(y^,y)来反方向地计算每一层的z、a、w、b的偏导数（梯度），从而更新参数。</li>
</ul>
</li>
</ul>
<div align=center><img width = '' height ='' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/5118838-e7f5f61e3aff398a.webp"/></div>
<p>每经过一次前向传播和反向传播之后，参数就更新一次，然后用新的参数再次循环上面的过程。这就是神经网络训练的整个过程。</p>
<div align=center><img width = '' height ='' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C1.png"/></div>
<div align=center><img width = '' height ='' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C2.png"/></div>
<div align=center><img width = '' height ='' src ="https://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C3.png"/></div>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Day2</title>
    <url>/2023/03/12/leetcodeDay2/</url>
    <content><![CDATA[<p>LeetCode Day2<a id="more"></a></p>
<h1>数组</h1>
<h2 id="移除元素"><a class="header-anchor" href="#移除元素">¶</a>移除元素</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day2_27.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 暴力解法 */</span></span><br><span class="line"><span class="comment">/* 注意：不使用额外的数组空间，必须仅使用 O(1) 额外空间并原地修改输入数组 */</span></span><br><span class="line"><span class="comment">/* 不需要考虑数组中超出新长度后面的元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num_i = nums[i]; </span><br><span class="line">            <span class="keyword">if</span> (num_i == val) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                i--; len--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">两层for循环</span></span><br><span class="line"><span class="comment">一个for循环遍历数组元素 ，第二个for循环更新数组</span></span><br><span class="line"><span class="comment">时间复杂度 O(n^2)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 双指针法（快慢指针法）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</span></span><br><span class="line"><span class="comment">定义快慢指针:</span></span><br><span class="line"><span class="comment">快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</span></span><br><span class="line"><span class="comment">慢指针：指向更新 新数组下标的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自己写的，也过了 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fastIndex &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fastIndex != slowIndex) </span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">            <span class="keyword">if</span>(nums[slowIndex] == val) slowIndex--;</span><br><span class="line">            fastIndex++;</span><br><span class="line">            slowIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 代码随想录中的双指针法标准代码 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 理解：</span></span><br><span class="line"><span class="comment">fastIndex 要是指向了一个值为 val 的元素</span></span><br><span class="line"><span class="comment">那么 slowIndex 的自增就得停一次（即代表最后的长度-1）</span></span><br><span class="line"><span class="comment">那如果指向的元素值不为 val，那就无脑把后面的值赋到前面去</span></span><br><span class="line"><span class="comment">结合我自己的理解，可以改一下 if 语句的代码：</span></span><br><span class="line"><span class="comment">if (val != nums[fastIndex]) &#123;</span></span><br><span class="line"><span class="comment">    if (fastIndex != slowIndex) nums[slowIndex] = nums[fastIndex];</span></span><br><span class="line"><span class="comment">    slowIndex++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 还有一种方法：</span></span><br><span class="line"><span class="comment">* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">            <span class="comment">// 找左边等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">                ++leftIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找右边不等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">                -- rightIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line">            <span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">                nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftIndex;   <span class="comment">// leftIndex一定指向了最终数组末尾的下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%95%B0%E7%BB%84/day2_26.PNG" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自己写的，能过 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(fastIndex &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != nums[slowIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                slowIndex++;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> flag = <span class="literal">true</span>;</span><br><span class="line">            fastIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">想法：</span></span><br><span class="line"><span class="comment">首先用一个 flag 区分是不是遇到了重复元素</span></span><br><span class="line"><span class="comment">当遇到了重复元素时，flag = true</span></span><br><span class="line"><span class="comment">如果两个指针指向的元素不相同，并且之前是重复元素</span></span><br><span class="line"><span class="comment">则进行赋值，并且置 flag 为 false</span></span><br><span class="line"><span class="comment">注意，赋值后，人为地制造了重复元素</span></span><br><span class="line"><span class="comment">那么就不让 fastIndex 向后走</span></span><br><span class="line"><span class="comment">重新进入循环，检测出这一次重复</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 来看看官方题解 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="comment">// 可以删了，规定 n &gt;= 1</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>, slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从下标 1 开始删除元素</span></span><br><span class="line"><span class="comment">对于每个位置，如果 nums[fast] ≠ nums[fast−1]</span></span><br><span class="line"><span class="comment">​说明 nums[fast] 和之前的元素都不同</span></span><br><span class="line"><span class="comment">因此将 nums[fast] 的值复制到 nums[slow]</span></span><br><span class="line"><span class="comment">然后将 slow 的值加 1，即指向下一个位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标准答案没有我写的那么别扭qwq</span></span><br><span class="line"><span class="comment">它的思路是将整个要解决的问题</span></span><br><span class="line"><span class="comment">变成（用fastIndex）找到之前没有的值放到前面（slowIndex）去</span></span><br><span class="line"><span class="comment">这样就清晰很多</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：写技术博客的注意事项</title>
    <url>/2020/04/01/%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css">
                            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css">
                <div class="htmledit_views" id="content_views">
<p><span style="font-size:18px;">个人认为写博客（Blogging）是技术总结的最佳方式，甚至可以这样子讲，博客就是积累，从一定角度上讲是酱紫的。可能是受规范约束习惯了，感觉写博客也有一些注意事项，虽然之前写了很多文章，但感觉都不是很规范，现总结写博客应该注意的几点，以随时提醒自己。</span></p><a id="more"></a>
<h2><a name="t0"></a><a name="t0"></a><span style="font-size:18px;">1. Do not Repeat Documents, link to it&nbsp;&nbsp; 不要重复文档，给出链接就好。重点写自己的心得，体会和总结。</span></h2>
<p><span style="font-size:18px;">对于那些在官方文档中都讲的很清楚的东西就没有必要再进行重复了，给出相应的链接就好了。特别是对于像MSDN这种非常丰富的官方文档，最好不要去重复它的内容，因为你不一定比官方讲的清楚。重点应该放在自己的心得，体会和总结等，这样于自己是真正的总结和积累，能变成经验，于他人也是一种有价值的参考的。</span></p>
<h2><a name="t1"></a><a name="t1"></a><span style="font-size:18px;">2. 进行全面的总结</span></h2>
<p><span style="font-size:18px;">前面说了不要重复文档，那应该写什么呢？愚认为，应该是自己经过实践之后的总结：</span></p>
<ul><li><span style="font-size:18px;">把所有可靠的方法都说一下;</span></li></ul><ul><li><span style="font-size:18px;">把注意事项说一下;</span></li></ul><ul><li><span style="font-size:18px;">把各种方法进行比较，给出各自的优缺点和适用场合;</span></li></ul><ul><li><span style="font-size:18px;">文档中没有说明的情况，比如对文档的补充，或者文档有自相矛盾的地方。</span></li></ul><h2><a name="t2"></a><a name="t2"></a><span style="font-size:18px;">3. 必须亲自实践进行验证，确保可靠可行。并附上实例（源码，资源）和运行结果（截图等）</span></h2>
<h2><a name="t3"></a><a name="t3"></a><span style="font-size:18px;">4. 要总结与所谈内容相关且有价值的网络资料</span></h2>
<h2><a name="t4"></a><a name="t4"></a><span style="font-size:18px;">5. 要列出参考资料，比如官方文档，别人的博客，源码等。这是对别人的尊重，也是对知识的一种尊重。</span></h2>
<h2><a name="t5"></a><a name="t5"></a><span style="font-size:18px;">6. 可以参考，可以引用，但不要照搬，不思考式的抄袭。最重要的是要有自己的思考和理解。</span></h2>
<p><span style="font-size:18px;">如果是受他人的博客或代码的启发，最好把关键的句子段落引用出来，然后再写自己的思考和讨论。在文章中再给出原文或出处的链接，这样以显得尊重和专业。</span></p>
<h2><a name="t6"></a><a name="t6"></a><span style="font-size:18px;">7. 最好能有版本控制信息和修订记录</span></h2>
<p><span style="font-size:18px;">对于代码我们都有版本控制系统来帮助维护修改记录。但对于文档，也建议这样做。对于博客，可能没有（或许我不知道）类似的工具，但可以手动来说明。比如在博客的头部或尾部加上修订历史记录，或者在文章中把后来的修改用其他字体标明，或者用括号或脚注来说明。这样自已日后看起来也很方便，也能看到自己的思考过程和成长过程。</span></p>
<h2><a name="t7"></a><a name="t7"></a><span style="font-size:18px;">8. Less But Better精深原则</span></h2>
<p><span style="font-size:18px;">讲的越详细越好，范围越小越好，但要深入的讲，正如那句话，十个百分之十不如一个百分之百。如果你不能深入的讲，证明你还没有到写的时候，应试再去学习或者实践，直到你能讲的很清楚，讲的很详细，讲的很深入的时候再来总结和写博客。争取做到一篇文章一个点，这样文章多了就成了网最后变成没有漏洞的面。</span></p>
<h2><a name="t8"></a><a name="t8"></a><span style="font-size:18px;">9. 突出主题，分清主次，逻辑清楚，层次分明</span></h2>
<p><span style="font-size:18px;">这可能是对于写作的通用要求，说起来容易，但是做起来就比较困难。其实也不难，主要表现在：</span></p>
<ul><li><span style="font-size:18px;">列表来罗列要讲的东西</span></li><li><span style="font-size:18px;">用标题先简明概括，然后再详细讲解</span></li><li><span style="font-size:18px;">标题与正文用不同的字体样式标识</span></li><li><span style="font-size:18px;">用字体和缩进来标识标题和正文</span></li></ul><p><span style="font-size:18px;">有没有一种感觉，这好像是在讲编码规范，没错，很早就有人讲过，写文章跟写代码是一样的。所以，作为程序员的我们，可以考虑用写代码的一切，包括习惯，规范来写文章。</span></p>
<h2><a name="t9"></a><a name="t9"></a><span style="font-size:18px;">10. 写完后多读几遍，进行校改</span></h2>
<p><span style="font-size:18px;">这就好比写完代码后的调试与测试。好代码是改出来的，好文章也是如此。能够一蹴而就的人有，但很少。即使是像鲁迅那样的大作家写文章都还需要修改，都没有一次成型的，更何况我们呢？在写完文章后也视情况对文章进行调试和重构，直到自己读起来感到满意和舒服为止。试想，如果自己写的文章自已都不想看，别人会看吗？我们又不是在写作业，不管好坏老师总会看，而且要仔细的看。要想写出好文章，必须首先让自己认为是好文章。</span></p>
<h2><a name="t10"></a><a name="t10"></a><span style="font-size:18px;">11. 用通俗易懂的平实的语言，对于专业术语要解释</span></h2>
<p><span style="font-size:18px;">好的技术文章应该都非常容易看懂，即使你对所说的那门科学完全不知。去读一读《Code Complete》等之类的经典书籍的英文原版，你会发现，其实看原版书并不需要多么NB的英语水平，可以不客气的讲上过大学的人应该都能看懂。其实这重点不在你懂不懂英语，而是要看作者能否用最易懂的语言来把事情表达清楚。这确实是一种能力，平常我们所谓的沟通能力，也基本上就在这，看你能否用最简单的语言把事情表达清楚，让另一方听明白。</span></p>
<p><span style="font-size:18px;">这里有一些技巧：</span></p>
<ul><li><span style="font-size:18px;">多用比喻，用大家熟悉的东西来比喻，这是让人最容易理解的一种方式。比如把软件构建比作建房子;把软件架构师比作楼房的设计师等。</span></li><li><span style="font-size:18px;">多用图示，用图解。很多时候一张图能抵上几百字的文字叙述，但还不一定能说明白。给出一张图就什么都明明白白了。</span></li><li><span style="font-size:18px;">图文并茂是讲解的最佳方式，合理的安排图片，再加之文字描述会达到事半功倍的效果。</span></li></ul><h2><a name="t11"></a><a name="t11"></a><span style="font-size:18px;">12. 用事实说话</span></h2>
<p><span style="font-size:18px;">有图有真相，有代码有真相。说完了，讲过了，最好附上真实事例，代码和截图。否则别人可能会质疑，至少我在看到别人只“说”，没“做”的时候会质疑的。<br></span></p>
<hr>
<p>转自：<a href="https://blog.csdn.net/hitlion2008/article/details/6950493" target="_blank" rel="noopener">https://blog.csdn.net/hitlion2008/article/details/6950493</a></p>
<hr>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>技术博客要领</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划DP</title>
    <url>/2022/06/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=6" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
未找到课程习题<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>动态规划DP</h1>
<h2 id="什么是动态规划？"><a class="header-anchor" href="#什么是动态规划？">¶</a>什么是动态规划？</h2>
<p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
<h2 id="两个问题"><a class="header-anchor" href="#两个问题">¶</a>两个问题</h2>
<p>解决动态规划问题，要明确状态和转移两个问题。</p>
<h2 id="【例】数字三角形"><a class="header-anchor" href="#【例】数字三角形">¶</a>【例】数字三角形</h2>
<p>给出一个数字三角形，从顶点出发每次向下或右下走一步直至最底层，将途经的数字相加，问得到的最大值。</p>
<p>7<br>
3 8<br>
8 1 0<br>
2 7 4 4<br>
4 5 2 6 5</p>
<p>7-&gt;3-&gt;8-&gt;7-&gt;5 = 30</p>
<h3 id="状态"><a class="header-anchor" href="#状态">¶</a>状态</h3>
<p>定义状态 $f[i][j]$ 表示从 $(1, 1)$ 出发走到 $(i, j)$ 所有路径的最大和。</p>
<p>例如：$f[3][2] = \text{max}(7+3+1, 7+8+1) = 16$</p>
<p>答案从哪取：$f[n][1 \dots n]$</p>
<h3 id="转移"><a class="header-anchor" href="#转移">¶</a>转移</h3>
<p>考虑哪些状态对 $f[i][j]$ 这个状态有影响。</p>
<p>$(i-1, j) \rightarrow (i, j)$</p>
<p>$(i-1, j-1) \rightarrow (i, j)$</p>
<p>如何转移？</p>
<p>$f[i][j] = \text{max}(f[i-1][j], f[i-1][j-1]) + a[i][j]$</p>
<p>把 $(1, 1)$ 到 $(i, j)$ 的路径分成两类，$(1, 1) \rightarrow (i-1, j) \rightarrow (i, j)$ 和 $(1, 1) \rightarrow (i-1, j-1) \rightarrow (i, j)$</p>
<h3 id="初始状态-取答案"><a class="header-anchor" href="#初始状态-取答案">¶</a>初始状态&amp;取答案</h3>
<p>状态要明确两点</p>
<ol>
<li>
<p>初始状态 $f[1][1] = a[1][1]$，其余为 $-\text{inf}$</p>
</li>
<li>
<p>答案在哪取 $\text{max}(f[n][1] \dots f[n][n])$</p>
</li>
</ol>
<p>转移要注意顺序</p>
<p>从上到下，从左到右</p>
<pre><code>For i:2-&gt;n
    For j:1-&gt;l
        f[i][j] = max(f[i-1][j], f[i-1][j-1]) + a[i][j];
</code></pre>
<h2 id="【例】经典问题最长上升子序列-LIS"><a class="header-anchor" href="#【例】经典问题最长上升子序列-LIS">¶</a>【例】经典问题最长上升子序列 (LIS)</h2>
<p>给一个序列，求它的最长上升子序列。<br>
其中，子序列是指将序列删除 $0 - n$ 个元素所组成的序列，子序列不一定是连续的。</p>
<p>1 13 5 7 8 2 11<br>
1 5 7 8 11</p>
<h3 id="状态-v2"><a class="header-anchor" href="#状态-v2">¶</a>状态</h3>
<p>$f[i]$ 表示以 $i$ 结尾的上升子序列中的最长长度。</p>
<h3 id="转移-v2"><a class="header-anchor" href="#转移-v2">¶</a>转移</h3>
<p>$f[i] = max(f[j]) + 1$，$i &lt; j$ 且 $a[i] &lt; a[j]$</p>
<h3 id="初始状态-取答案-v2"><a class="header-anchor" href="#初始状态-取答案-v2">¶</a>初始状态&amp;取答案</h3>
<p>初始状态 $f[i] = 1$<br>
取答案 $ans = \text{max}(f[1] \dots f[n])$</p>
<pre><code>For i = 1-&gt;n
{
    f[i] = 1;
    For j = 1-&gt;i-1 
        if (a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1)
}
</code></pre>
<p>时间优化</p>
<p>可以优化成 $O(n \log n)$<br>
用二分的方法</p>
<h2 id="更多经典问题"><a class="header-anchor" href="#更多经典问题">¶</a>更多经典问题</h2>
<ul>
<li>最长公共子序列</li>
<li>最大子段和</li>
<li>最长公共上升子序列</li>
</ul>
<p>杨辉三角</p>
<pre><code>    0 1 2 3 4
0   1
1   1 1
2   1 2 1
3   1 3 3 1
4   1 4 6 4 1

c[n][m] = C[n-1][m] + C[n-1][m-1];
</code></pre>
<h2 id="背包问题"><a class="header-anchor" href="#背包问题">¶</a>背包问题</h2>
<h3 id="01-背包问题"><a class="header-anchor" href="#01-背包问题">¶</a>01 背包问题</h3>
<p>给 $n$ 个物品，每个物品有体积 $v_i$ 以及价值 $w_i$，取 $n$ 个物品的一个子集，使得体积和不超过 $m$，并且价值和尽量大。</p>
<p>如果采用贪心的方法取，肯定能举出反例。</p>
<p>状态</p>
<p>$f[i][j]$ 表示考虑前 $i$ 个物品，占用体积为 $j$，能得到的最大价值。</p>
<p>转移</p>
<p>$f[i][j]=\text{max}(f[i-1][j], f[i-1][j-v[i]]+w[i])$<br>
考虑第 $i$ 个物品取还是不取<br>
取则从 $f[i - 1][j-v[i]]+w[i]$ 转移过来<br>
不取则从 $f[i-1][j]$ 转移过来</p>
<p>空间优化</p>
<p>（图解）</p>
<p>滚动数组</p>
<p>数组 $f[i][j]$ 的取值只与上一行有关，开数组 $f[2][maxn]$<br>
用 $f[i%2][j]$ 代表当前行<br>
用 $f[(i-1)%2][j]$ 代表上一行</p>
<p>进一步优化</p>
<pre><code>for (int i = 1; i &lt;= n; i++)
{
    for (int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]);
}
</code></pre>
<p>从后向前更新，$j$ 以后的是当前行，$j$ 以前的是上一行。</p>
<h3 id="完全背包"><a class="header-anchor" href="#完全背包">¶</a>完全背包</h3>
<p>与 01 背包不同，每个物品可以不限制次数取。</p>
<p>转移方程略作修改</p>
<pre><code>for (int i = 1; i &lt;= n; i++)
{
    for (int j = v[i]; j &lt;= m; j++) f[j] = max(f[j], f[j-v[i]] + w[i]);
}
</code></pre>
<h3 id="更多背包问题"><a class="header-anchor" href="#更多背包问题">¶</a>更多背包问题</h3>
<ul>
<li>多重背包：二进制拆分</li>
<li>混合背包：01，完全，多重背包的混合</li>
<li>二维费用背包</li>
<li>分组背包</li>
<li>背包九讲</li>
</ul>
<p>二进制拆分图解</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Convolutional Neural Networks. Andrew Ng.</title>
    <url>/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CAndrewNg/</url>
    <content><![CDATA[<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/000.PNG"/></div>
<p>Convolutional Neural Networks. (<a href="https://www.coursera.org/learn/convolutional-neural-networks" target="_blank" rel="noopener">https://www.coursera.org/learn/convolutional-neural-networks</a>)</p>
<p>In the fourth course of the Deep Learning Specialization, you will understand how computer vision has evolved and become familiar with its exciting applications such as autonomous driving, face recognition, reading radiology images, and more.</p>
<p>By the end, you will be able to build a convolutional neural network, including recent variations such as residual networks; apply convolutional networks to visual detection and recognition tasks; and use neural style transfer to generate art and apply these algorithms to a variety of image, video, and other 2D or 3D data.</p>
<p>The Deep Learning Specialization is our foundational program that will help you understand the capabilities, challenges, and consequences of deep learning and prepare you to participate in the development of leading-edge AI technology. It provides a pathway for you to gain the knowledge and skills to apply machine learning to your work, level up your technical career, and take the definitive step in the world of AI.</p>
<ul>
<li><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E8%8A%82/" target="_blank" rel="noopener">Part 1. </a><br>
Convolutional Neural Networks. Yann LeCun interview.</li>
<li><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E8%8A%82/" target="_blank" rel="noopener">Part 2. </a><br>
Case Studies. Convolutional Neural Networks. Practical advice for using ConvNets.</li>
<li><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E8%8A%82/" target="_blank" rel="noopener">Part 3. </a><br>
Object Detection. Convolutional Neural Networks.</li>
<li><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E8%8A%82/" target="_blank" rel="noopener">Part 4. </a><br>
Face recognition. Neural Sytle Transfer. Convolutional Networks in 1D or 3D.</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CNN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>关于四旋翼飞行器的介绍及其飞行原理与姿态解算的分析</title>
    <url>/2020/06/02/%E5%85%B3%E4%BA%8E%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E9%A3%9E%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%E7%9A%84%E5%88%86%E6%9E%90%E5%8D%9A%E5%AE%A2%E7%89%88/</url>
    <content><![CDATA[<h2 id="一、前言"><a class="header-anchor" href="#一、前言">¶</a>一、前言</h2>
<blockquote>
<p>  在我校开展科研选题的背景下，我小组决定对四旋翼飞行器的控制进行研究，并确定课题名称为“基于STM32的四旋翼飞行器控制系统的研究”, 开始对飞行器的软硬件系统以及控制逻辑进行系统化的学习。<br>
  其中，我主要参与学习了对四旋翼飞行器的飞行原理与姿态解算的分析，现撰写报告如下。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="二、概述与发展现状"><a class="header-anchor" href="#二、概述与发展现状">¶</a>二、概述与发展现状</h2>
<h3 id="1-概述"><a class="header-anchor" href="#1-概述">¶</a>1. 概述</h3>
<blockquote>
<p>  四旋翼无人机广泛应用于民用与军事领域，例如救援、侦察、勘探等方面，其主要优点如下：</p>
<ul>
<li>机械结构简单</li>
<li>飞行姿态稳定</li>
<li>易于小型化和微型化</li>
<li>可执行的任务多样化</li>
<li>成本低、噪声小、易于维护</li>
</ul>
</blockquote>
<h3 id="2-发展现状"><a class="header-anchor" href="#2-发展现状">¶</a>2. 发展现状</h3>
<blockquote>
<p>  到2012年左右，国际上普遍认为四轴飞行器的控制已经不再是学术研究问题，而是成熟的技术。学术研究的方向也转向了基于四轴飞行器做智能导航或者多飞行器的编队控制。<br>
  四轴飞行器的智能导航指的是利用机器视觉技术、人工智能技术让四轴飞行器能像人一样在复杂环境中活动。<br>
  多飞行器的编队控制是指同时控制多个飞行器，或者让多个飞行器自主编队飞行。</p>
</blockquote>
<h3 id="3-技术关键"><a class="header-anchor" href="#3-技术关键">¶</a>3. 技术关键</h3>
<h4 id="3-1-总体设计优化"><a class="header-anchor" href="#3-1-总体设计优化">¶</a>3.1 总体设计优化</h4>
<blockquote>
<p>  设计微小型四旋翼飞行器时，原则上希望达到以下几个方面的要求：<br>
即质量轻、尺寸小、速度快、能耗与成本低，但这几者之间存在相互制约与矛盾，于是要求设计者综合考虑，不断对方案进行优化。</p>
</blockquote>
<h4 id="3-2-能源动力系统"><a class="header-anchor" href="#3-2-能源动力系统">¶</a>3.2 能源动力系统</h4>
<blockquote>
<p>  能源动力装置包括了旋翼（螺旋桨）、微型直流电机、电调、机载电池等，其质量占了整个机体质量的很大部分，需要选用更轻、更高效的能源动力装置。</p>
</blockquote>
<h4 id="3-3-建立数学模型"><a class="header-anchor" href="#3-3-建立数学模型">¶</a>3.3 建立数学模型</h4>
<blockquote>
<p>  机体在飞行过程中受到多种物理效应的作用（空气动力、重力、陀螺效应和旋翼惯量矩等），且容易受到气流等外部环境的干扰，这些都给建立有效、可靠的动力学模型带来了困难。同时，微型飞行器空气动力学特性与常规飞行器有很大的不同，需要了解新的理论与研究手段。</p>
</blockquote>
<h4 id="3-4-飞行控制"><a class="header-anchor" href="#3-4-飞行控制">¶</a>3.4 飞行控制</h4>
<blockquote>
<p>  四旋翼飞行器是一个具有六自由度（位置与姿态）和四个控制输入（旋翼转速）的欠驱动系统，具有多变量、非线性、强耦合和干扰敏感的特性，且传感器性能会受到模型准确性与传感器精度的影响，需要精确控制飞行器姿态，具有较强的抗干扰与环境自适应能力。</p>
</blockquote>
<h4 id="3-5-定位、导航与通信"><a class="header-anchor" href="#3-5-定位、导航与通信">¶</a>3.5 定位、导航与通信</h4>
<blockquote>
<p>  近地面环境地形复杂、干扰源多，对定位系统、导航技术与通信链技术的可靠性、安全性与抗干扰性有着较高的要求。</p>
</blockquote>
<hr>
<h2 id="三、基本飞行原理"><a class="header-anchor" href="#三、基本飞行原理">¶</a>三、基本飞行原理</h2>
<h3 id="1-概述-v2"><a class="header-anchor" href="#1-概述-v2">¶</a>1. 概述</h3>
<p>  四旋翼飞行器是一个 <strong>欠驱动系统</strong>（<strong>Underactuated System</strong>），即其控制自由度小于其活动自由度的系统，其拥有六个 <strong>活动自由度</strong> ，即可以分别沿三个坐标轴作平移和旋转动作，四个 <strong>控制自由度</strong> ，即四个电机的转速。飞行器由四个可以独立控制转速的外转子直流无刷电机驱动的螺旋桨提供全部动力，依据力的合成与分解及空气转动扭矩的反向性，通过各种不同的改变转速的方式，进行各种不同的飞行动作。</p>
<p>  四旋翼飞行器从结构上来分类，主要可以分为 <strong>X模型</strong> 、 <strong>十模型</strong> 与 <strong>H模型</strong>（如图1所示），目前来说，最主流的是X模型，但是无论是哪一种模型，其基本的飞行原理是大同小异的。</p>
<div align=center><img width = '600' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/3model.PNG"/></div>
<center>图1. 三种四旋翼飞行器模型</center><br>
<p>  从上图中可以发现， <strong>相邻两个旋翼的转动方向是相反的</strong> ，也就是说，对角线上两个电机的转动方向相同，这是因为，由于空气转动扭矩的反向性，旋翼在旋转时会产生反扭距，例如，顺时针方向转动的螺旋桨在转动时，空气会产生使得四轴逆时针方向转动的反向扭矩，而当M1与M4同方向、M2与M3同方向时，反向扭矩能够相互抵消，使得飞行器在偏航方向能够保持平衡，不至于出现自旋转。与传统的单旋翼飞行器，特别是直升机相比，省去了用尾桨（又称抗扭螺旋桨）来平衡反扭距，使得四旋翼飞行器的能量利用率更高。</p>
<p>  另外，由于相邻两个旋翼的转动方向相反，为保证他们产生的升力皆向上，M1、M4电机使用 “<strong>正桨</strong>” ，即顺时针方向转动产生上升力的桨，M2、M3电机使用 “<strong>反桨</strong>” ，即逆时针方向转动产生上升力的桨。</p>
<p>  图2与图3以“X模型”为例，对飞行器结构进行了简单描述。</p>
<div align=center><img width = '350' height ='280' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/Xmodel-1.PNG"/></div>
<center>图2. 四旋翼飞行器平面结构图</center><br>
<div align=center><img width = '350' height ='280' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/Xmodel-2.PNG"/></div>
<center>图3. 四旋翼飞行器立体结构图</center><br>
<h3 id="2-基本飞行动作"><a class="header-anchor" href="#2-基本飞行动作">¶</a>2. 基本飞行动作</h3>
<p>  四旋翼飞行器可以分别沿着机体的 X、Y、Z 三个轴进行旋转或者平移运动，因此在每个轴向上有两个自由度，四旋翼飞行器有六种基本飞行动作：</p>
<ul>
<li>垂直（升降）运动</li>
<li>俯仰运动</li>
<li>横滚（滚转）运动</li>
<li>偏航（自旋）运动</li>
<li>前后运动</li>
<li>侧向运动</li>
</ul>
<p>  下面以十字模式说明六种运动的原理：</p>
<div align=center><img width = '350' height ='280' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/principle-1.PNG"/></div>
<center>图4-1. 基本运动原理-1</center><br>
<div align=center><img width = '350' height ='280' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/principle-2.PNG"/></div>
<center>图4-2. 基本运动原理-2</center><br>
<h4 id="2-1-垂直运动"><a class="header-anchor" href="#2-1-垂直运动">¶</a>2.1 垂直运动</h4>
<p>  在图 a 中，因有两对电机转向相反，可以平衡其对机身的反扭矩，当同时增加四个电机的输出功率，旋翼转速增加使得总的拉力增大，当总拉力足以克服整机的重量时，四旋翼飞行器便离地垂直上升；<br>
  反之，同时减小四个电机的输出功率，四旋翼飞行器则垂直下降，直至平衡落地，实现了沿 z 轴的垂直运动；<br>
  当外界扰动量为零时，在旋翼产生的升力等于飞行器的自重时，飞行器便保持悬停状态；<br>
保证四个旋翼转速同步增加或减小是垂直运动的关键；</p>
<div align=center><img width = '300' height ='240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/move-1.PNG"/></div>
<center>图5-1. 垂直运动（图 a）</center><br>
<div align=center><img width = '320' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/hovering.PNG"/></div>
<center>图5-2. Hovering</center><br>
<div align=center><img width = '320' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/lift.PNG"/></div>
<center>图5-3. Lift</center><br>
<h4 id="2-2-俯仰运动"><a class="header-anchor" href="#2-2-俯仰运动">¶</a>2.2 俯仰运动</h4>
<p>  在图 b 中，电机1的转速上升，电机3的转速下降，电机2、电机4的转速保持不变；<br>
为了不因为旋翼转速的改变引起四旋翼飞行器整体扭矩及总拉力改变，旋翼1 与 旋翼3 转速该变量的大小应相等；<br>
  由于 旋翼1 的升力上升，旋翼3 的升力下降，产生的不平衡力矩使机身绕 y 轴旋转（方向如图所示），同理，当 电机1 的转速下降，电机3 的转速上升，机身便绕 y 轴向另一个方向旋转，实现飞行器的俯仰运动；</p>
<div align=center><img width = '300' height ='240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/move-2.PNG"/></div>
<center>图6-1. 俯仰运动（图 b）</center><br>
<div align=center><img width = '320' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/pitch.PNG"/></div>
<center>图6-2. Pitch</center><br>
<h4 id="2-3-横滚运动"><a class="header-anchor" href="#2-3-横滚运动">¶</a>2.3 横滚运动</h4>
<p>  与图 b 的原理相同，在图 c 中，改变 电机2 和 电机4 的转速，保持 电机1 和 电机3 的转速不变，则可使机身绕 x 轴旋转（正向和反向），实现飞行器的横滚（滚转）运动；</p>
<div align=center><img width = '300' height ='240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/move-3.PNG"/></div>
<center>图7-1. 横滚运动（图 c）</center><br>
<div align=center><img width = '320' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/roll.PNG"/></div>
<center>图7-2. Roll</center><br>
<h4 id="2-4-偏航运动"><a class="header-anchor" href="#2-4-偏航运动">¶</a>2.4 偏航运动</h4>
<p>  四旋翼飞行器偏航运动可以借助旋翼产生的反扭矩来实现；<br>
  旋翼转动过程中由于空气阻力作用会形成与转动方向相反的反扭矩，为了克服反扭矩影响，可使四个旋翼中的两个正转，两个反转，且对角线上的来年各个旋翼转动方向相同；<br>
  反扭矩的大小与旋翼转速有关，当四个电机转速相同时，四个旋翼产生的反扭矩相互平衡，四旋翼飞行器不发生转动；<br>
  当四个电机转速不完全相同时，不平衡的反扭矩会引起四旋翼飞行器转动；<br>
  在图 d 中，当 电机1 和 电机3 的转速上升，电机2 和 电机4 的转速下降时，旋翼1 和 旋翼3 对机身的反扭矩大于 旋翼2 和 旋翼4 对机身的反扭矩，机身便在富余反扭矩的作用下绕z轴转动，实现飞行器的偏航运动，转向与 电机1、电机3 的转向相反；<br>
  因为电机的总升力不变，飞机不会发生垂直运动；</p>
<div align=center><img width = '300' height ='240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/move-4.PNG"/></div>
<center>图8-1. 偏航运动（图 d）</center><br>
<div align=center><img width = '320' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/yaw.PNG"/></div>
<center>图8-2. Yaw</center><br>
<h4 id="2-5-前后运动"><a class="header-anchor" href="#2-5-前后运动">¶</a>2.5 前后运动</h4>
<p>  要想实现飞行器在水平面内前后、左右的运动，必须在水平面内对飞行器施加一定的力；<br>
  在图 e 中，增加 电机3 转速，使拉力增大，相应减小 电机1 转速，使拉力减小，同时保持其它两个电机转速不变，反扭矩仍然要保持平衡；<br>
  按图 b 的理论，飞行器首先发生一定程度的倾斜，从而使旋翼拉力产生水平分量，因此可以实现飞行器的前飞运动，向后飞行与向前飞行正好相反；<br>
  当然在图 b 图 c 中，飞行器在产生俯仰、翻滚运动的同时也会产生沿 x、y 轴的水平运动；</p>
<div align=center><img width = '300' height ='240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/move-5.PNG"/></div>
<center>图9. 前后运动（图 e）</center><br>
<h4 id="2-6-侧向运动"><a class="header-anchor" href="#2-6-侧向运动">¶</a>2.6 侧向运动</h4>
<p>  在图 f 中，由于结构对称，所以侧向飞行的工作原理与前后运动完全一样；</p>
<div align=center><img width = '300' height ='240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/move-6.PNG"/></div>
<center>图10. 侧向运动（图 f）</center><br>
<h3 id="3-飞行姿态与电机转速关系"><a class="header-anchor" href="#3-飞行姿态与电机转速关系">¶</a>3. 飞行姿态与电机转速关系</h3>
<p>  由于主流的设计思想是将四旋翼飞行器设计为X模型，这里给出X模型的飞行姿态与电机转速关系，原理与十模型基本一致。</p>
<p>  不妨设悬停状态下4个电机的转速为M1、M2、M3、M4：</p>
<center>
<table border=0 cellpadding=0 cellspacing=0 width=432 style='border-collapse:
 collapse;table-layout:fixed;width:324pt'>
 <col width=72 span=6 style='width:54pt'>
 <tr height=19 style='height:14.25pt'>
  <td colspan=2 rowspan=2 height=38 class=xl638550 width=144 style='height:
  28.5pt;width:108pt'>动作</td>
  <td rowspan=2 class=xl638550 width=72 style='width:54pt'><span
  style='mso-spacerun:yes'>&nbsp;</span>电机1</td>
  <td rowspan=2 class=xl638550 width=72 style='width:54pt'><span
  style='mso-spacerun:yes'>&nbsp;</span>电机2</td>
  <td rowspan=2 class=xl638550 width=72 style='width:54pt'><span
  style='mso-spacerun:yes'>&nbsp;</span>电机3</td>
  <td rowspan=2 class=xl638550 width=72 style='width:54pt'><span
  style='mso-spacerun:yes'>&nbsp;</span>电机4</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=2 height=38 class=xl638550 style='height:28.5pt'>悬停</td>
  <td class=xl638550>/</td>
  <td rowspan=2 class=xl638550>M1</td>
  <td rowspan=2 class=xl638550>M2</td>
  <td rowspan=2 class=xl638550>M3</td>
  <td rowspan=2 class=xl638550>M4</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl638550 style='height:14.25pt'>/</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=2 height=38 class=xl638550 style='height:28.5pt'>垂直</td>
  <td class=xl638550>上升</td>
  <td class=xl638550>M1+</td>
  <td class=xl638550>M2+</td>
  <td class=xl638550>M3+</td>
  <td class=xl638550>M4+</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl638550 style='height:14.25pt'>下降</td>
  <td class=xl638550>M1-</td>
  <td class=xl638550>M2-</td>
  <td class=xl638550>M3-</td>
  <td class=xl638550>M4-</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=2 height=38 class=xl638550 style='height:28.5pt'>横滚</td>
  <td class=xl638550>左移</td>
  <td class=xl638550>M1-</td>
  <td class=xl638550>M2+</td>
  <td class=xl638550>M3-</td>
  <td class=xl638550>M4+</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl638550 style='height:14.25pt'>右移</td>
  <td class=xl638550>M1+</td>
  <td class=xl638550>M2-</td>
  <td class=xl638550>M3+</td>
  <td class=xl638550>M4-</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=2 height=38 class=xl638550 style='height:28.5pt'>俯仰</td>
  <td class=xl638550>前移</td>
  <td class=xl638550>M1-</td>
  <td class=xl638550>M2-</td>
  <td class=xl638550>M3+</td>
  <td class=xl638550>M4+</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl638550 style='height:14.25pt'>后移</td>
  <td class=xl638550>M1+</td>
  <td class=xl638550>M2+</td>
  <td class=xl638550>M3-</td>
  <td class=xl638550>M4-</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td rowspan=2 height=38 class=xl638550 style='height:28.5pt'>偏航</td>
  <td class=xl638550>顺时针</td>
  <td class=xl638550>M1-</td>
  <td class=xl638550>M2+</td>
  <td class=xl638550>M3+</td>
  <td class=xl638550>M4-</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl638550 style='height:14.25pt'>逆时针</td>
  <td class=xl638550>M1+</td>
  <td class=xl638550>M2-</td>
  <td class=xl638550>M3-</td>
  <td class=xl638550>M4+</td>
 </tr>
 <![if supportMisalignedColumns]>
 <tr height=0 style='display:none'>
  <td width=72 style='width:54pt'></td>
  <td width=72 style='width:54pt'></td>
  <td width=72 style='width:54pt'></td>
  <td width=72 style='width:54pt'></td>
  <td width=72 style='width:54pt'></td>
  <td width=72 style='width:54pt'></td>
 </tr>
 <![endif]>
</table>
</center>
<hr>
<h2 id="四、姿态解算分析"><a class="header-anchor" href="#四、姿态解算分析">¶</a>四、姿态解算分析</h2>
<h3 id="1-概述-v3"><a class="header-anchor" href="#1-概述-v3">¶</a>1. 概述</h3>
<p>  四旋翼飞行器具有6个自由度，通过 <strong>IMU 惯性测量单元</strong> 实时测量飞行器三个轴向的旋转角速度和加速度，进行数据融合与姿态解算，从而控制飞行器的4个输入控制量，以达到飞行器平衡飞行的目的。</p>
<p>  其简易控制逻辑如图11所示，其中 <strong>GYRO</strong> 指 <strong>陀螺仪（Gyroscope）</strong> ， <strong>ACC</strong> 指 <strong>加速度计（Accelerometer）</strong> ， <strong>PWM</strong> 指 <strong>脉冲宽度调制（Pulse width modulation）</strong> ， <strong>Remote</strong> 指 <strong>远端</strong> 。</p>
<div align=center><img width = '500' height ='250' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/IMU-1.PNG"/></div>
<center>图11. 简易控制逻辑</center><br>
<p>  姿态解算是 <strong>捷联式惯性导航系统（SINS）</strong> 的关键技术，通过位姿矩阵可以得到载体的姿态和导航参数计算需要的数据，是捷联式惯导算法中的重要工作。载体的姿态和航向体现了载体坐标系和导航坐标系之间的方位关系，确定两个坐标系之间的方位关系需要借助矩阵法和力学中的刚体定点运动的位移定理，通过矩阵法推导方向余弦表，而刚体定点运动的位移定理表明，定点运动刚体的任何有限位移都可以绕过定点的某一轴经过一次转动来实现。那么，一个动坐标系相对参考坐标系的方位可以完全由动坐标系一次让三个不同的轴转动的三个角度，即一组欧拉角来确定。</p>
<p>  目前，描述动坐标相对参考坐标系方位关系的方法可以简单地将其分为三类，即三参数法，四参数法和九参数法，三参数法也称 <strong>欧拉角法</strong> ，四参数法通常指 <strong>四元数法</strong> ，九参数法称为 <strong>方向余弦法</strong> 。</p>
<p>  欧拉角法推导出的微分方程式皆含有三角函数运算，计算速度慢，方程出现“奇点”，且实时计算困难，故难以广泛用于工程实践；方向余弦法避免了奇点现象，但方程的计算量大，工作效率低；相比较而言，四元数法更能够合理地描述载体的刚体空间运动。</p>
<h3 id="2-姿态模块"><a class="header-anchor" href="#2-姿态模块">¶</a>2. 姿态模块</h3>
<p>  姿态模块可以使用 Invensense 公司的消费级陀螺仪传感器，如六轴系列的 <strong>MPU6050</strong> 、九轴系列的 <strong>MPU9250</strong> 等，可输出六轴数据的传感器模块包括基础的三轴（X, Y, Z）角速度数据，三轴加速度数据，而九轴系列传感器还会输出三轴地磁数据，如果在加上气压计芯片获取高度就会构成十轴传感器模块。</p>
<p>  有了姿态模块输出角速度、加速度、地磁数据后，就能通过算法计算出四轴相对于地心坐标系偏差的角度，以及此时偏差的速度大小（角速度）。对于姿态计算可以使用 <strong>AHRS（航姿参考系统）</strong> 和 <strong>IMU（惯性测量单元）</strong> 算法。 AHRS 由加速度计、地磁计和陀螺仪构成，是一种相对广泛使用的算法。其优点是使用多组数据进行融合，保障了数据的准确性；其缺点是太过于依赖地磁数据进行融合，磁场传感器一旦受到干扰，数据融合就可能出错，造成严重后果。IMU 则放弃了地磁数据，单纯地用角速度计算出角度。当四轴处于惯性参考系中飞行效果与 AHRS 比较相差甚微，而当四轴突然加速或减速时，机体处于非惯性参考系下，加速计数据短暂失真，表现在四轴上会发生振荡现象。</p>
<h3 id="3-IMU惯性导航姿态算法"><a class="header-anchor" href="#3-IMU惯性导航姿态算法">¶</a>3. IMU惯性导航姿态算法</h3>
<h4 id="3-1-算法分析"><a class="header-anchor" href="#3-1-算法分析">¶</a>3.1 算法分析</h4>
<p>  IMU惯性导航姿态算法，即利用四元数法进行姿态解算，其算法流程图如图12所示。</p>
<p>  从流程图中可以看出，其主要思想还是利用加速度计对陀螺仪进行修正，其修正的快慢程度由参数进行控制，由于使用该方法步骤较为繁琐，涉及中间变量转换较多，且计算量较大，占用内存也较大，使用起来很不方便。为解决该问题，运动控制传感器（例如 MPU6050 ）在内部提供了 DMP 四元数解算功能，可以直接输出四元数数据，从而省略了繁琐的计算步骤，给设计带来了极大便利，大大简化了四轴飞行器的代码设计量。</p>
<p>  <strong>DMP（数字运动处理器）</strong> ，是 MPU 内部集成的处理单元，也就是说，MPU6050，或者MPU9250，并不单单是传感器，其内部还包含了可以独立完成姿态解算算法的处理单元。因其使用的是 Invensense 公司官方提供的姿态解算算法，与入门级的开发者相比有着较高的可靠性，且能够将微处理器从算法处理的压力中解放出来，只需要等待 DMP 解算完成后产生外部中断，在中断里读取姿态解算的结果，于是，在实际设计中，一般使用 DMP 来实现传感器融合算法，这里为了学习了解算法背后的飞行控制原理，对用四元数法进行姿态解算的算法进行深入分析。</p>
<div align=center><img width = '300' height ='700' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%9B%9B%E5%85%83%E6%95%B0%E6%B3%95%E5%A7%BF%E6%80%81%E8%A7%A3%E7%AE%97%E6%B5%81%E7%A8%8B.png"/></div>
<center>图12. 四元数法姿态解算流程</center><br>
<h4 id="3-2-坐标系统"><a class="header-anchor" href="#3-2-坐标系统">¶</a>3.2 坐标系统</h4>
<p>  为获取四旋翼飞行器控制系统的数学模型，必须先建立两个基本坐标系，即“地理”坐标系（惯性坐标系）和“载体”坐标系（机体坐标系）。“地理”坐标系指的就是地球上的 <strong>“东北天（ENU）”坐标系</strong> ，而“载体”坐标系指的就是四轴自己的坐标系。</p>
<h4 id="3-3-欧拉角与方向余弦矩阵"><a class="header-anchor" href="#3-3-欧拉角与方向余弦矩阵">¶</a>3.3 欧拉角与方向余弦矩阵</h4>
<p>  首先给出刚体定点运动的欧拉定理，又称刚体欧拉转动定理、欧拉旋转定理。</p>
<p><strong>刚体定点运动的欧拉定理：</strong></p>
<center>刚体定点运动的任意位移，可以通过绕该定点的某个轴线的一次转动来实现</center><br>
<p>  可以推知，空间中坐标系的任意旋转，等效于依次绕三个坐标系定轴的旋转，那么，一个动坐标系相对参考坐标系的方位可以完全由动坐标系一次让三个不同的轴转动的三个角度来确定。在四旋翼飞行器的控制系统中，动坐标系即指机体坐标系，而参考坐标系即为地球上的“东北天（ENU）”坐标系。</p>
<p>  然后给出欧拉角的定义:</p>
<p><strong>欧拉角：</strong></p>
<p>  刚体定点运动的自由度为3，如何选择3个变量，使它们既能简单、明确、单值地确定刚体位置，又能独立变化，这对简化定点运动的描述是非常重要的，刚体力学的奠基者欧拉（Leonhard Euler,1707一1783）成功地、巧妙地解决了这个问题，他选择3个角度，即著名的 <strong>欧拉角(Euler angles)</strong> 作为描述刚体定点运动的变量，具体选择方法如下：以固定点为原点建立静正坐标系 $o-\xi\eta\zeta$ ，再以固定点为原点建立与刚体固连的动坐标系 $o-xyz$ ，如下图所示：</p>
<div align=center><img width = '300' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/Euler_angles.png"/></div>
<center>图13. 欧拉角</center><br>
<p>  确定刚体位置等价于确定动坐标的位置，这里用两个角度确定 $z$ 轴的位置，一个是 $z$ 轴对 $\zeta$ 轴的倾角 $\theta$ 角，另一个是用来确定 $z$ 轴的方位，它是 $o-xy$ 面与平均赤道面 $o-\xi\eta$ 面的交线 $ON$ 与 $\xi$ 轴的夹角，交线 $ON$ 称为节线；这两个角确定后， $z$ 轴的位置就确定了，但动坐标系还可以绕 $z$ 轴转动，若动坐标的 $x$ 轴与节线的夹角 $\psi$ 确定了，则动坐标的位置完全确定，<strong>这样选取的3个角 $\theta$ ， $\phi$ ， $\psi$ 称为 欧拉角</strong> 。</p>
<p>  它们的量度方向如图所示，它们的变化范围分别为：$0\le\theta\le\pi，0\le\phi\le2\pi，0\le\psi\le2\pi$ 。</p>
<p>  为了表示动坐标系与参考坐标系的关系，引入 <strong>方向余弦</strong> ，在研究两坐标系之间的运动特性时，方向余弦用矩阵的形式表示，称 <strong>方向余弦矩阵</strong> ，也称为旋转矩阵、姿态矩阵，其元素是两组坐标系单位矢量之间夹角的正余弦值。</p>
<p><strong>方向余弦与方向余弦矩阵：</strong></p>
<p><strong>方向余弦：</strong></p>
<p>  在解析几何里，一个向量的三个方向余弦分别是这向量与三个坐标轴之间的角度的余弦。两个向量之间的方向余弦指的是这两个向量之间的角度的余弦。</p>
<p><strong>方向余弦矩阵：</strong></p>
<p>  方向余弦矩阵是由两组不同的标准正交基的基底向量之间的方向余弦所形成的矩阵。方向余弦矩阵可以用来表达一组标准正交基与另一组标准正交基之间的关系，也可以用来表达一个向量对于另一组标准正交基的方向余弦。</p>
<p>  方向余弦方法可以用来设定附体参考系B的取向，即刚体的取向。假设沿着参考系 $S$ 的坐标轴的三个单位向量分别为 $\widehat{\boldsymbol x}_1，\widehat{\boldsymbol x}_2，\widehat{\boldsymbol x}_3$ ，沿着参考系 $B$ 的坐标轴的三个单位向量分别为 $\widehat{\boldsymbol e}_1，\widehat{\boldsymbol e}_2，\widehat{\boldsymbol e}_3$ 。定义 $\widehat{\boldsymbol e}_i$ 与 $\widehat{\boldsymbol x}_j$ 之间的方向余弦 ${a} _{ij}$ 为：</p>
<p>$$a_{ij}\overset{\underset{\mathrm{def}}{}}{=}cos({\theta}_{ij})=\widehat{\boldsymbol e}_i\cdot\widehat{\boldsymbol x}_j；$$</p>
<p>  其中 ${\theta} _{ij}$ 是 $\widehat{\boldsymbol e}_i$ 与 $\widehat{\boldsymbol x}_j$ 之间的夹角。</p>
$\widehat{\boldsymbol e}_1,\widehat{\boldsymbol e}_2,\widehat{\boldsymbol e}_3$ 与 $\widehat{\boldsymbol x}_1,\widehat{\boldsymbol x}_2,\widehat{\boldsymbol x}_3$ 之间的关系分别为：
$$\widehat{\boldsymbol e}_1=cos({\theta}_{11})\cdot\widehat{\boldsymbol x}_1+cos({\theta}_{12})\cdot\widehat{\boldsymbol x}_2+cos({\theta}_{13})\cdot\widehat{\boldsymbol x}_3=a_{11}\widehat{\boldsymbol x}_1+a_{12}\widehat{\boldsymbol x}_2+a_{13}\widehat{\boldsymbol x}_3$$
$$\widehat{\boldsymbol e}_2=cos({\theta}_{21})\cdot\widehat{\boldsymbol x}_1+cos({\theta}_{22})\cdot\widehat{\boldsymbol x}_2+cos({\theta}_{23})\cdot\widehat{\boldsymbol x}_3=a_{21}\widehat{\boldsymbol x}_1+a_{22}\widehat{\boldsymbol x}_2+a_{23}\widehat{\boldsymbol x}_3$$
$$\widehat{\boldsymbol e}_3=cos({\theta}_{31})\cdot\widehat{\boldsymbol x}_1+cos({\theta}_{32})\cdot\widehat{\boldsymbol x}_2+cos({\theta}_{33})\cdot\widehat{\boldsymbol x}_3=a_{31}\widehat{\boldsymbol x}_1+a_{32}\widehat{\boldsymbol x}_2+a_{33}\widehat{\boldsymbol x}_3$$
<p>  两个参考系的坐标轴所形成的矩阵称为方向余弦矩阵 $A$ ：</p>
$$A=\begin{bmatrix}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{bmatrix}$$
<p>  采用爱因斯坦求和约定，由于 $\widehat{\boldsymbol e}_i=\sum_{}a_{ij}\cdot\widehat{\boldsymbol x}_j$ ，给定方向余弦矩阵 $A$ ，则可设定附体参考系 $B$ 的取向，也就是刚体的取向。</p>
<p>  给定位置向量：</p>
$$\boldsymbol r=x_1\widehat{\boldsymbol x}_1+x_2\widehat{\boldsymbol x}_2+x_3\widehat{\boldsymbol x}_3=e_1\widehat{\boldsymbol e}_1+e_2\widehat{\boldsymbol e}_2+e_3\widehat{\boldsymbol e}_3$$
<p>  则 $\boldsymbol r$ 与 $\widehat{\boldsymbol e}_i$ 的内积为：</p>
$$\boldsymbol r\cdot\widehat{\boldsymbol e}_i=e_i=a_{i1}x_1+a_{i2}x_2+a_{i3}x_3=a_{ij}x_j$$
<p>  方向余弦矩阵 $A$ 可以将从空间参考系 $S$ 观测的位置坐标，变换为从附体参考系 $B$ 观测的位置坐标，因此又称为 <strong>变换矩阵</strong> 。</p>
<p>  变换矩阵 $A$ 是一种正交矩阵，满足正交条件：</p>
<p>$$a_{ij}a_{jk}={\delta}_{ik}$$</p>
<p>  其中 ${\delta}_{ik}$ 为 <strong>克罗内克函数</strong> ，满足 ${\delta}_{ik}\begin{cases} 1\ \ \ \ (i=k) \\ 0\ \ \ \ (i \neq k) \end{cases}$ 。</p>
<p>  变换矩阵可以视为旋转矩阵。例如将附体参考系 $B$ 或刚体旋转，从 $\widehat{\boldsymbol e}_1,\widehat{\boldsymbol e}_2,\widehat{\boldsymbol e}_3$ 旋转 $\theta$ 角弧成为 $\widehat{\boldsymbol e}’_1,\widehat{\boldsymbol e}’_2,\widehat{\boldsymbol e}’_3$ ；其中， $\widehat{\boldsymbol e}_3=\widehat{\boldsymbol e}’_3$ 。对于这个旋转，旋转矩阵 $A$ 为：</p>
$$A=\begin{bmatrix}
cos\theta & sin\theta & 0 \\
-sin\theta & cos\theta & 0 \\
0 & 0 & 1
\end{bmatrix}$$
<p>  有了以上数学物理工具的支持，可以开始对四旋翼飞行器的空间姿态进行描述。</p>
<h4 id="3-4-空间姿态常规描述"><a class="header-anchor" href="#3-4-空间姿态常规描述">¶</a>3.4 空间姿态常规描述</h4>
<p>分别定义欧拉角：<br>
  $\psi$ 为飞行器的航角， $\theta$ 为飞行器的仰角， $\phi$为飞行器的滚角。</p>
<p>  那么需求得用三个欧拉角 $(\phi,\theta,\psi)$ 表示的机体坐标系与参考坐标系之间的方向余弦矩阵：</p>
<p>  将机体坐标系 $b$ 的转动分解为分别绕参考坐标系 $n$ 的 $X,Y,Z$ 轴的简单转动，如图14所示：（注意笛卡尔坐标系左手系与右手系的区别，此处使用右手系）</p>
<div align=center><img width = '800' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2.PNG"/></div>
<center>图14. 转动分解</center><br>
<p>  分别求解三次简单转动的方向余弦矩阵：</p>
<p>  这里以绕 $Z$ 轴的简单转动为例，说明求解过程，其余直接给出其方向余弦矩阵。</p>
<p>  如图15所示，点 $v$ 绕原点旋转 $\alpha$ 角，得到点 $v’$，假设 $v$ 点的坐标为 $(x,y)$ ，那么可以推导得到 $v’$ 点的坐标 $(x’,y’)$ （设原点到点 $v$ 的距离为 $r$ ，原点到点 $v$ 的向量与 $X$ 轴的夹角为 $\beta$）：</p>
<div align=center><img width = '200' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/Z-1.PNG"/></div>
<center>图15. 绕 Z 轴转动</center><br>
<p>$$x=rcos\beta$$</p>
<p>$$y=rsin\beta$$</p>
<p>$$x’=rcos(\alpha+\beta)$$</p>
<p>$$y’=rsin(\alpha+\beta)$$</p>
<p>  通过三角函数展开得到：</p>
<p>$$x’=rcos\alpha cos\beta - rsin\alpha sin\beta$$</p>
<p>$$y’=rsin\alpha cos\beta + rcos\alpha sin\beta$$</p>
<p>  将 $x,y$ 代入得：</p>
<p>$$x’=xcos\alpha-ysin\alpha$$</p>
<p>$$y’=xsin\alpha+ycos\alpha$$</p>
<p>  由于 $Z$ 为旋转轴，所以 $z$ 坐标保持不变：</p>
<p>$$z’=z$$</p>
<p>  将方程组写成矩阵形式：</p>
$$\begin{bmatrix}x' \\y' \\z' \end{bmatrix}=\begin{bmatrix}cos\alpha & -sin\alpha & 0 \\sin\alpha & cos\alpha & 0 \\0 & 0 & 1\end{bmatrix}\begin{bmatrix}x \\y \\z \end{bmatrix}$$
<p>  将 $\alpha$ 角替换为飞行器的航角 $\psi$：</p>
$$\begin{bmatrix}x' \\y' \\z' \end{bmatrix}=\begin{bmatrix}cos\psi & -sin\psi & 0 \\sin\psi & cos\psi & 0 \\0 & 0 & 1\end{bmatrix}\begin{bmatrix}x \\y \\z \end{bmatrix}$$
<p>  即有：</p>
$$C^{b3}_{n}=\begin{bmatrix}cos\psi & -sin\psi & 0 \\sin\psi & cos\psi & 0 \\0 & 0 & 1\end{bmatrix}$$
<p>  同理可得：</p>
<p>  绕 $Y$ 轴转动：</p>
$$C^{b2}_{n}=\begin{bmatrix}cos\theta & 0 & -sin\theta \\0 & 1 & 0 \\sin\theta & 0 & cos\theta\end{bmatrix}$$
<p>  绕 $X$ 轴转动：</p>
$$C^{b1}_{n}=\begin{bmatrix}1 & 0 & 0 \\0 & cos\phi & sin\phi \\0 & -sin\phi & cos\phi\end{bmatrix}$$
<p>  则用三个欧拉角 $(\phi,\theta,\psi)$ 表示的机体坐标系与参考坐标系之间的方向余弦矩阵可求得为：</p>
$$C^b_n=C^{b1}_{n}C^{b2}_{n}C^{b3}_{n}=\begin{bmatrix}1 & 0 & 0 \\0 & cos\phi & sin\phi \\0 & -sin\phi & cos\phi\end{bmatrix}\begin{bmatrix}cos\theta & 0 & -sin\theta \\0 & 1 & 0 \\sin\theta & 0 & cos\theta\end{bmatrix}\begin{bmatrix}cos\psi & -sin\psi & 0 \\sin\psi & cos\psi & 0 \\0 & 0 & 1\end{bmatrix}$$<br>
$$C^b_n=\begin{bmatrix}cos\theta cos\psi+sin\theta sin\psi sin\phi & sin\theta cos\psi sin\phi - cos\theta sin\psi & -sin\theta cos\phi \\sin\psi cos\phi & cos\psi cos\phi & sin\phi \\sin\theta cos\psi - cos\theta sin\psi sin\phi & -cos\theta cos\psi sin\phi - sin\theta sin\psi & cos\theta cos\phi\end{bmatrix}$$<br>
<p>  如何应用该结论呢？</p>
<p>  记：</p>
$$C^n_b=\begin{bmatrix}T_{11} & T_{12} & T_{13} \\T_{21} & T_{22} & T_{23} \\T_{31} & T_{32} & T_{33}\end{bmatrix}$$
<p>  则由于矩阵正交，有：</p>
$$C^n_b=(C^b_n)^{T}=\begin{bmatrix}T_{11} & T_{21} & T_{31} \\T_{12} & T_{22} & T_{32} \\T_{13} & T_{23} & T_{33}\end{bmatrix}$$
<p>  根据矩阵可以反解出三个轴的角度——欧拉角：</p>
$$\begin{cases}
\phi=arcsin(T_{32}) \\\\
\theta=arctan(-{\dfrac {T_{31}}{T_{33}}}) \\\\
\psi=arctan(\dfrac {T_{12}}{T_{22}})
\end{cases}$$
<p>  但该结论还不能够应用到四旋翼姿态解算中：<br>
    (1)函数与自变量量相同；<br>
    (2)含有大量三角运算，加重了运算负担，拖慢了运算效率。</p>
<p>  在此思路上，希望能够换一种变量来表示该矩阵，保证方程可解的基础上还能提高运算效率。</p>
<p>  于是引入四元数与罗德里格旋转公式。</p>
<h4 id="3-5-四元数"><a class="header-anchor" href="#3-5-四元数">¶</a>3.5 四元数</h4>
<p>  <strong>四元数（Quaternions）</strong> 是由爱尔兰数学家哈密顿(William Rowan Hamilton,1805-1865）在1843年发明的数学概念。它是简单的超复数。 复数是由实数加上虚数单位 $i$ 组成，其中 $i^2=-1$ 。 相似地，四元数都是由实数加上三个虚数单位 $i、j、k$ 组成，而且它们有如下的关系： $i^2 = j^2 = k^2 = -1， i^0 = j^0 = k^0 = 1$ , 每个四元数都是 $1、i、j$ 和 $k$ 的线性组合，即是四元数一般可表示为 $a + bi+ cj + dk$ ，其中 $a、b、c 、d$ 是实数。</p>
<p>  明确地说，四元数是复数的不可交换延伸。如把四元数的集合考虑成多维实数空间的话，四元数就代表着一个四维空间，相对于复数为二维空间。</p>
<p>  四元数有如下的表达形式：</p>
<p>$$Q=q_0 + q_1 \dot i + q_2 \dot j+q_3 \dot k$$</p>
<p>$$Q=cos{\dfrac \theta 2}+\vec{\lambda}sin{\dfrac \theta 2}$$</p>
$$Q=\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \end{bmatrix}$$
<h4 id="3-6-罗德里格旋转公式"><a class="header-anchor" href="#3-6-罗德里格旋转公式">¶</a>3.6 罗德里格旋转公式</h4>
<p>  为了让空间中旋转的坐标变换过程能够与四元数之间建立关系，可以以某向量为研究对象引入更广义的空间旋转过程的计算公式——罗德里格旋转公式。</p>
<p>  <strong>罗德里格旋转公式（Rodrigues’ rotation formula）</strong> 是计算三维空间中，一个向量绕旋转轴旋转给定角度以后得到的新向量的计算公式。这个公式使用原向量，旋转轴及它们叉积作为标架表示出旋转以后的向量。可以改写为矩阵形式，被广泛应用于空间解析几何和计算机图形学领域，成为刚体运动的基本计算公式。</p>
<p>  四元数可以很方便地表示旋转变换。但在很多场合中，使用矩阵形式和向量形式表达旋转更有利于推导。向量旋转公式最早由法国数学家本杰明·奥伦德·罗德里格(Benjamin Olinde Rodrigues(1795–1851))导出，后来被应用在很多领域。</p>
<div align=center><img width = '300' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/R-3.PNG"/></div>
<center>图16. 罗德里格旋转公式示意图-1</center><br>
<p>  设v是一个三维空间向量，$\boldsymbol k$ 是旋转轴的单位向量，则 $\boldsymbol v$ 在右手螺旋定则意义下绕旋转轴 $\boldsymbol k$ 旋转角度 $\theta$ 得到的向量可以由三个不共面的向量 $\boldsymbol v，\boldsymbol k$ 和 $\boldsymbol k \times \boldsymbol v$ 构成的标架表示：</p>
<p>$$\boldsymbol v_{rot}=cos\theta \cdot \boldsymbol v+(1-cos\theta)(\boldsymbol v \cdot \boldsymbol k)\boldsymbol k+sin\theta \cdot \boldsymbol k \times \boldsymbol v$$</p>
<p>  根据此公式推导可得以下结论：</p>
<div align=center><img width = '200' height ='250' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/R-2.PNG"/></div>
<center>图17. 罗德里格旋转公式示意图-2</center><br>
<p>$$\overrightarrow{D B}^{R}=U \cdot \overrightarrow{D B}^{b}$$</p>
<p>  $U$ 为刚体旋转过程中 $b$ 系到 $R$ 系的坐标变换矩阵：</p>
<p>$$U=C_b^R=I+2Jcos{\dfrac \theta 2}+2K$$</p>
<p>  其中：</p>
<p>    $I$ 为三阶单位矩阵：</p>
$$I=\begin{bmatrix}1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & 1 \end{bmatrix}$$<br>
$$J=\begin{bmatrix}0 & -nsin{\dfrac \theta 2} & msin{\dfrac \theta 2} \\\\nsin{\dfrac \theta 2} & 0 & -lsin{\dfrac \theta 2} \\\\-msin{\dfrac \theta 2} & lsin{\dfrac \theta 2} & 0 \end{bmatrix}$$<br>
$$K=
\begin{bmatrix}-(m^2+n^2)sin^2{\dfrac \theta 2} & lmsin^2{\dfrac \theta 2} & nlsin^2{\dfrac \theta 2} \\\\lmsin^2{\dfrac \theta 2} & -(l^2+n^2)sin^2{\dfrac \theta 2} & mnsin^2{\dfrac \theta 2} \\\\nlsin^2{\dfrac \theta 2} & mnsin^2{\dfrac \theta 2} & -(m^2+l^2)sin^2{\dfrac \theta 2} \end{bmatrix}$$<br>
<p>  在 $K$ 中， $l、m、n$ 分别是向量 $\overrightarrow{D E}$ 在 $R$ 系的旋转瞬轴，结合四元数的三角表示式，令：<br>
$$Q=cos{\dfrac \theta 2}+(l\boldsymbol i+m\boldsymbol j+n\boldsymbol k)sin{\dfrac \theta 2}$$</p>
<p>  即有：</p>
$$\begin{cases}
q_0=cos{\dfrac \theta 2} \\\\
q_1=lsin{\dfrac \theta 2} \\\\
q_2=msin{\dfrac \theta 2} \\\\
q_3=nsin{\dfrac \theta 2}
\end{cases}$$
<p>  将 $q$ 代入 $U$，$U$ 等价于方向余弦矩阵：</p>
$$C_b^R=\begin{bmatrix}
q_0^2+q_1^2-q_2^2-q_3^2 & 2(q_1 q_2-q_0 q_3) & 2(q_1 q_3+q_0 q_2) \\
\\
2(q_1 q_2+q_0 q_3) & q_0^2-q_1^2+q_2^2-q_3^2 & 2(q_3 q_2-q_0 q_1) \\
\\
2(q_1 q_3-q_0 q_2) & 2(q_3 q_2+q_0 q_1) & q_0^2-q_1^2-q_2^2+q_3^2
\end{bmatrix}$$
<p>  于是可以反解欧拉角：</p>
$$\begin{cases}
\phi=arcsin(T_{32})=arcsin(C_{23}) \\\\
\theta=arctan(-{\dfrac {T_{31}}{T_{33}}})=arctan(-{\dfrac {C_{13}}{C_{33}}}) \\\\
\psi=arctan(\dfrac {T_{12}}{T_{22}})=arctan(\dfrac {C_{21}}{C_{22}})
\end{cases}$$
<p>  可得：</p>
$$\begin{cases}
\phi=arcsin[2(-q_0 q_1+q_2 q_3)] \\\\
\theta=-arctan({\dfrac{2(q_0 q_2+q_1 q_3)}{q_0^2-q_1^2-q_2^2+q_3^2}}) \\\\
\psi=arctan({\dfrac{2(q_1 q_2+q_0 q_3)}{q_0^2-q_1^2+q_2^2-q_3^2}})
\end{cases}$$
<p>  那么现在问题就变成了如何求取四元数中的 $q_0、q_1、q_2、q_3$ 。</p>
<h4 id="3-7-四元数的求解与一阶龙格-库塔法"><a class="header-anchor" href="#3-7-四元数的求解与一阶龙格-库塔法">¶</a>3.7 四元数的求解与一阶龙格-库塔法</h4>
<p>  到目前为止，飞行器姿态的改变已经转换成了对应四元数的改变，因此实时的姿态计算需要实时更新四元数。于是在此构建四元数关于时间的微分方程，来研究四元数的变化规律，又因为考虑到与四元数直接相关的变量是角度，因此，利用四元数的三角表示式来建立四元数微分方程，并求解该微分方程，即可成功解出四元数。</p>
<p>$$Q=cos{\dfrac \theta 2}+\vec{\lambda}sin{\dfrac \theta 2}$$</p>
<p>  令该四元数对时间 $t$ 进行微分，可得微分方程为：</p>
$$\dfrac{\mathrm{d}Q}{\mathrm{d}t}={\dfrac 1 2}
\begin{bmatrix}
0 & -{\omega}_x & -{\omega}_y & -{\omega}_z \\
{\omega}_x & 0 & {\omega}_z & -{\omega}_y \\
{\omega}_y & -{\omega}_z & 0 & {\omega}_x \\
{\omega}_z & {\omega}_y & -{\omega}_x & 0
\end{bmatrix}
\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \end{bmatrix}$$
<p>  记为：</p>
<p>$$\dfrac{\mathrm{d}Q}{\mathrm{d}t}=\Phi \cdot Q$$</p>
<p>  求解该微分方程即可得到当下的四元数。</p>
<p>  为了在单片机中能够求解微分方程，引入一阶龙格-库塔法。</p>
<p><strong>一阶龙格-库塔法（Runge-Kutta）：</strong></p>
<p>  龙格-库塔(Runge-Kutta)方法是一种在工程上应用广泛的高精度单步算法，其中包括著名的欧拉法（Euler’s method），用于数值求解微分方程，该算法是构建在数学支持的基础之上的。</p>
<p>  一阶龙格库塔法，即对应于“一阶精度欧拉公式”：</p>
$$\begin{cases}
y'=\dfrac{\mathrm{d}y}{\mathrm{d}x}=f(x,y) \\\\
y_{i+1}=y_i+h\cdot K_1 \\\\
K_1= f(x_i,y_i)
\end{cases}$$
<p>  其中 $h$ 为步长。</p>
<p>  设有微分方程：</p>
$$\dfrac{\mathrm{d}y}{\mathrm{d}x}=f(x,y)$$
<p>  根据一阶龙格-库塔法可以得到求解 $y$ 的迭代公式：</p>
$$y(\lambda + \Delta\lambda)=y(\lambda)+\Delta\lambda\cdot f(x(\lambda),y(\lambda))$$
<p>  对应四元数微分方程：</p>
$$Q(t + \Delta t)=Q(t)+\Delta t \cdot \Phi(t) \cdot Q(t)$$
<p>  整理可得最终的计算结论：</p>
$$\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \end{bmatrix}_{t+\Delta t}=\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \end{bmatrix}_t+{\dfrac 1 2} \cdot \Delta t \cdot
\begin{bmatrix}
-\omega_x \cdot q_1-\omega_y \cdot q_2-\omega_z \cdot q_3 \\
\omega_x \cdot q_0-\omega_y \cdot q_3+\omega_z \cdot q_2 \\
\omega_x \cdot q_3+\omega_y \cdot q_0-\omega_z \cdot q_1 \\
-\omega_x \cdot q_2+\omega_y \cdot q_1+\omega_z \cdot q_0
\end{bmatrix}$$<br>
<p>  对该结论利用C语言编程，即可实现对四元数的求解，而求解过程中需要用到三轴角速度数据，要想准确获取机体的实时姿态，则要求三轴角速度数据足够准确，可行的想法是，利用加速度计对陀螺仪的数据进行修正。</p>
<h4 id="3-8-传感器数据融合——基于四元数的互补滤波法-向量外积补偿"><a class="header-anchor" href="#3-8-传感器数据融合——基于四元数的互补滤波法-向量外积补偿">¶</a>3.8 传感器数据融合——基于四元数的互补滤波法(向量外积补偿)</h4>
<div align=center><img width = '800' height ='180' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/CF-2.PNG"/></div>
<center>图18. 角度计算中的误差</center><br>
<p>  <strong>互补滤波法（Complementary Filter）</strong> 的思路是，加速度计由于其自身灵敏度较高，在振动较大的场合，加速度计的测量值容易混入振动等噪声，也就是说，加速度计在瞬时精度上容易受到外部干扰，而有很大误差，这种误差属于高频误差；陀螺仪的测量值是角速度，短时间内将角速度按时间积分得到的角度是比较准确的，但是此时得到的角度带有累积误差，这种误差属于低频误差。可以利用这两种传感器的特性来互补，得到正确的角度。</p>
<p>  但是这里并不打算用常规的互补滤波算法来实现互补滤波，而是采用向量外积补偿的方法来实现。</p>
<div align=center><img width = '800' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/filter-2.PNG"/></div>
<center>图19. 互补滤波法（Complementary Filter）</center><br>
<div align=center><img width = '1000' height ='600' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A/filter-1.PNG"/></div>
<center>图20. 用向量外积补偿的方式实现基于四元数的互补滤波</center><br>
<p>  在图20中，$a_x,a_y,a_z$ 为机体坐标参考系上加速度计测出来的重力加速度分量经过单位化后得到的单位重力加速度分量，相当于是实际重力加速度分量；$v_x,v_y,v_z$ 为用三轴陀螺仪角速度数据经过换算、积分后得到的单位重力加速度分量，相当于是理论重力加速度分量。若能够表示出两者之间的误差，就能够用这个误差去补偿陀螺仪输出的角速度，从而计算出更新的四元数。</p>
<p>  这个误差属于向量之间的误差，可以用向量外积（即向量叉积）来表示。</p>
<p>  这个向量叉积仍然是位于机体坐标系上的，而陀螺积分误差也在机体坐标系上，而且叉积的大小与陀螺积分误差呈正比，正好拿来补偿陀螺仪角速度数据。</p>
<h4 id="3-9-构建PI（比例-积分）控制器"><a class="header-anchor" href="#3-9-构建PI（比例-积分）控制器">¶</a>3.9 构建PI（比例-积分）控制器</h4>
<p>  得到用向量外积表示的误差后，接下来需要构建PI（比例-积分）控制器来控制补偿值的大小与精度。（其中有关自动控制原理特性的分析，此处不再体现）</p>
$$error\_GYRO=K_p\cdot error+K_I\cdot \int error$$
<p>  积分项用来消除静态误差，比例项用来控制传感器的“可信度”，$K_p$ 越大，则更加信任加速度计，$K_p$ 越小，则更加信任陀螺仪。</p>
<p>  把补偿量加到角速度上，即可得到可信度较高的陀螺仪数据，之后代入龙格库塔法即可得到当前的四元数。</p>
$$value\_GYRO=value\_GYRO+error\_GYRO$$
<h4 id="3-10-算法流程与总体代码分析"><a class="header-anchor" href="#3-10-算法流程与总体代码分析">¶</a>3.10 算法流程与总体代码分析</h4>
<h5 id="3-10-1-四元数法姿态解算流程"><a class="header-anchor" href="#3-10-1-四元数法姿态解算流程">¶</a>3.10.1 四元数法姿态解算流程</h5>
<p>(1)初始化四元数：</p>
<p>  设当前的坐标系为机体坐标系，则四元数列向量：</p>
$$\boldsymbol q=\begin{bmatrix}q_0 & q_1 & q_2 & q_3 \end{bmatrix}^T=
\begin{bmatrix}1 & 0 & 0 & 0 \end{bmatrix}^T$$
<p>(2)获取角速度、加速度：</p>
<p>  读取三轴加速度计和三轴陀螺仪的信号，并经过IIR低通滤波器滤波滤除振动噪声，得到重力加速度分量和角速度分量 $acc_x,acc_y,acc_z$ 和角速度分量 $w_x,w_y,w_z$ 。</p>
<p>(3)将加速度计测量值 $acc_x,acc_y,acc_z$ 转化为三维的单位向量（归一化）：</p>
$$\begin{cases}
a_x={\dfrac {acc_x}{\sqrt {acc_x^2+acc_y^2+acc_z^2}}} \\\\
a_y={\dfrac {acc_y}{\sqrt {acc_x^2+acc_y^2+acc_z^2}}} \\\\
a_z={\dfrac {acc_z}{\sqrt {acc_x^2+acc_y^2+acc_z^2}}}
\end{cases}$$
<p>  代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">norm = <span class="built_in">sqrt</span>(ax * ax + ay * ay + az * az);</span><br><span class="line">ax = ax / norm;</span><br><span class="line">ay = ay / norm;</span><br><span class="line">az = az / norm;</span><br></pre></td></tr></table></figure>
<p>(4)用四元数表示三轴的重力分量 $V_x,V_y,V_z$：<br>
  （对应着已求出的用四元数表示的方向余弦矩阵 $C_b^R$ 的第三行）</p>
$$\begin{cases}
V_x=2(q_1 q_3-q_0 q_2) \\\\
V_y=2(q_0 q_1+q_2 q_3) \\\\
V_z=q_0^2-q_1^2-q_2^2+q_3^2
\end{cases}$$
<p>  式中的 $V_x,V_y,V_z$ 即重力单位向量在机体坐标系中的分量。</p>
<p>  代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vx = <span class="number">2</span> * (q1 * q3 - q0 * q2);</span><br><span class="line">vy = <span class="number">2</span> * (q0 * q1 + q2 * q3);</span><br><span class="line">vz = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3;</span><br></pre></td></tr></table></figure>
<p>(5)求四元数所求重力分量与加速度计测量值的误差值：</p>
$$\begin{cases}
e_x=a_y \times V_z - a_z \times V_y \\\\
e_y=a_z \times V_x - a_x \times V_z \\\\
e_z=a_x \times V_y - a_y \times V_x
\end{cases}$$
<p>  代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ex = (ay * vz - az * vy);</span><br><span class="line">ey = (az * vx - ax * vz);</span><br><span class="line">ez = (ax * vy - ay * vx);</span><br></pre></td></tr></table></figure>
<p>(6)利用所得的误差修正陀螺仪的测量值：<br>
(式中参数 $k_i,k_p$ 用以控制加速度计修正陀螺仪误差的过程)</p>
$$\begin{cases}
e_{xint} = {\widehat e}_{xint}+k_i \times e_x \\
{\dot w}_x = w_x + k_p \times e_x + e_{xint}
\end{cases}$$
$$\begin{cases}
e_{yint} = {\widehat e}_{yint}+k_i \times e_y \\
{\dot w}_y = w_y + k_p \times e_y + e_{yint}
\end{cases}$$
$$\begin{cases}
e_{zint} = {\widehat e}_{zint}+k_i \times e_z \\
{\dot w}_z = w_z + k_p \times e_z + e_{zint}
\end{cases}$$
<p>  代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exInt = exInt + ex * Ki;</span><br><span class="line">eyInt = eyInt + ey * Ki;</span><br><span class="line">ezInt = ezInt + ez * Ki;</span><br><span class="line"></span><br><span class="line">gx = gx + Kp * ex + exInt;</span><br><span class="line">gy = gy + Kp * ey + eyInt;</span><br><span class="line">gz = gz + Kp * ez + ezInt;</span><br></pre></td></tr></table></figure>
<p>(7)利用修正后的陀螺仪值 ${\dot w}_x,{\dot w}_y,{\dot w}_z$ 更新四元数：</p>
$$\begin{cases}
q_0={\widehat q}_0+{\dfrac {\mathrm{d}t}{2}}(-q_1{\dot w}_x-q_2{\dot w}_y-q_3{\dot w}_z) \\\\
q_1={\widehat q}_1+{\dfrac {\mathrm{d}t}{2}}(q_0{\dot w}_x+q_2{\dot w}_z-q_3{\dot w}_y) \\\\
q_2={\widehat q}_2+{\dfrac {\mathrm{d}t}{2}}(q_0{\dot w}_y-q_1{\dot w}_z+q_3{\dot w}_x) \\\\
q_3={\widehat q}_3+{\dfrac {\mathrm{d}t}{2}}(q_0{\dot w}_z+q_1{\dot w}_y-q_2{\dot w}_x)
\end{cases}$$
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">q0 = q0 + (-q1 * gx - q2 * gy - q3 * gz) * halfT;</span><br><span class="line">q1 = q1 + (q0 * gx + q2 * gz - q3 * gy) * halfT;</span><br><span class="line">q2 = q2 + (q0 * gy - q1 * gz + q3 * gz) * halfT;</span><br><span class="line">q3 = q3 + (q0 * gz + q1 * gy - q2 * gx) * halfT;</span><br></pre></td></tr></table></figure>
<p>(8)将得到更新后的四元数规范化：</p>
$$\begin{cases}
q_0={\dfrac {\widehat q_0}{\sqrt {q_0^2+q_1^2+q_2^2+q_3^2}}} \\\\
q_1={\dfrac {\widehat q_1}{\sqrt {q_0^2+q_1^2+q_2^2+q_3^2}}} \\\\
q_2={\dfrac {\widehat q_2}{\sqrt {q_0^2+q_1^2+q_2^2+q_3^2}}} \\\\
q_3={\dfrac {\widehat q_3}{\sqrt {q_0^2+q_1^2+q_2^2+q_3^2}}}
\end{cases}$$
<p>  代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">norm = <span class="built_in">sqrt</span>(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);</span><br><span class="line">q0 = q0 / norm;</span><br><span class="line">q1 = q1 / norm;</span><br><span class="line">q2 = q2 / norm;</span><br><span class="line">q3 = q3 / norm;</span><br></pre></td></tr></table></figure>
<p>(9)得到新四元数后，即完成了一次四元数法姿态融合的运算，将新的四元数作为下一次四元数运算的初始四元数，再从步骤(1)开始下一次的四元数运算。为了直观表示飞行器的姿态，可将新四元数转化成为三个欧拉角：</p>
$$\begin{cases}
\phi=arcsin[2(-q_0 q_1+q_2 q_3)] \\\\
\theta=-arctan({\dfrac{2(q_0 q_2+q_1 q_3)}{q_0^2-q_1^2-q_2^2+q_3^2}}) \\\\
\psi=arctan({\dfrac{2(q_1 q_2+q_0 q_3)}{q_0^2-q_1^2+q_2^2-q_3^2}})
\end{cases}$$
<p>  这里提供了两种代码进行参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pitch = <span class="built_in">asin</span>(<span class="number">2</span> * (q0 * q2 - q1 * q3)) * <span class="number">57.2957795f</span>;</span><br><span class="line"><span class="comment">//pitch += (float)OFFSET_PITCH;</span></span><br><span class="line">roll = <span class="built_in">asin</span>(<span class="number">2</span> * (q0 * q1 + q2 * q3)) * <span class="number">57.2957795f</span>;</span><br><span class="line"><span class="comment">//roll += (float)OFFSET_ROLL;</span></span><br><span class="line"></span><br><span class="line">angle-&gt;pit = <span class="built_in">asin</span>( <span class="number">-2</span> * q1 * q3 + <span class="number">2</span> * q0 * q2) * <span class="number">57.3</span>;</span><br><span class="line">angle-&gt;rol = -<span class="built_in">atan2</span>(<span class="number">2</span> * q2 * q3 + <span class="number">2</span> * q0 * q1, <span class="number">-2</span> * q1 * q1 - <span class="number">2</span> * q2 * q2 + <span class="number">1</span>) * <span class="number">57.3</span>;</span><br><span class="line">angle-&gt;yaw = <span class="built_in">atan2</span>( <span class="number">2</span> * (q0 * q3 + q1 * q2), <span class="number">1</span> - <span class="number">2</span> * q2 * q2 - <span class="number">2</span> * q3 * q3) * <span class="number">57.3</span>;</span><br></pre></td></tr></table></figure>
<h5 id="3-10-2-总体代码"><a class="header-anchor" href="#3-10-2-总体代码">¶</a>3.10.2 总体代码</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**********/</span></span><br><span class="line"><span class="comment">/***** Madgwick 的 IMUupdate 算法 *****/</span></span><br><span class="line"><span class="comment">/***** 数据融合 &amp;&amp; 姿态解算 *****/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Kp 1.6f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ki 0.001f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> halfT 0.001f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> q0 = <span class="number">1</span>, q1 = <span class="number">0</span>, q2 = <span class="number">0</span>, q3 = <span class="number">0</span>;     <span class="comment">//float idata</span></span><br><span class="line"><span class="keyword">float</span> exInt = <span class="number">0</span>, eyInt = <span class="number">0</span>, ezInt = <span class="number">0</span>;    <span class="comment">//float idata</span></span><br><span class="line"><span class="keyword">float</span> pitch, roll, yaw;                   <span class="comment">//float idata</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IMUupdate</span><span class="params">(<span class="keyword">float</span> gx, <span class="keyword">float</span> gy, <span class="keyword">float</span> gz, <span class="keyword">float</span> ax, <span class="keyword">float</span> ay, <span class="keyword">float</span> az)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">/***** IMUupdate 算法中要求输入6个数据               *****/</span></span><br><span class="line">      <span class="comment">/***** gx gy gz 分别为陀螺仪测量到的3个旋转角速度分量 *****/</span></span><br><span class="line">      <span class="comment">/***** ax ay az 分别为加速度计的3个加速度分量        *****/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">float</span> norm;                         <span class="comment">//float idata</span></span><br><span class="line">      <span class="keyword">float</span> vx, vy, vz;                   <span class="comment">//float idata</span></span><br><span class="line">      <span class="keyword">float</span> ex, ey, ez;                   <span class="comment">//float idata</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 将加速度计测量到的3个向量转换为单位向量，即规范化处理 *****/</span></span><br><span class="line">      norm = <span class="built_in">sqrt</span>(ax * ax + ay * ay + az * az);</span><br><span class="line">      ax = ax / norm;</span><br><span class="line">      ay = ay / norm;</span><br><span class="line">      az = az / norm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 根据方向余弦矩阵与欧拉角的定义，将地理坐标系的重力向量转到机体坐标系 *****/</span></span><br><span class="line">      <span class="comment">/***** 即在当前的四元数机体坐标参考系上换算出来的重力单位向量 vx vy vz     *****/</span></span><br><span class="line">      vx = <span class="number">2</span> * (q1 * q3 - q0 * q2);</span><br><span class="line">      vy = <span class="number">2</span> * (q0 * q1 + q2 * q3);</span><br><span class="line">      vz = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 用向量的叉积来表示误差向量 *****/</span></span><br><span class="line">      <span class="comment">/***** 两者均位于机体坐标系上，叉积大小与与陀螺积分成正比 *****/</span></span><br><span class="line">      ex = (ay * vz - az * vy);</span><br><span class="line">      ey = (az * vx - ax * vz);</span><br><span class="line">      ez = (ax * vy - ay * vx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 用叉积误差来做PI调节 *****/</span></span><br><span class="line">      <span class="comment">/***** 最后用得到的调节量对陀螺仪进行零偏修正 *****/</span></span><br><span class="line">      exInt = exInt + ex * Ki;</span><br><span class="line">      eyInt = eyInt + ey * Ki;</span><br><span class="line">      ezInt = ezInt + ez * Ki;</span><br><span class="line"></span><br><span class="line">      gx = gx + Kp * ex + exInt;</span><br><span class="line">      gy = gy + Kp * ey + eyInt;</span><br><span class="line">      gz = gz + Kp * ez + ezInt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 用一阶龙格—库塔法对陀螺仪角速度值进行处理更新得到新的四元数值 *****/</span></span><br><span class="line">      <span class="comment">/***** 其中，halfT 取值为四元数更新数据的周期的一半 *****/</span></span><br><span class="line">      q0 = q0 + (-q1 * gx - q2 * gy - q3 * gz) * halfT;</span><br><span class="line">      q1 = q1 + (q0 * gx + q2 * gz - q3 * gy) * halfT;</span><br><span class="line">      q2 = q2 + (q0 * gy - q1 * gz + q3 * gz) * halfT;</span><br><span class="line">      q3 = q3 + (q0 * gz + q1 * gy - q2 * gx) * halfT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 对得到的四元数进行规范化处理 *****/</span></span><br><span class="line">      norm = <span class="built_in">sqrt</span>(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);</span><br><span class="line">      q0 = q0 / norm;</span><br><span class="line">      q1 = q1 / norm;</span><br><span class="line">      q2 = q2 / norm;</span><br><span class="line">      q3 = q3 / norm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/***** 将四元数转化为欧拉角，并可以对欧拉角进行一定的误差补偿 *****/</span></span><br><span class="line">      pitch = <span class="built_in">asin</span>(<span class="number">2</span> * (q0 * q2 - q1 * q3)) * <span class="number">57.2957795f</span>;</span><br><span class="line">      <span class="comment">//pitch += (float)OFFSET_PITCH;</span></span><br><span class="line">      roll = <span class="built_in">asin</span>(<span class="number">2</span> * (q0 * q1 + q2 * q3)) * <span class="number">57.2957795f</span>;</span><br><span class="line">      <span class="comment">//roll += (float)OFFSET_ROLL;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      angle-&gt;pit = asin( -2 * q1 * q3 + 2 * q0 * q2) * 57.3;</span></span><br><span class="line"><span class="comment">      angle-&gt;rol = -atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2 * q2 + 1) * 57.3;</span></span><br><span class="line"><span class="comment">      angle-&gt;yaw = atan2( 2 * (q0 * q3 + q1 * q2), 1 - 2 * q2 * q2 - 2 * q3 * q3) * 57.3;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="五、总结"><a class="header-anchor" href="#五、总结">¶</a>五、总结</h2>
<h3 id="1-全文总结"><a class="header-anchor" href="#1-全文总结">¶</a>1. 全文总结</h3>
<p>  本文以四旋翼飞行器的飞行原理与姿态解算的分析为背景，目的是深入研究四旋翼飞行器的姿态解算算法，从而理解其软件设计的基本原理，并为动手设计一款四旋翼飞行器奠定基础。本文主要进行的研究工作与成果如下：</p>
<p>1)四旋翼飞行器的飞行原理。本文对四旋翼飞行器的基本飞行原理与基本结构进行了简要的描述，对飞行器能够做出的基本飞行动作的动力学原理进行了基本的分析，给出了飞行器飞行姿态与其电机转速的关系。</p>
<p>2)四旋翼飞行器的姿态解算算法。本文基于 Madgwick 的 IMUupdate 算法，对四旋翼飞行器的姿态解算算法从其数学原理以及其算法优化上进行了深入的分析，为今后飞行器姿态解算的软件设计提供了基础。</p>
<h3 id="2-个人总结"><a class="header-anchor" href="#2-个人总结">¶</a>2. 个人总结</h3>
<p>  在本次科研选题训练过程中，我对该领域的知识进行了深入的认识与了解，加强了自身检索文献的能力，培养了自身撰写论文的能力，增强了小组合作探究的能力。总的来说，这是一次收获颇丰的体验。</p>
<hr>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<p>  看了各种各样的资料，其中有的资料中还存在一些错误，我将其一并放在这里了，如果读者有兴趣阅读，一定要注意。</p>
<h3 id="文献"><a class="header-anchor" href="#文献">¶</a>文献</h3>
<p>[1] 王瑞，丁晓青 编著 . 四旋翼飞行器设计与实现 . 北京：清华大学出版社, 2018.<br>
[2] 冯新宇，范红刚，辛亮 著 . 四旋翼无人飞行器设计 . 北京：清华大学出版社, 2017.<br>
[3] 严恭敏，翁浚 编著 . 捷联惯导算法与组合导航原理讲义 . 西北工业大学, 2016.<br>
[4] 喻金峰 . 四旋翼飞行器设计与实现[D] . 华南理工大学, 2018.<br>
[5] 赵杰 . 基于模型的多旋翼飞行器飞控系统设计与实现[D] . 电子科技大学, 2019.</p>
<h3 id="网页"><a class="header-anchor" href="#网页">¶</a>网页</h3>
<p><a href="https://blog.csdn.net/qq_35723367/article/details/79721503" target="_blank" rel="noopener">四轴飞行器基本组成及其飞行原理详解</a></p>
<p><a href="https://blog.csdn.net/sinat_29315697/article/details/81293458" target="_blank" rel="noopener">四旋翼飞行器的原理研究和建模</a></p>
<p><a href="https://baike.baidu.com/item/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/3216074?fromtitle=%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8&amp;fromid=7293393&amp;fr=aladdin" target="_blank" rel="noopener">四旋翼飞行器百度百科</a></p>
<p><a href="https://blog.csdn.net/nemol1990/article/details/18698927" target="_blank" rel="noopener">微型四旋翼飞行器的设计与制作</a></p>
<p><a href="https://blog.csdn.net/nemol1990/article/details/16924745" target="_blank" rel="noopener">四旋翼飞行器的姿态解算小知识点</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_40edfdc90102xd2t.html" target="_blank" rel="noopener">捷联惯导算法与组合导航原理讲义</a></p>
<p><a href="https://www.cnblogs.com/ilekoaiq/p/8849217.html" target="_blank" rel="noopener">Madgwick算法详细解读</a></p>
<p><a href="https://blog.csdn.net/nemol1990/article/details/39236189" target="_blank" rel="noopener">基于四元数的姿态解算算法图解</a></p>
<p><a href="http://www.360doc.com/content/19/0502/23/32196507_832986646.shtml" target="_blank" rel="noopener">刚体定点运动的欧拉定理（基于线性代数的证明）</a></p>
<p><a href="https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%96%B9%E7%A8%8B/19134800?fr=aladdin" target="_blank" rel="noopener">欧拉运动学方程百度百科</a></p>
<p><a href="https://baike.baidu.com/item/%E6%96%B9%E5%90%91%E4%BD%99%E5%BC%A6/638712?fr=aladdin" target="_blank" rel="noopener">方向余弦百度百科</a></p>
<p><a href="https://baike.baidu.com/item/%E5%9B%9B%E5%85%83%E6%95%B0/5795379?fr=aladdin" target="_blank" rel="noopener">四元数百度百科</a></p>
<p><a href="https://baike.baidu.com/item/%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8F/18878562?fr=aladdin" target="_blank" rel="noopener">罗德里格旋转公式百度百科</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52335076" target="_blank" rel="noopener">四元数、欧拉角及方向余弦矩阵的相互转化公式</a></p>
<p><a href="https://blog.csdn.net/qq_29831163/article/details/89703598" target="_blank" rel="noopener">常微分方程的解法 (三): 龙格—库塔（Runge—Kutta）方法 、线性多步法</a></p>
<p><a href="https://blog.csdn.net/u013007900/article/details/45922331/" target="_blank" rel="noopener">龙格-库塔(Runge-Kutta)方法数学原理及实现</a></p>
<p><a href="https://www.sohu.com/a/168421601_464087" target="_blank" rel="noopener">一阶龙格库塔法更新四元数的原理分析</a></p>
<h3 id="视频"><a class="header-anchor" href="#视频">¶</a>视频</h3>
<p>  非常感谢b站up主<a href="https://space.bilibili.com/174366293?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">Rick_Grimes</a>对于姿态解算算法的总结，本文在分析姿态解算算法时是基于对其视频的思路与内容的概括与提炼。视频中同样也有一些错误，但不影响对于总体算法的理解。</p>
<p>  视频链接：<a href="https://www.bilibili.com/video/BV1px411p71z" target="_blank" rel="noopener">【教程】四旋翼飞行器姿态解算算法入门学习-Rick Grimes</a></p>
<hr>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>飞控</tag>
        <tag>姿态解算</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：关于对CC系列知识共享许可证【CC BY-SA 4.0】 的理解及整理</title>
    <url>/2020/03/31/%E5%85%B3%E4%BA%8E%E5%AF%B9CC%E7%B3%BB%E5%88%97%E7%9F%A5%E8%AF%86%E5%85%B1%E4%BA%AB%E8%AE%B8%E5%8F%AF%E8%AF%81%E3%80%90CC%20BY-SA%204.0%E3%80%91%20%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css">
                            <div id="content_views" class="markdown_views prism-dracula">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <p><em><strong>看了CC官网的<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener">中文</a>及<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh_TW" target="_blank" rel="nofollow noopener">華語</a>译本，好多地方直译的难以理解，我结合<a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="nofollow noopener">英文原版</a>加上自己的理解做了整理。</strong></em> 不过话说回来，这个 CC License 和 MIT License 之类的开源软件许可证一样，原版按英文提供，条款太多且晦涩难懂，中文翻译可能失去了原意，所以感觉不太适合中国大陆国情。正如易软天创公司所言，“对于绝大多数的中国用户（包括开发者、最终用户、第三方开发者）来讲这些条款都比较晦涩，难以理解。虽然有中文翻译的版本，但也都比较难以理解，而且缺乏权威。”。类似的，中国开源云联盟也说，“现有许可证中的条款的表述比较晦涩，容易因理解有误而违约。”因此，在开源软件领域，他们另起炉灶起草了适合中国国情的<a href="http://zpl.pub/page/why.html" target="_blank" rel="nofollow noopener">ZPL</a>和<a href="https://license.coscl.org.cn/index.html" target="_blank" rel="nofollow noopener">MulanPSL</a>。</p>
<hr><a id="more"></a>
<p></p><div class="toc"><h3><a name="t0"></a><a name="t0"></a>文章目录</h3><ul><li><a href="#CC_BYSA_40_License_7" rel="nofollow" target="_self">CC BY-SA 4.0 License</a></li><ul><li><a href="#_11" rel="nofollow" target="_self">适用范围</a></li><li><a href="#_15" rel="nofollow" target="_self">内容摘要</a></li><ul><li><a href="#_17" rel="nofollow" target="_self">您可以自由地：</a></li><li><a href="#_25" rel="nofollow" target="_self">依据下列条款：</a></li><li><a href="#_33" rel="nofollow" target="_self">声明：</a></li></ul><li><a href="#_43" rel="nofollow" target="_self">如何使用</a></li><ul><li><a href="#_45" rel="nofollow" target="_self">在网站中使用</a></li><li><a href="#_50" rel="nofollow" target="_self">在博客中使用</a></li><li><a href="#_65" rel="nofollow" target="_self">在线下文档中使用</a></li><li><a href="#_71" rel="nofollow" target="_self">在视频中使用</a></li></ul></ul><li><a href="#CC__75" rel="nofollow" target="_self">CC 系列许可证版本说明</a></li><ul><ul><li><a href="#40_79" rel="nofollow" target="_self">4.0</a></li><li><a href="#30_93" rel="nofollow" target="_self">3.0</a></li><li><a href="#25_107" rel="nofollow" target="_self">2.5</a></li><li><a href="#20_121" rel="nofollow" target="_self">2.0</a></li><li><a href="#10_135" rel="nofollow" target="_self">1.0</a></li></ul></ul><li><a href="#_CC_BYSA_40__160" rel="nofollow" target="_self">附 CC BY-SA 4.0 许可证完整内容</a></li></ul></div><p></p>
<h1><a name="t1"></a><a name="t1"></a><a id="CC_BYSA_40_License_7"></a>CC BY-SA 4.0 License</h1>
<p>全称为 Creative Commons Attribution-ShareAlike 4.0 International Public License（知识共享 版权归属-相同方式共享 4.0 国际  公共许可证），简称为 CC BY-SA 4.0。</p>
<h2><a name="t2"></a><a name="t2"></a><a id="_11"></a>适用范围</h2>
<p>本许可证适用于自由文化作品，包括但不限于网站、图像、视频、博客、电子文档、书籍、数据集等。</p>
<h2><a name="t3"></a><a name="t3"></a><a id="_15"></a>内容摘要</h2>
<h3><a name="t4"></a><a name="t4"></a><a id="_17"></a>您可以自由地：</h3>
<p><strong>共享</strong> — 通过任何媒介和任何形式复制、转载本作品。</p>
<p><strong>改编</strong> — 在任意用途下合成、转换和改造本作品，甚至是商业性的。</p>
<p>只要您遵循许可证条款，版权方就不能收回您的这些权利。</p>
<h3><a name="t5"></a><a name="t5"></a><a id="_25"></a>依据下列条款：</h3>
<p><strong>注明版权归属</strong> — 您必须附上原始作品的来源及本许可证的链接，同时说明是否修改了原始作品。您可以用任何合理的方式来注明原始作品的版权归属，但是不得以任何方式表明版权方认可您或您的使用。</p>
<p><strong>相同方式共享</strong> — 若您改编了原始作品，则您必须使用和原始作品相同的许可证来分发您的衍生作品。</p>
<p><strong>不得附加限制</strong> — 您不得使用任何法律条款或技术措施，在法律上限制别人做许可证准许的任何事情。</p>
<h3><a name="t6"></a><a name="t6"></a><a id="_33"></a>声明：</h3>
<p>当你使用本作品中属于公众领域的要素，或当法律有例外或限制条款允许您使用时，您无需遵从本许可证。</p>
<p>不提供担保。本许可证可能不会授予能满足您使用所必须的所有许可，诸如肖像权、隐私权、人格权等可能会限制您如何使用本作品。</p>
<hr>
<p>上面这个只是“CC BY-SA 4.0”许可证的内容摘要，仅强调许可证的部分关键特点及条款，不具备法律效力，您应该仔细阅读<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" target="_blank" rel="nofollow noopener">完整的许可证</a>的所有条款及条件。</p>
<h2><a name="t7"></a><a name="t7"></a><a id="_43"></a>如何使用</h2>
<h3><a name="t8"></a><a name="t8"></a><a id="_45"></a>在网站中使用</h3>
<pre class="prettyprint"><code class="prism language-html has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">除非另有说明，否则本站内容依据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://creativecommons.org/licenses/by-sa/4.0/<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>CC BY-SA 4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>许可证进行授权，转载请附上出处链接。
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<h3><a name="t9"></a><a name="t9"></a><a id="_50"></a>在博客中使用</h3>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">版权声明：本文为&lt;author&gt;原创，依据 [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) 许可证进行授权，转载请附上出处链接及本声明。
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>比如，国内大名鼎鼎的CSDN博客使用的格式为：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;这里是博客内容&gt;
————————————————
版权声明：本文为CSDN博主「贵州穿青人」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/waplyj/article/details/90319250
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre>
<h3><a name="t10"></a><a name="t10"></a><a id="_65"></a>在线下文档中使用</h3>
<pre class="prettyprint"><code class="prism language-text has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">本内容依据“CC BY-SA 4.0”许可证进行授权。要查看该许可证，可访问https://creativecommons.org/licenses/by-sa/4.0/
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<h3><a name="t11"></a><a name="t11"></a><a id="_71"></a>在视频中使用</h3>
<p</p>
<h1><a name="t12"></a><a name="t12"></a><a id="CC__75"></a>CC 系列许可证版本说明</h1>
<p>截至目前（2019年9月18日），CC 系列许可证共有6种形式5个版本：</p>
<h3><a name="t13"></a><a name="t13"></a><a id="40_79"></a>4.0</h3>
<p>· <a href="https://creativecommons.org/licenses/by/4.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc/4.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nd/4.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-ND</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-ND</strong></a></p>
<h3><a name="t14"></a><a name="t14"></a><a id="30_93"></a>3.0</h3>
<p>· <a href="https://creativecommons.org/licenses/by/3.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-sa/3.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc/3.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nd/3.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-ND</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-ND</strong></a></p>
<h3><a name="t15"></a><a name="t15"></a><a id="25_107"></a>2.5</h3>
<p>· <a href="https://creativecommons.org/licenses/by/2.5/legalcode" target="_blank" rel="nofollow noopener"><strong>BY</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-sa/2.5/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc/2.5/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-sa/2.5/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nd/2.5/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-ND</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-nd/2.5/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-ND</strong></a></p>
<h3><a name="t16"></a><a name="t16"></a><a id="20_121"></a>2.0</h3>
<p>· <a href="https://creativecommons.org/licenses/by/2.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-sa/2.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc/2.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nd/2.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-ND</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-ND</strong></a></p>
<h3><a name="t17"></a><a name="t17"></a><a id="10_135"></a>1.0</h3>
<p>· <a href="https://creativecommons.org/licenses/by/1.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-sa/1.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc/1.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-sa/1.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-NC-SA</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nd/1.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-ND</strong></a></p>
<p>· <a href="https://creativecommons.org/licenses/by-nc-nd/1.0/legalcode" target="_blank" rel="nofollow noopener"><strong>BY-ND-NC</strong></a></p>
<p>其中的6种形式拆分说明如下：</p>
<ol>
<li>BY（Attribution，署名归属）：您可自由地分享和改编本作品，但您必须注明创作者的版权归属。</li>
<li>NC（Non Commercial，非商业性）：您可自由地分享和改编本作品，但您不得用于商业目的。</li>
<li>ND（No Derivatives，禁止改编）：你可自由地分享本作品，但您不得合成、转换和改造本作品。</li>
<li>SA（Share Alike，同样分享）：你可自由地分享和改编本作品，但您的衍生作品须以同样方式共享。</li>
</ol>
<p>在没有指定“NC”的情况下，将授权进行商业利用；在没有指定“ND”的情况下，将授权进行改编；在没有指定“SA”的情况下，将不限制进行同样方式分享。</p>
<p>CC 系列许可证版本，可参见 https://wiki.creativecommons.org/wiki/License_Versions#Licenses。</p>
<h1><a name="t18"></a><a name="t18"></a><a id="_CC_BYSA_40__160"></a>附 CC BY-SA 4.0 许可证完整内容</h1>
<p><strong>Creative Commons Attribution-ShareAlike 4.0 International Public License</strong></p>
<p>By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License (“Public License”). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.</p>
<p><strong>Section 1 – Definitions.</strong></p>
<p>​    a. <strong>Adapted Material</strong> means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.</p>
<p>​    b. <strong>Adapter's License</strong> means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.</p>
<p>​    c. <strong>BY-SA Compatible License</strong> means a license listed at <a href="http://creativecommons.org/compatiblelicenses" target="_blank" rel="nofollow noopener">creativecommons.org/compatiblelicenses</a>, approved by Creative Commons as essentially the equivalent of this Public License.</p>
<p>​    d. <strong>Copyright and Similar Rights</strong> means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section <a href="#s2b" rel="nofollow" target="_self">2(b)(1)-(2)</a> are not Copyright and Similar Rights.</p>
<p>e. <strong>Effective Technological Measures</strong> means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.</p>
<p>​    f. <strong>Exceptions and Limitations</strong> means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.</p>
<p>​    g. <strong>License Elements</strong> means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike.</p>
<p>​    h. <strong>Licensed Material</strong> means the artistic or literary work, database, or other material to which the Licensor applied this Public License.</p>
<p>​    i. <strong>Licensed Rights</strong> means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.</p>
<p>​    j. <strong>Licensor</strong> means the individual(s) or entity(ies) granting rights under this Public License.</p>
<p>​    k. <strong>Share</strong> means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.</p>
<p>​    l. <strong>Sui Generis Database Rights</strong> means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.</p>
<p>​    m. <strong>You</strong> means the individual or entity exercising the Licensed Rights under this Public License. <strong>Your</strong> has a corresponding meaning.</p>
<p><strong>Section 2 – Scope.</strong></p>
<p>​    a. <strong>License grant</strong>.</p>
<p>​        1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:</p>
<p>​             A. reproduce and Share the Licensed Material, in whole or in part; and</p>
<p>​             B. produce, reproduce, and Share Adapted Material.</p>
<p>​         2. Exceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.</p>
<p>​         3. Term. The term of this Public License is specified in Section <a href="#s6a" rel="nofollow" target="_self">6(a)</a>.</p>
<p>​         4. Media and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section <a href="#s2a4" rel="nofollow" target="_self">2(a)(4)</a> never produces Adapted Material.</p>
<p>​         5. Downstream recipients.</p>
<p>​             A. Offer from the Licensor – Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.</p>
<p>​             B. Additional offer from the Licensor – Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter's License You apply.</p>
<p>​             C. No downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.</p>
<p>​         6. No endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section <a href="#s3a1Ai" rel="nofollow" target="_self">3(a)(1)(A)(i)</a>.</p>
<p>​    b.<strong>Other rights</strong>.</p>
<p>​         1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.</p>
<p>​         2. Patent and trademark rights are not licensed under this Public License.</p>
<p>​         3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.</p>
<p><strong>Section 3 – License Conditions.</strong></p>
<p>Your exercise of the Licensed Rights is expressly made subject to the following conditions.</p>
<p>​    a. <strong>Attribution</strong>.</p>
<p>​     1.If You Share the Licensed Material (including in modified form), You must:</p>
<p>​         A.retain the following if it is supplied by the Licensor with the Licensed Material:</p>
<p>​             i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);</p>
<p>​             ii. a copyright notice;</p>
<p>​             iii. a notice that refers to this Public License;</p>
<p>​             iv. a notice that refers to the disclaimer of warranties;</p>
<p>​             v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable;</p>
<p>​         B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and</p>
<p>​         C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.</p>
<p>​     2. You may satisfy the conditions in Section <a href="#s3a1" rel="nofollow" target="_self">3(a)(1)</a> in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.</p>
<p>​     3. If requested by the Licensor, You must remove any of the information required by Section <a href="#s3a1A" rel="nofollow" target="_self">3(a)(1)(A)</a> to the extent reasonably practicable.</p>
<p>​    b. <strong>ShareAlike</strong>.</p>
<p>​     In addition to the conditions in Section <a href="#s3a" rel="nofollow" target="_self">3(a)</a>, if You Share Adapted Material You produce, the following conditions also apply.</p>
<p>​         1. The Adapter's License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License.</p>
<p>​         2. You must include the text of, or the URI or hyperlink to, the Adapter's License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material.</p>
<p>​         3. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter's License You apply.</p>
<p><strong>Section 4 – Sui Generis Database Rights.</strong></p>
<p>Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:</p>
<p>​    a. for the avoidance of doubt, Section <a href="#s2a1" rel="nofollow" target="_self">2(a)(1)</a> grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;</p>
<p>​    b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section <a href="#s3b" rel="nofollow" target="_self">3(b)</a>; and</p>
<p>​    c. You must comply with the conditions in Section <a href="#s3a" rel="nofollow" target="_self">3(a)</a> if You Share all or a substantial portion of the contents of the database.</p>
<p>For the avoidance of doubt, this Section <a href="#s4" rel="nofollow" target="_self">4</a> supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.</p>
<p><strong>Section 5 – Disclaimer of Warranties and Limitation of Liability.</strong></p>
<p>​    a. <strong>Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.</strong></p>
<p>​    b. <strong>To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.</strong></p>
<p>​    c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.</p>
<p><strong>Section 6 – Term and Termination.</strong></p>
<p>​    a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.</p>
<p>​    b. Where Your right to use the Licensed Material has terminated under Section <a href="#s6a" rel="nofollow" target="_self">6(a)</a>, it reinstates:</p>
<p>​     1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or</p>
<p>​     2. upon express reinstatement by the Licensor.</p>
<p>​     For the avoidance of doubt, this Section <a href="#s6b" rel="nofollow" target="_self">6(b)</a> does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.</p>
<p>​    c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.</p>
<p>​    d. Sections <a href="#s1" rel="nofollow" target="_self">1</a>, <a href="#s5" rel="nofollow" target="_self">5</a>, <a href="#s6" rel="nofollow" target="_self">6</a>, <a href="#s7" rel="nofollow" target="_self">7</a>, and <a href="#s8" rel="nofollow" target="_self">8</a> survive termination of this Public License.</p>
<p><strong>Section 7 – Other Terms and Conditions.</strong></p>
<p>​    a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.</p>
<p>​    b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.</p>
<p><strong>Section 8 – Interpretation.</strong></p>
<p>​    a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.</p>
<p>​    b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.</p>
<p>​    c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.</p>
<p>​    d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.</p>
<hr>
<p>转自：<a href="https://blog.csdn.net/waplyj/article/details/100899165" target="_blank" rel="noopener">https://blog.csdn.net/waplyj/article/details/100899165</a></p>
<hr>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>CC BY-NC-SA 4.0 license</tag>
      </tags>
  </entry>
  <entry>
    <title>Convolutional Neural Networks. Part 3.</title>
    <url>/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CAndrewNg/" target="_blank" rel="noopener">Convolutional Neural Networks. Andrew Ng.</a></p>
<a id="more"></a>
<hr>
<h1>Convolutional Neural Networks. Part 3.</h1>
<p>Part 3.<br>
Object Detection. Convolutional Neural Networks.</p>
<h2 id="Object-localization"><a class="header-anchor" href="#Object-localization">¶</a>Object localization</h2>
<h2 id="Landmark-detection"><a class="header-anchor" href="#Landmark-detection">¶</a>Landmark detection</h2>
<h2 id="Object-detection"><a class="header-anchor" href="#Object-detection">¶</a>Object detection</h2>
<h2 id="Convolutional-implementation-of-sliding-windows"><a class="header-anchor" href="#Convolutional-implementation-of-sliding-windows">¶</a>Convolutional implementation of sliding windows</h2>
<h2 id="Bounding-box-predictions"><a class="header-anchor" href="#Bounding-box-predictions">¶</a>Bounding box predictions</h2>
<h2 id="Intersection-over-union"><a class="header-anchor" href="#Intersection-over-union">¶</a>Intersection over union</h2>
<h2 id="Non-max-suppression"><a class="header-anchor" href="#Non-max-suppression">¶</a>Non-max suppression</h2>
<h2 id="Anchor-boxes"><a class="header-anchor" href="#Anchor-boxes">¶</a>Anchor boxes</h2>
<h2 id="Putting-it-together-YOLO-algorithm"><a class="header-anchor" href="#Putting-it-together-YOLO-algorithm">¶</a>Putting it together: YOLO algorithm</h2>
<h2 id="Region-proposals-Optional"><a class="header-anchor" href="#Region-proposals-Optional">¶</a>Region proposals (Optional)</h2>
<h2 id="Semantic-segmentation-with-U-Net"><a class="header-anchor" href="#Semantic-segmentation-with-U-Net">¶</a>Semantic segmentation with U-Net</h2>
<h2 id="Transpose-Convolutions"><a class="header-anchor" href="#Transpose-Convolutions">¶</a>Transpose Convolutions</h2>
<h2 id="U-Net-Architecture-intuition"><a class="header-anchor" href="#U-Net-Architecture-intuition">¶</a>U-Net Architecture intuition</h2>
<h2 id="U-Net-Architecture"><a class="header-anchor" href="#U-Net-Architecture">¶</a>U-Net Architecture</h2>
<hr>
<h2 id="Papers"><a class="header-anchor" href="#Papers">¶</a>Papers</h2>
<p>[Sermanet et al., 2014, OverFeat: Integrated recognition, localization and detection using convolutional networks]<br>
[Redmon et al., 2015, You Only Look Once: Unified real-time object detection]<br>
[Girshik et al., 2013, Rich feature hierarchies for accurate object detection and semantic segmentation]<br>
[Girshik, 2015. Fast R-CNN]<br>
[Ren et al., 2016. Faster R-CNN: Towards real-time object detection with region proposal networks]<br>
[Novikov et al., 2017, Fully Convolutional Architectures for Multi-Class Segmentation in Chest Radiograghs]<br>
[Dong et al., 2017, Automatic Brain Tumor Detection and Segmentation Using U-Net Based Fully Convolutional Networks]<br>
[Ronneberger et al., 2015, U-Net: Convolutional Networks for Biomedical Image Segmentation]</p>
<h2 id="传送门"><a class="header-anchor" href="#传送门">¶</a>传送门</h2>
<p><a href="https://www.bilibili.com/video/BV1e54y1b7uk?p=1" target="_blank" rel="noopener">(强推)2021吴恩达深度学习-卷积神经网络</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CNN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Convolutional Neural Networks. Part 1.</title>
    <url>/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CAndrewNg/" target="_blank" rel="noopener">Convolutional Neural Networks. Andrew Ng.</a></p>
<a id="more"></a>
<hr>
<h1>Convolutional Neural Networks. Part 1.</h1>
<p>Part 1.<br>
Convolutional Neural Networks. Yann LeCun interview.</p>
<h2 id="Computer-vision"><a class="header-anchor" href="#Computer-vision">¶</a>Computer vision</h2>
<h3 id="Deep-Learning-for-computer-vision"><a class="header-anchor" href="#Deep-Learning-for-computer-vision">¶</a>Deep Learning for computer vision</h3>
<ul>
<li>self-driving car</li>
<li>face recognition</li>
<li>show the most attractive or the most relevant pictures</li>
<li>enable new types of art to be created</li>
</ul>
<h3 id="Computer-Vision-Problems"><a class="header-anchor" href="#Computer-Vision-Problems">¶</a>Computer Vision Problems</h3>
<ul>
<li>Image Classification</li>
<li>Object detection</li>
<li>Neural Style Transfer</li>
</ul>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/002.png"/></div><br>
<h3 id="Deep-Learning-on-large-images"><a class="header-anchor" href="#Deep-Learning-on-large-images">¶</a>Deep Learning on large images</h3>
<p>standard or fully connected network : billions of parameters (<strong>very large</strong>)</p>
<ul>
<li>it is difficult to get enough data to prevent a neural network from <strong>overfitting</strong></li>
<li>the computational requirements and the momory requirements to train a neural network with billions of parameters is just a bit infeasible</li>
</ul>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/003.png"/></div><br>
<p>For computer vision applications, you don’t want to be stuck using only tiny little images, you want to use large images. To do that, you need to better implement <strong>the convolution operation</strong>, which is one of the fundamental building blocks of convolutional neural networks.</p>
<h2 id="Edge-detection-example"><a class="header-anchor" href="#Edge-detection-example">¶</a>Edge detection example</h2>
<p>see how the convolution operation works</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/004.png"/></div><br>
<p>Given a picture like that for a computer to figure out what are the objects in this picture, and the first thing you might do is maybe detect vertical edges and the horizontal edges in this image.</p>
<h3 id="Vertical-edge-detection"><a class="header-anchor" href="#Vertical-edge-detection">¶</a>Vertical edge detection</h3>
<p>How do you detect edges in image like this?</p>
<p>Here is a 6 by 6 grayscale image.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/conv_0.PNG"/></div>
<p>And this turns out to be a vertical edge detector.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/005.png"/></div><br>
<p>Why is this doing vertical edge detection?</p>
<p><strong>The lighter region right in the middle</strong> corresponds to this having detected this vertical edge down the middle of your 6 by 6 image.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/006.png"/></div><br>
<p>In this example, <strong>this bright region</strong> in the middle is just the output images way of saying that it looks like there is a strong vertical edge right down the middle of the image.</p>
<h2 id="More-edge-detection"><a class="header-anchor" href="#More-edge-detection">¶</a>More edge detection</h2>
<p>the difference between <strong>positive and negative edges</strong><br>
that is the difference between light to dark versus dark to light edge transitions</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/007.png"/></div><br>
<p>If you don’t care which of these two cases it is, you could take absolute values of this output matrix.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/008.png"/></div><br>
<ul>
<li>sobel filter:<br>
puts a little bit more weight to the central row<br>
more robust</li>
<li>scharr filter</li>
</ul>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/009.png"/></div><br>
<p>just learn them and treat the nine numbers of this matrix as parameters, then learn using <strong>back propagation</strong></p>
<p>so just letting all of these numbers be parameters and learning them automatically from data, we find that neural networks can actually learn low level features such as edges, even more robustly than computer vision researchers are generally able to code up these things by hand.</p>
<p>how to use padding as well as different strides for conv</p>
<h2 id="Padding"><a class="header-anchor" href="#Padding">¶</a>Padding</h2>
<p>In order to build deep neural networks one modification to the basic convolutional operation that you nend to really use is padding.</p>
<p>n by n image / f by f filter<br>
the dimension of the output will be (n-f+1) by (n-f+1)</p>
<p>two downsides to this:</p>
<ul>
<li>getting small</li>
<li>lost information near the edge of the image</li>
</ul>
<p>solution: <strong>pad the image</strong> using 0 before the convolution operation</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/010.png"/></div><br>
<p>then the output becomes (n+2p-f+1) by (n+2p-f+1)<br>
counting less the information from the edge of the corner or the edge of the image is reduced</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/011.png"/></div><br>
<p>in CV, f is usually <strong>odd</strong>:</p>
<ul>
<li>gives a natural padding region</li>
<li>nice to have a distinguisher (central position)</li>
</ul>
<p>recommend just use odd number filters</p>
<h2 id="Strided-convolutions"><a class="header-anchor" href="#Strided-convolutions">¶</a>Strided convolutions</h2>
<p>Strided convolutions is another piece of the basic buliding block of convolutions as used in Convolutional Neural Networks.</p>
<p>We are going to do the Conv with a stride of two.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/012_1.png"/></div><br>
<p>step over by two steps</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/013_1.png"/></div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/014_1.png"/></div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/015.png"/></div><br>
<h2 id="cross-correlation-and-convolution"><a class="header-anchor" href="#cross-correlation-and-convolution">¶</a>cross-correlation and convolution</h2>
<p>we’ve skipped the flipping operation.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/016.png"/></div><br>
<p>Just to summarize, by convention in machine learning, we usually do not bother with this skipping operation, and technically, this operation is maybe better called <strong>cross-correlation</strong> but most of the deep learning literature just calls it the convolution operator.</p>
<h2 id="Convolutions-over-volumes"><a class="header-anchor" href="#Convolutions-over-volumes">¶</a>Convolutions over volumes</h2>
<p>You’ve seen how Conv over 2D images works. Now, let’s see how you can implement Conv over three dimensional volumes.</p>
<p>Let’s start with an example.<br>
Let’s say you want to detect features not just in a gray scale image, but in a RGB image.<br>
Three here responds to the three color channels and you could think of this as a stack of three six by six images.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/017_1.png"/></div>
<p>Let’s go through in detail how this works.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/018.png"/></div><br>
<p>if you want to detect edges in the red channel of the image<br>
you could set the first filter as a vertical edge detector, and have the green / blue channel be all zeros</p>
<p>alternatively, if you don’t care what color the vertical edge is in<br>
then you might have a filter that’s like the second one</p>
<p>what if we don’t just wanted to detect vertical edges?<br>
in other words, what if you want to <strong>use multiple filters at the same time</strong>?</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/019.png"/></div><br>
<h2 id="One-layer-of-a-convolutional-network"><a class="header-anchor" href="#One-layer-of-a-convolutional-network">¶</a>One layer of a convolutional network</h2>
<p>Get now ready to see how to build one layer of a convolutional network.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/conv_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/020.png"/></div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/021.png"/></div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/022.png"/></div><br>
<p>The key point is just how one layer of how convolution neural network works.</p>
<h2 id="A-simple-convolution-network-example"><a class="header-anchor" href="#A-simple-convolution-network-example">¶</a>A simple convolution network example</h2>
<p>Now let’s go through a concrete example of a deep convolutional neural network.</p>
<p>Let’s say you have an image, and you want to do image classification, or image recognition. And you want to take an image as input X, and decide this is a cat or not, so it’s a classification problem. Let’s build an example of a ConvNet you could use for this task.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/023.png"/></div><br>
<p>A lot of the work in designing convolutional neural net is selecting hyperparameters like these, deciding what’s the total size? What’s the stride? What’s the padding and how many filters are used?</p>
<h3 id="Types-of-layer-in-a-convolutional-network"><a class="header-anchor" href="#Types-of-layer-in-a-convolutional-network">¶</a>Types of layer in a convolutional network</h3>
<ul>
<li>Convolution ( <strong>CONV</strong> )</li>
<li>Pooling ( <strong>POOL</strong> )</li>
<li>Fully connected ( <strong>FC</strong> )</li>
</ul>
<p>Fortunately pooling layers and fully connected layers are a bit simpler than convolutional layers to define.</p>
<h2 id="Pooling-layers"><a class="header-anchor" href="#Pooling-layers">¶</a>Pooling layers</h2>
<p>Other than convolutional layers, ConvNets often also use pooling layers to reduce the size of the representation, to speed the computation, as well as make some of the features that detects a bit more robust.</p>
<p>Let’s go through an example of pooling and talk about why you might want to do this.</p>
<h3 id="Max-pooling"><a class="header-anchor" href="#Max-pooling">¶</a>Max pooling</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/024.png"/></div><br>
<p>Max Pooling : take the max over the region</p>
<p>the reason people use max pooling:</p>
<ul>
<li>the intuition behind max pooling<br>
if you think of this 4 by 4 region as some set of features, the activations in some layer of the neural network, then a large number means that it’s maybe detected a <strong>particular feature</strong>. if these features detected anywhere in this filter, then keep a high number. but if this feature is not detected, then the max of all those numbers is still itself quite small.</li>
<li>it’s been found in a lot of experiments to work well<br>
maybe this is the main reason</li>
</ul>
<p>Max pooling has a set of hyperparameters but it has no parameters to learn. Just a fixed computation.</p>
<p>an example with some different hyperparameters</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/025.png"/></div><br>
<p>The max pooling computation is done <strong>independently</strong> on each of these Nc channels.<br>
(different from the convolution operation)</p>
<h3 id="Average-pooling"><a class="header-anchor" href="#Average-pooling">¶</a>Average pooling</h3>
<p>mention briefly : average pooling</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/026.png"/></div><br>
<p>As a matter of fact, max pooling used much more in the neural network than average pooling.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/027.png"/></div><br>
<p>common chosen hyperparameters:</p>
<ul>
<li>f = 2, s = 2<br>
this has the effect of shrinking the height and width of the representation by a factor of two</li>
<li>f = 3, s = 2</li>
</ul>
<p>when you do max pooling, usually, you do not use any padding. (One exception)</p>
<h2 id="Convolutional-neural-network-example"><a class="header-anchor" href="#Convolutional-neural-network-example">¶</a>Convolutional neural network example</h2>
<p>You now know pretty much all the building blocks of building a full convolutional neural network.<br>
Let’s look an example.</p>
<p>Let’s say you’re inputting an image which is 32 by 32 by 3, so it’s an RGB image and maybe you’re trying to do handwritten digit recognition. Let’s throw the neural network to do this.</p>
<p>What I’m going to use in this slide is inspired, it’s actually quite similar to one of the classic neural networks called <strong>LeNet-5</strong>, which is created by Yann LeCun many years ago.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/028.png"/></div><br>
<p>When people report the number of layers in a neural network usually people just record the number of layers that have weight, that have parameters. The pooling layer only have a few hyperparameters, so I’m going to treat that as Layer 1.</p>
<p>The fully connected layer is just like the single neural network layer.</p>
<p>how to choose these types of hyperparameters?<br>
One common guideline is to actually not try to invent your own settings of hyperparameters, but to look in the literature to see what hyperparameters you work for others. And to just choose an architecture that has worked well for someone else, and there’s a chance that will work for your application as well.</p>
<p>some more details</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/029.png"/></div><br>
<p>Notice:</p>
<ul>
<li>The max pooling layers don’t have any parameters.</li>
<li>The conv layers tend to have relatively few parameters.</li>
<li>The activation size tends to maybe go down gradually as you go deeper in the neural network. if it drops too quickly, that’s usually not great for performance as well.</li>
<li>CONV1 have 8 filters, so #parameters = (5 * 5 + 1) * 8 = 208<br>
CONV2 have 16 filters, so #parameters = (5 * 5 + 1) * 16 = 416<br>
FC3 #parameters = 400 * 120 + 1 = 48001<br>
FC4 #parameters = 120 * 84 + 1 = 10081</li>
</ul>
<p>a lot of onvolutional neural networks have properies or have patterns similar to these.</p>
<h2 id="Why-convolutions"><a class="header-anchor" href="#Why-convolutions">¶</a>Why convolutions?</h2>
<ul>
<li>why convolutions are so useful when you include them in your neural networks</li>
<li>how to put convolutions and neural networks together or say how to train a convolutional neural network when you have a label training set</li>
</ul>
<p>There are two main advantages of convolutional layers over just using fully connected layers and the advantages are parameter sharing and sparsity of connections.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/030.png"/></div><br>
<p>convolutional layers : small parameters : parameter sharing and sparsity of connections</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/031.png"/></div><br>
<p>how to train:<br>
use gradient descent or other algorithm to optimize parameters to reduce the cost function</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/032.png"/></div><br>
<h2 id="Yann-LeCun-interview"><a class="header-anchor" href="#Yann-LeCun-interview">¶</a>Yann LeCun interview</h2>
<p>Part of the interview</p>
<p>Andrew Ng : What advice do you have for someone wanting to get involved in the AI, break into AI?</p>
<p>Yann LeCun : Hhh, I mean, it’s such a different world now, than when it was when I got started. But I think what’s great now is it’s very easy for people to get involved at some level, the tools that are available are so easy to use now, in terms of whatever. You can have a run through on the cheap computer in your bedroom, and basically train your conventional net or your current net to do whatever, and there’s a lot of tools. You can learn a lot from online material about this without… it’s not very onerous. So you see high school students now playing with this right? Which is kind of great, I think and they certainly are growing interest from the student population to learn about machine learning and AI and it’s very exciting for young people and I find that wonderful I think. So my advice is, if you want to get into this, make yourself useful. So make a contribution to an open source project, for example. Or make an implementation of some standard algorithm that you can’t find the code of online, but you’d like to make it available to other people. So take a paper that you think is important, and then reimplementation the algorithm, and, then put it open source package, or contribute to one of those open source packages. And if the stuff you write is interesting and useful, you’ll get noticed. Maybe you’ll get a nice job at a company you really wanted a job at, or maybe you’ll get accepted in your favorite PhD program or things like this. So I think that’s a good way to get started.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ML_CNN/033.png"/></div><br>
<hr>
<h2 id="传送门"><a class="header-anchor" href="#传送门">¶</a>传送门</h2>
<p><a href="https://www.bilibili.com/video/BV1e54y1b7uk?p=1" target="_blank" rel="noopener">(强推)2021吴恩达深度学习-卷积神经网络</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CNN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Convolutional Neural Networks. Part 2.</title>
    <url>/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CAndrewNg/" target="_blank" rel="noopener">Convolutional Neural Networks. Andrew Ng.</a></p>
<a id="more"></a>
<hr>
<h1>Convolutional Neural Networks. Part 2.</h1>
<p>Part 2.<br>
Case Studies. Convolutional Neural Networks. Practical advice for using ConvNets.</p>
<h2 id="Why-look-at-case-studies"><a class="header-anchor" href="#Why-look-at-case-studies">¶</a>Why look at case studies?</h2>
<p>how to put together these basic building blocks to form effective conv nets<br>
One good way : to read or see other examples of effective conv nets</p>
<p>It turns out that a neural network architecture that works well on one computer vision task often works well on other tasks as well, such as maybe on your task.</p>
<p>Ontline</p>
<p>Classic networks:</p>
<ul>
<li>LeNet-5</li>
<li>AlexNet</li>
<li>VGG</li>
</ul>
<p>ResNet</p>
<p>Inception</p>
<h2 id="Classic-networks"><a class="header-anchor" href="#Classic-networks">¶</a>Classic networks</h2>
<h3 id="LeNet-5"><a class="header-anchor" href="#LeNet-5">¶</a>LeNet - 5</h3>
<h3 id="AlexNet"><a class="header-anchor" href="#AlexNet">¶</a>AlexNet</h3>
<h3 id="VGG-16"><a class="header-anchor" href="#VGG-16">¶</a>VGG - 16</h3>
<h2 id="Residual-Networks-ResNets"><a class="header-anchor" href="#Residual-Networks-ResNets">¶</a>Residual Networks (ResNets)</h2>
<p>Very, very deep neural networks are difficult to train because of vanishing and exploding gradient types of problems. You’ll learn skip connections which allows you to take the activation from one layer and suddenly feed it to another layer even much deeper in the neural network. And using that, you’ll build ResNet which enables you to train very, very deep networks.</p>
<h2 id="Why-ResNets-work"><a class="header-anchor" href="#Why-ResNets-work">¶</a>Why ResNets work</h2>
<h2 id="Network-in-Network-and-1-×-1-convolutions"><a class="header-anchor" href="#Network-in-Network-and-1-×-1-convolutions">¶</a>Network in Network and 1 × 1 convolutions</h2>
<h2 id="Inception-network-motivation"><a class="header-anchor" href="#Inception-network-motivation">¶</a>Inception network motivation</h2>
<h2 id="Inception-network"><a class="header-anchor" href="#Inception-network">¶</a>Inception network</h2>
<h2 id="MobileNet"><a class="header-anchor" href="#MobileNet">¶</a>MobileNet</h2>
<h2 id="MobileNet-Architecture"><a class="header-anchor" href="#MobileNet-Architecture">¶</a>MobileNet Architecture</h2>
<h2 id="EfficientNet"><a class="header-anchor" href="#EfficientNet">¶</a>EfficientNet</h2>
<h2 id="Using-open-source-implementations"><a class="header-anchor" href="#Using-open-source-implementations">¶</a>Using open-source implementations</h2>
<h2 id="Transfer-Learning"><a class="header-anchor" href="#Transfer-Learning">¶</a>Transfer Learning</h2>
<h2 id="Data-augmentation"><a class="header-anchor" href="#Data-augmentation">¶</a>Data augmentation</h2>
<h2 id="The-state-of-computer-vision"><a class="header-anchor" href="#The-state-of-computer-vision">¶</a>The state of computer vision</h2>
<hr>
<h2 id="Papers"><a class="header-anchor" href="#Papers">¶</a>Papers</h2>
<p>[Lecun et al., 1998. Gradient-based learning applied to document recognition]<br>
[Krizhevsky et al., 2012. ImageNet classification with deep convolutional neural networks]<br>
[Simonyan &amp; Zisserman 2015. Very deep convolutional networks for large-scale image recognition]<br>
[He et al., 2015. Deep residual networks for image recognition]<br>
[Lin et al., 2013. Network in network]<br>
[Szegedy et al., 2014. Going deeper with convolutions]<br>
[Howard et al. 2017, MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications]<br>
[Sandler et al. 2019, MobileNetV2: Inverted Residuals and Linear Bottlenecks]<br>
[Tan and Le, 2019, EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks]</p>
<h2 id="传送门"><a class="header-anchor" href="#传送门">¶</a>传送门</h2>
<p><a href="https://www.bilibili.com/video/BV1e54y1b7uk?p=1" target="_blank" rel="noopener">(强推)2021吴恩达深度学习-卷积神经网络</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CNN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Convolutional Neural Networks. Part 4.</title>
    <url>/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E8%8A%82/</url>
    <content><![CDATA[<p><a href="https://cloudplayer.top/2021/07/30/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CAndrewNg/" target="_blank" rel="noopener">Convolutional Neural Networks. Andrew Ng.</a></p>
<a id="more"></a>
<hr>
<h1>Convolutional Neural Networks. Part 4.</h1>
<p>Part 4.<br>
Face recognition. Neural Sytle Transfer. Convolutional Networks in 1D or 3D.</p>
<h2 id="What-is-face-recognition"><a class="header-anchor" href="#What-is-face-recognition">¶</a>What is face recognition</h2>
<h2 id="One-shot-learning"><a class="header-anchor" href="#One-shot-learning">¶</a>One-shot learning</h2>
<h2 id="Siamese-network"><a class="header-anchor" href="#Siamese-network">¶</a>Siamese network</h2>
<h2 id="Triplet-loss"><a class="header-anchor" href="#Triplet-loss">¶</a>Triplet loss</h2>
<h2 id="Face-verification-and-binary-classification"><a class="header-anchor" href="#Face-verification-and-binary-classification">¶</a>Face verification and binary classification</h2>
<h2 id="What-is-neural-style-transfer"><a class="header-anchor" href="#What-is-neural-style-transfer">¶</a>What is neural style transfer</h2>
<h2 id="What-are-deep-ConvNets-learning"><a class="header-anchor" href="#What-are-deep-ConvNets-learning">¶</a>What are deep ConvNets learning</h2>
<h2 id="Cost-function"><a class="header-anchor" href="#Cost-function">¶</a>Cost function</h2>
<h2 id="Content-cost-function"><a class="header-anchor" href="#Content-cost-function">¶</a>Content cost function</h2>
<h2 id="Style-cost-function"><a class="header-anchor" href="#Style-cost-function">¶</a>Style cost function</h2>
<h2 id="1D-and-3D-generalizations-of-models"><a class="header-anchor" href="#1D-and-3D-generalizations-of-models">¶</a>1D and 3D generalizations of models</h2>
<hr>
<h2 id="Papers"><a class="header-anchor" href="#Papers">¶</a>Papers</h2>
<p>[Taigman et al., 2014, DeepFace closing the gap to human level performance]<br>
[Schroff et al., 2015, FaceNet: A unified embedding for face recognition and clustering]<br>
[Zeoler and Fergus., 2013, Visualizing and understanding convolutional networks]<br>
[Gatys et al., 2015. A neural algorithm of artistic style. Images on slide generated by Justin Johnson]</p>
<h2 id="传送门"><a class="header-anchor" href="#传送门">¶</a>传送门</h2>
<p><a href="https://www.bilibili.com/video/BV1e54y1b7uk?p=1" target="_blank" rel="noopener">(强推)2021吴恩达深度学习-卷积神经网络</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>CNN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>告别gitee迎来aliyun</title>
    <url>/2022/03/27/%E5%91%8A%E5%88%ABgitee%E8%BF%8E%E6%9D%A5aliyun/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_41701290/article/details/123755118" target="_blank" rel="noopener">gitee 寄了</a>，<a href="https://blog.csdn.net/Pop_Rain/article/details/104834973" target="_blank" rel="noopener">希望交钱给阿里云能省心点叭</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>告别yilia，迎来NexT</title>
    <url>/2021/02/21/%E5%91%8A%E5%88%AByilia%E8%BF%8E%E6%9D%A5NexT/</url>
    <content><![CDATA[<p>将博客更换了主题，之前的文章仍然保留，但由于重新进行了配置，未能将之前的评论区内容也保留下来，于是将本文之前所有博文的评论区一律关闭，如果要留言，可以去之前在 GitHub 创建的 <a href="https://github.com/cloudplayer99/cloudplayer99.github.io/issues" target="_blank" rel="noopener">issues</a>。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>套接字编程，简单程序的编写</title>
    <url>/2021/09/24/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h2 id="Socket-编程"><a class="header-anchor" href="#Socket-编程">¶</a>Socket 编程</h2>
<p>2 种传输层服务的socket类型：</p>
<ul>
<li>TCP: 可靠的、字节流的服务</li>
<li>UDP: 不可靠（数据 UDP 数据报）服务<a id="more"></a></li>
</ul>
<h2 id="UDP-与-TCP"><a class="header-anchor" href="#UDP-与-TCP">¶</a>UDP 与 TCP</h2>
<p>UDP：<font color= red>在客户端和服务器之间没有连接</font></p>
<ul>
<li>没有握手</li>
<li>发送端在每一个报文中明确地指定目标的 IP 地址和端口号</li>
<li>服务器必须从收到的分组中提取出发送端的 IP 地址和端口号</li>
</ul>
<p>UDP：<font color= red>传送的数据可能乱序，也可能丢失</font></p>
<p>进程视角看 UDP 服务：<br>
UDP 为客户端和服务器提供不可靠的字节组的传送服务</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/useUDP.PNG"/></div>
<p>TCP：<font color= red>面向连接的协议，在客户和服务器能够开始互相发送数据之前，它们先要握手和创建一个 TCP 连接</font></p>
<p><font color= red>服务器首先运行，等待连接建立</font></p>
<p>1：服务器进程必须先处于运行状态</p>
<ul>
<li><font color= red>创建</font>欢迎 socket</li>
<li>和本地端口<font color= red>捆绑</font></li>
<li>在欢迎 socket 上阻塞式<font color= red>等待接收</font><br>
用户的连接</li>
</ul>
<p><font color= red>客户端主动和服务器建立连接：</font></p>
<p>2：<font color= red>创建</font>客户端本地套接字（<font color= red>隐式捆绑</font>到本地 port）</p>
<ul>
<li>指定服务器进程的IP地址和端口号，与服务器进程<font color= red>连接</font></li>
</ul>
<p>3 ：当与客户端连接请求到来时</p>
<ul>
<li>服务器<font color= red>接受</font>来自用户端的请求，解除阻塞式等待，返回一个新的 socket（与欢迎 socket 不一样），与客户端通信
<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源 IP 和源端</li>
</ul>
</li>
</ul>
<p>4：连接 API 调用有效时，客户端 P 与服务器建立了 TCP 连接</p>
<p>从应用程序的角度:<br>
TCP在客户端和服务器进程之间提供了可靠的、字节流（管道）服务</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/useTCP.PNG"/></div>
<h2 id="一个简单的客户-服务器应用程序"><a class="header-anchor" href="#一个简单的客户-服务器应用程序">¶</a>一个简单的客户-服务器应用程序</h2>
<ul>
<li>客户从其键盘读取一行字符（数据）并将该数据向服务器发送；</li>
<li>服务器接收该数据并将这些字符转换为大写；</li>
<li>服务器将修改的数据发送给客户；</li>
<li>客户接收修改的数据并在其监视器上将该行显示出来。</li>
</ul>
<h3 id="UDP-实现"><a class="header-anchor" href="#UDP-实现">¶</a>UDP 实现</h3>
<p>该应用程序客户端的代码：</p>
<figure class="highlight python"><figcaption><span>UDPClient.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># serverName 为包含服务器的 IP 地址，或者是包含服务器的主机名</span></span><br><span class="line"><span class="comment"># serverPort 为服务器的端口号 </span></span><br><span class="line">serverName = <span class="string">'hostname'</span>                       </span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户的套接字</span></span><br><span class="line"><span class="comment"># 第一个参数指示了地址簇，第二个参数指示了套接字类型</span></span><br><span class="line"><span class="comment"># AF_INET 指示了底层网络使用了 IPv4</span></span><br><span class="line"><span class="comment"># SOCK_DGRAM 意味着它是一个 UDP 套接字</span></span><br><span class="line"><span class="comment"># 操作系统为我们指定客户套接字的端口号（隐式）</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">message = raw_input(<span class="string">'Input lowercase sentence:'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sendto 方法为报文附上目的地址 (serverName, serverPort) 并向进程的套接字 clientSocket 发送结果分组</span></span><br><span class="line">clientSocket.sendto(message.encode(), (serverName, serverPort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户等待接收来自服务器的数据</span></span><br><span class="line"><span class="comment"># 当一个来自因特网的分组到达该客户套接字时</span></span><br><span class="line"><span class="comment"># 该分组的数据被放置到变量 modifiedMessage 中</span></span><br><span class="line"><span class="comment"># 其源地址（服务器的 IP 地址和服务器的端口号）被放置到变量 serverAddress 中（程序实际不需要）</span></span><br><span class="line"><span class="comment"># 2048 为缓存长度</span></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">print(modifiedMessage.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字，关闭该进程</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>
<p>该应用程序服务器端的代码：</p>
<figure class="highlight python"><figcaption><span>UDPServer.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务器的套接字</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码显式地为服务器套接字分配端口号 12000 </span></span><br><span class="line"><span class="comment"># 任何人向位于该服务器的 IP 地址的端口 12000 发送一个分组，该分组将导向该套接字</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"The server is ready to receive"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 到达、处理、发回</span></span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br><span class="line">    <span class="comment"># 维持 while 循环，等待另一个 UDP 分组到达</span></span><br></pre></td></tr></table></figure>
<h3 id="TCP-实现"><a class="header-anchor" href="#TCP-实现">¶</a>TCP 实现</h3>
<p>该应用程序客户端的代码：</p>
<figure class="highlight python"><figcaption><span>TCPClient.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">'hostname'</span>                       </span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建客户的套接字</span></span><br><span class="line"><span class="comment"># SOCK_STREAM 意味着它是一个 TCP 套接字</span></span><br><span class="line"><span class="comment"># 操作系统为我们指定客户套接字的端口号（隐式）</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发起客户和服务器之间的 TCP 连接</span></span><br><span class="line"><span class="comment"># 这行代码执行完后，执行三次握手，并在客户和服务器之间创建起一条 TCP 连接 </span></span><br><span class="line">clientSocket.connect((serverName, serverPort))</span><br><span class="line"></span><br><span class="line">sentence = raw_input(<span class="string">'Input lowercase sentence:'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并不像 UDP 一样显式地创建一个分组并为该分组附上目的地址</span></span><br><span class="line"><span class="comment"># 只是将 sentence 中的字节放入该 TCP 连接中去</span></span><br><span class="line">clientSocket.send(sentence.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待接收来自服务器的字节</span></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">print(<span class="string">'From Server: '</span>, modifiedSentence.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>
<p>该应用程序服务器端的代码：</p>
<figure class="highlight python"><figcaption><span>TCPServer.py</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器创建一个 TCP 套接字</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将服务器的端口号与该套接字关联起来</span></span><br><span class="line"><span class="comment"># 对 TCP 而言，serverSocket 相当于欢迎套接字</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器聆听来自客户的 TCP 连接请求，参数定义了请求连接的最大数（至少为 1）</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'The server is ready to receive'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 收到来自客户的 TCP 连接请求，为 serverSocket 调用 accept() 方法</span></span><br><span class="line">    <span class="comment"># 创建新套接字 connectionSocket，由这个特定的客户专用</span></span><br><span class="line">    <span class="comment"># 建立 TCP 连接 </span></span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    capitalizedSocket.send(capitalizedSentence.encode())</span><br><span class="line">    connectionSocket.close()</span><br><span class="line">    <span class="comment"># serverSocket 保持打开</span></span><br></pre></td></tr></table></figure>
<h2 id="更深入的了解，从-Python-到-C"><a class="header-anchor" href="#更深入的了解，从-Python-到-C">¶</a>更深入的了解，从 Python 到 C</h2>
<h3 id="一些数据结构"><a class="header-anchor" href="#一些数据结构">¶</a>一些数据结构</h3>
<h4 id="in-addr"><a class="header-anchor" href="#in-addr">¶</a>in_addr</h4>
<p>一个 IP 地址就是一个 32 位无符号整数。网络程序将 IP 地址存放在 IP 地址结构中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IP address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_addr;      <span class="comment">/* Address in network byte order (big-endian) */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="socketaddr-in"><a class="header-anchor" href="#socketaddr-in">¶</a>socketaddr_in</h4>
<p>socketaddr_in:<br>
IP 地址和 Port 捆绑关系的数据结构（标示进程的端结点）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socketaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>          sin_family;       <span class="comment">/* Protocol family (always AF_INET)  */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>          sin_port;         <span class="comment">/* Port number in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>   <span class="title">sin_addr</span>;</span>         <span class="comment">/* IP address in network byte order  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>     sin_zero[<span class="number">8</span>];      <span class="comment">/* Pad to sizeof(struct sockaddr)    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>          sa_family;        <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="keyword">char</span>              sa_data[<span class="number">14</span>];      <span class="comment">/* Address data    */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="hostend"><a class="header-anchor" href="#hostend">¶</a>hostend</h4>
<p>域名和 IP 地址的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>*             h_name;           <span class="comment">/* 主机域名 */</span></span><br><span class="line">    <span class="keyword">char</span>**            h_aliases;        <span class="comment">/* 域名别名 */</span></span><br><span class="line">    <span class="keyword">int</span>               h_addrtype;</span><br><span class="line">    <span class="keyword">int</span>               h_length;         <span class="comment">/* 地址长度 */</span></span><br><span class="line">    <span class="keyword">char</span>**            h_addr_list;      <span class="comment">/* IP 地址  */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span>   h_addr  h_addr_list[0];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为调用域名解析函数时的参数<br>
返回后，将 IP 地址拷贝到 sockaddr_in 的 IP 地址部分</p>
<h3 id="C-客户端（UDP）"><a class="header-anchor" href="#C-客户端（UDP）">¶</a>C 客户端（UDP）</h3>
<figure class="highlight c"><figcaption><span>UDPclient.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span>                                 <span class="comment">/* structure to hold an IP address */</span></span><br><span class="line">    <span class="keyword">int</span> clientSocket;                                       <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span>                                   <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);          <span class="comment">/* 创建客户端 socket，没有连接到服务器 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* determine the server's address */</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));                     <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET;                               <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    ptrh = gethostbyname(host);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Convert host name to IP address */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    gets(Sentence);                                         <span class="comment">/* Get input stream from user */</span></span><br><span class="line">    </span><br><span class="line">    addr_len = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    n = sendto(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>,</span><br><span class="line">    (struct sockaddr *) &amp;sad, addr_len);                    <span class="comment">/* Send line to server */</span> </span><br><span class="line"></span><br><span class="line">    n = recvfrom(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence),</span><br><span class="line">    (struct sockaddr *) &amp;sad, &amp;addr_len);                   <span class="comment">/* Read line from server */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FROM SERVER: %s\n”,modifiedSentence);           </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    close(clientSocket);                                    /* Close connection */</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="C-服务器（UDP）"><a class="header-anchor" href="#C-服务器（UDP）">¶</a>C 服务器（UDP）</h3>
<figure class="highlight c"><figcaption><span>UDPserver.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span>                                 <span class="comment">/* structure to hold an IP address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span></span><br><span class="line">    <span class="keyword">int</span> serverSocket;                                       <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span>                                   <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create welcoming socket at port &amp; Bind a local address */</span></span><br><span class="line">    serverSocket = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));                     <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET;                               <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY;                       <span class="comment">/* set the local IP address */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);                    <span class="comment">/* set the port number */</span></span><br><span class="line">    bind(serverSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        n = recvfrom(serverSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence), <span class="number">0</span></span><br><span class="line">        (struct sockaddr *) &amp;cad, &amp;addr_len);               <span class="comment">/* Receive messages from clients */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line"></span><br><span class="line">        n = sendto(serverSocket , capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>,</span><br><span class="line">        (struct sockaddr *) &amp;cad, &amp;addr_len);               <span class="comment">/* Write out the result to socket */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* End of while loop, loop back and wait for another client connection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-客户端（TCP）"><a class="header-anchor" href="#C-客户端（TCP）">¶</a>C 客户端（TCP）</h3>
<figure class="highlight c"><figcaption><span>TCPclient.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* client.c */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. 建立 socket </span></span><br><span class="line"><span class="comment">2. 隐式捆绑 socket</span></span><br><span class="line"><span class="comment">3. 连接 socket</span></span><br><span class="line"><span class="comment">4. 写和读</span></span><br><span class="line"><span class="comment">5. 关闭 socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span>                                 <span class="comment">/* structure to hold an IP address of server */</span></span><br><span class="line">    <span class="keyword">int</span> clientSocket;                                       <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span>                                   <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> Sentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> modifiedSentence[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    host = argv[<span class="number">1</span>]; port = atoi(argv[<span class="number">2</span>]);                   <span class="comment">/* 服务器的主机域名与端口号 */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Create client socket, connect to server */</span></span><br><span class="line">    clientSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));                     <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET;                               <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);</span><br><span class="line">    ptrh = gethostbyname(host);                             <span class="comment">/* Convert host name to IP address */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;sad.sin_addr, ptrh-&gt;h_addr, ptrh-&gt;h_length);    <span class="comment">/* 将IP地址拷贝到sad.sin_addr */</span></span><br><span class="line">    <span class="built_in">connect</span>(clientSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line"></span><br><span class="line">    gets(Sentence);                                         <span class="comment">/* Get input stream from user */</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">write</span>(clientSocket, Sentence, <span class="built_in">strlen</span>(Sentence)+<span class="number">1</span>);  <span class="comment">/* Send line to server */</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">read</span>(clientSocket, modifiedSentence, <span class="keyword">sizeof</span>(modifiedSentence));</span><br><span class="line">                                                            <span class="comment">/* Read line from server */</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"FROM SERVER: %s\n”,modifiedSentence);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    close(clientSocket);                                    /* Close connection */ </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="C-服务器（TCP）"><a class="header-anchor" href="#C-服务器（TCP）">¶</a>C 服务器（TCP）</h3>
<figure class="highlight c"><figcaption><span>TCPserver.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server.c */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 建立 socket</span></span><br><span class="line"><span class="comment">2. 绑定 socket</span></span><br><span class="line"><span class="comment">3. 等待并建立连接 socket</span></span><br><span class="line"><span class="comment">4. 读和写</span></span><br><span class="line"><span class="comment">5. 关闭 (connection)socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sad</span>;</span>                                 <span class="comment">/* structure to hold an IP address of server*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cad</span>;</span>                                 <span class="comment">/* client */</span></span><br><span class="line">    <span class="keyword">int</span> welcomeSocket, connectionSocket;                    <span class="comment">/* socket descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ptrh</span>;</span>                                   <span class="comment">/* pointer to a host table entry */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> clientSentence[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">char</span> capitalizedSentence[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Create welcoming socket at port &amp; Bind a local address */</span></span><br><span class="line">    welcomeSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span> *)&amp;sad,<span class="number">0</span>,<span class="keyword">sizeof</span>(sad));                     <span class="comment">/* clear sockaddr structure */</span></span><br><span class="line">    sad.sin_family = AF_INET;                               <span class="comment">/* set family to Internet */</span></span><br><span class="line">    sad.sin_addr.s_addr = INADDR_ANY;                       <span class="comment">/* set the local IP address */</span></span><br><span class="line">    sad.sin_port = htons((u_short)port);                    <span class="comment">/* set the port number */</span></span><br><span class="line">    bind(welcomeSocket, (struct sockaddr *)&amp;sad, <span class="keyword">sizeof</span>(sad));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Specify the maximum number of clients that can be queued */</span></span><br><span class="line">    <span class="built_in">listen</span>(welcomeSocket, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        connectionSocket = accept(welcomeSocket, (struct sockaddr *)&amp;cad, &amp;alen);</span><br><span class="line">                                                            <span class="comment">/* Wait, on welcoming socket for contact by a client */</span></span><br><span class="line">        n = <span class="built_in">read</span>(connectionSocket, clientSentence, <span class="keyword">sizeof</span>(clientSentence));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* capitalize Sentence and store the result in capitalizedSentence*/</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">write</span>(connectionSocket, capitalizedSentence, <span class="built_in">strlen</span>(capitalizedSentence)+<span class="number">1</span>);</span><br><span class="line">                                                            <span class="comment">/* Write out the result to socket */</span> </span><br><span class="line">        <span class="built_in">close</span>(connectionSocket);                            </span><br><span class="line">        <span class="comment">/* End of while loop, loop back and wait for another client connection */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串入门</title>
    <url>/2022/06/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=4" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356631" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-字符串入门</a> 但是没得密码。。。<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>字符串入门</h1>
<h2 id="基础约定与定义"><a class="header-anchor" href="#基础约定与定义">¶</a>基础约定与定义</h2>
<ul>
<li>
<p>记号 $\sum$ 表示字符集。字符串中的字符一定在字符集内。</p>
</li>
<li>
<p>$|s|$ 表示字符串 $s$ 的长度。$s[i](0 \le i &lt; |s|)$ 表示字符串 $s$ 中的第 $(i+1)$ 个字符。<br>
$s[l \dots r](0 \le l,r &lt; |s|)$ 表示由串 $s$ 中下标为 $l$ 的字符到下标为 $r$ 的字符所组成的子串。特别地，若 $l &gt; r$，则 $s[l \dots r]$ 为一空串。</p>
</li>
<li>
<p>对于两个字符串 $s$ 和 $t$，定义 $s$ 与 $t$ 相等（匹配）当且仅当 $|s| = |t|$ 且 $s[i] = t[i]$，$0 \le i &lt; |s|$。</p>
</li>
<li>
<p>记 $pre_s[i]$ 表示 $s[0 \dots i]$，称为 $s$ 的前缀 $i$；$suf_s[i]$ 表示 $s[i \dots |s|-1]$，称为 $s$ 的后缀 $i$。</p>
</li>
<li>
<p>对于两个串 $s$ 和 $t$，定义 $LCP(s,t)$ 为 $s$ 与 $t$ 的最长公共前缀的长度。</p>
</li>
</ul>
<h2 id="构造与赋值"><a class="header-anchor" href="#构造与赋值">¶</a>构造与赋值</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">()</span></span>;                <span class="comment">// s1 = ""</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;         <span class="comment">// s2 = "Hello"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>, <span class="string">'K'</span>)</span></span>;          <span class="comment">// s3 = "KKKK"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">"12345"</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;   <span class="comment">// s4 = "234", 即 "12345" 的从下标 1 开始，长度为 3 的子串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;                  </span><br><span class="line">s1 = <span class="string">"Hello"</span>;               <span class="comment">// s1 = "Hello"</span></span><br><span class="line">s2 = <span class="string">'K'</span>;                   <span class="comment">// s2 = "K"</span></span><br></pre></td></tr></table></figure>
<h2 id="String-成员函数"><a class="header-anchor" href="#String-成员函数">¶</a>String 成员函数</h2>
<p>字符串长度 length 函数</p>
<p>String 对象支持 + 和 +=，append（在后面添加内容）<br>
s1.append(s2)<br>
支持比较运算符的比较<br>
支持 compare 函数比较<br>
s1.compare(s2)<br>
支持 substr 函数求子串<br>
s2 = s1.substr(2,4)<br>
s1.empty() 判断是否为空</p>
<p>find: 从前往后查找子串或字符出现的位置。<br>
rfind: 从后往前查找子串或字符出现的位置。<br>
find_first_of: 从前往后查找何处出现另一个字符串中包含的字符。例如：<br>
s1.find_first_of(“abc”); // 查找 s1 中第一次出现 “abc” 中任一字符的位置<br>
find_last_of: 从后往前查找何处出现另一个字符串中包含的字符。<br>
find_first_not_of: 从前往后查找何处出现另一个字符串中没有包含的字符。<br>
find_last_not_of: 从后往前查找何处出现另一个字符串中没有包含的字符。</p>
<p>String 支持 insert<br>
支持 replace<br>
支持 erase<br>
支持 substr 提取出子串<br>
支持 push_back(char c)</p>
<h2 id="字符串哈希"><a class="header-anchor" href="#字符串哈希">¶</a>字符串哈希</h2>
<p>字符串哈希<br>
STRING HASH<br>
处理子串匹配的有力工具</p>
<h3 id="什么是哈希？"><a class="header-anchor" href="#什么是哈希？">¶</a>什么是哈希？</h3>
<ul>
<li>哈希又称为散列，在计算机科学中表示一个将某个对象映射到某个整数值的过程。执行此映射的函数称为哈希函数。</li>
<li>由于计算机在检索数据时仅能检索数字量，哈希的引入为检索、匹配任意对象带来了方便。</li>
<li><strong>字符串哈希</strong> 即为将一个字符串映射到某个整数的过程。字符串哈希函数在数学形式上即为某个函数 $f: S \rightarrow \mathbb{Z}$，其中 $S$ 为字符集上的全体字符串集合。</li>
</ul>
<h3 id="哈希函数的特点"><a class="header-anchor" href="#哈希函数的特点">¶</a>哈希函数的特点</h3>
<ul>
<li>哈希函数的函数值随输入的不同，其在值域内的分布是大致均匀的。</li>
<li>对输入量的微小改动也会引起哈希函数值的巨大变化。</li>
<li>对于同一个输入对象，其哈希值是唯一的。</li>
<li>不同的对象被哈希函数映射到同一个整数值（“冲突”、“碰撞”）的可能性是存在的，但其发生的概率是较小的。只有针对特定哈希算法的、经过精心挑选的字符串才会造成大概率的碰撞。</li>
<li>由第 4 个特点，<strong>若两字符串的哈希值相同，我们一般认为这两个字符串相同。</strong></li>
</ul>
<h3 id="常用字符串哈希函数"><a class="header-anchor" href="#常用字符串哈希函数">¶</a>常用字符串哈希函数</h3>
<p>在字符串匹配问题中，常用如下函数作为字符串哈希函数：</p>
<p>$$Hash(s) = \sum_{i=0}^{|s|-1} s[i] \cdot p^i，$$</p>
<p>其中 $p$ 是一个常数（通常取质数）。</p>
<div align=center><img width = '600' height ='175' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/hashtest1.PNG"/></div>
<p>定义 $Hash_s(i)$ 表示串 $s$ 的后缀 $i$ 的哈希值。则易知：</p>
<p>$$<br>
Hash_s(i) =<br>
\begin{cases}<br>
0, &amp; i=|s| \<br>
Hash_s(i+1) \cdot p + s[i], &amp; 0 \le i &lt; |s|<br>
\end{cases}<br>
$$</p>
<p>定义 $Hash_s(i, L)$ 表示串 $s[i \dots i + L-1]$ 的哈希值。则易知：</p>
<p>$$Hash_s(i,L) = Hash_s(i) - Hash_s(i+L) \cdot p^L$$</p>
<div align=center><img width = '600' height ='175' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/hashtest2.PNG"/></div>
<p>在实际应用中，常将哈希值定义为 unsigned long long 型，并在运算过程中令其自由溢出（相当于对 $2^{64} - 1$ 取模）。</p>
<ul>
<li>
<p>$<br>
Hash_s(i) =<br>
\begin{cases}<br>
0, &amp; i=|s| \<br>
Hash_s(i+1) \cdot p + s[i], &amp; 0 \le i &lt; |s|<br>
\end{cases}<br>
$</p>
</li>
<li>
<p>$Hash_s(i,L) = Hash_s(i) - Hash_s(i+L) \cdot p^L$</p>
</li>
</ul>
<p>由上面两式可以推出：</p>
<p>串 $s$ 的相邻子串（$s[i \dots j]$ 与 $s[i+1 \dots j+1]$ 为 $s$ 的一对相邻子串）的哈希函数值可以在 $O(1)$ 的时间内转移计算。</p>
<p>$$Hash_s(i,L) = Hash_s(i+1,L) \cdot p - s[i+L] \cdot p^L + s[i]$$</p>
<h3 id="如何使用字符串哈希执行字符串匹配？"><a class="header-anchor" href="#如何使用字符串哈希执行字符串匹配？">¶</a>如何使用字符串哈希执行字符串匹配？</h3>
<p>【例】给定一个模式串 $t$。给定 $q$ 组询问，每组询问给定一个待匹配串 $s$。对于每组询问，分别回答给定的待匹配串 $s$ 是否包含串 $t$ 作为子串。<br>
【方法1】暴力。<br>
时间复杂度：$O(Q|t||s|)$。<br>
【方法2】字符串哈希。<br>
首先，预处理串 $t$ 的哈希值。时间复杂度：$O(t)$。<br>
对于每个询问，针对串 $s$ 中的每个长度为 $|t|$ 的子串，计算其子串哈希值并与模式串 $t$ 的哈希值进行比较。由于相邻子串间的子串哈希值可以在 $O(1)$ 的时间复杂度内进行转移，故该步骤的时间复杂度为 $O(Q|s|)$。<br>
总体时间复杂度：$O(Q|s|+|t|)$。</p>
<p>【例】给出 N 个数，要求把其中重复的去掉，只保留第一次出现的数。<br>
例如，给出的数为 1 2 18 3 3 19 2 3 6 5 4，其中 2 和 3 有重复，去除后的结果为 1 2 18 3 19 6 5 4。<br>
对于 100% 的数据，1 &lt;= N &lt;= 50000，给出的数在 32 位无符号整数范围内。</p>
<p>【方法1】sort<br>
【方法2】平衡树（可以自己手写 or set or map）<br>
【方法3】Hash（把数字当成字符）</p>
<p>【例】小 Q 定义，若两个字符串是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如 “Penguin1” 和 “Penguin2” 是相似的，但 “Penguin1” 和 “2Penguin” 不是相似的。而小 Q 想知道，在给定的 N 个字符串中，有多少对是相似的。<br>
为了简化你的工作，小 Q 给你的 N 个字符串长度均等于 L，且只包含大小写字母、数字、而且不存在两个相同的账户名称。<br>
N &lt;= 30000, L &lt;= 200.</p>
<p>枚举删去某一位。然后算出 hash 表，求重复数字的方法可参考上一例题<br>
枚举删去某一位后，计算一个字符串 Hash 值朴素做法是 $O(L)$，这样复杂度是 $O(L(NL + N \log N))$<br>
再枚举删除一位之后，利用子串的拼接做到计算一个字符串的 hash 值要做到 $O(1)$，这样的复杂度是 $O(L(N+N \log N))$</p>
<h2 id="字典树"><a class="header-anchor" href="#字典树">¶</a>字典树</h2>
<p>字典树 TRIE 前缀树</p>
<p>字典树要解决的问题</p>
<p>给定一个字符串集合 $S$，给定 $Q$ 个询问，每个询问给定一个串 $t$。对于每个询问，要求回答给定的串 $t$ 是否为集合 $S$ 中某个字符串的前缀。</p>
<p>【方法1】暴力。<br>
时间复杂度：$O(Q|t||S|)$。</p>
<p>【方法2】字典树。<br>
时间复杂度：$O(Q|t| + \sum_{s \in S}|s|)$</p>
<p>在使用朴素暴力方法解决原问题时，我们可以发现，每次对集合 $S$ 中的一个串进行匹配时，要匹配的字符序列都是一样的：都是串 $t$ 的字符序列。我们应该想办法实现仅对串 $t$ 的字符序列匹配一次便得出答案。</p>
<p>字典树的基本思想和人类做上述匹配问题的思想很近似。考虑一个含有三个串 “aaa”、“aba” 和 “baa” 的字符串集合 $S$。当串 $t$ 为 “aaa” 时：</p>
<ul>
<li>
<p>首先尝试匹配串 $t$ 的第一个字符 $a$，注意到 $S$ 中的第三个串的第一个字符为 $b$，因此第三个串一定不匹配，匹配串只可能在第一个串和第二个串间。</p>
</li>
<li>
<p>然后尝试匹配串 $t$ 的第二个字符 $a$，注意到 $S$ 中的第二个串的第二个字符为 $b$，因此第二个串一定不匹配，第三个串在上一轮匹配中已经被我们舍弃，不予考虑。</p>
</li>
</ul>
<p>以此类推。</p>
<p>字典树巧妙的利用树结构来对上述 “选择还能够匹配的字符串” 这一过程进行优化。</p>
<p>假设 $S = { \text{ “hello”, “how”, “what”, “holy”, “hole” } }$。则对 $S$ 构造字典树如下：</p>
<div align=center><img width = '450' height ='450' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/TRIE.png"/></div>
<p>特点：</p>
<ul>
<li>
<p>根结点到树上每个节点路径上的字母构成这个节点代表的字符串（根代表空字符串）；</p>
</li>
<li>
<p>叶子对应的字符串即为集合 $S$ 内的某个字符串；</p>
</li>
<li>
<p>不难看出，字典树的空间效率非常高。这是因为字典树充分利用了集合 $S$ 中的字符串的公共前缀部分。字典树的空间复杂度为 $O(\sum_{s \in S} |s|)$</p>
</li>
</ul>
<p>字典树代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tree[maxn][<span class="number">30</span>];         <span class="comment">// 小写字母 26 个</span></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tree[root][id]) tree[root][id] = ++tot;</span><br><span class="line">        root = tree[root][id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tree[root][id]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        root = tree[root][id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于字典树上的一些符号约定</p>
<p>为了后文阐述方便，约定一些字典树上的符号含义：</p>
<ul>
<li>
<p>对于字典树上一节点 p，记 $str§$ 表示从字典树根结点到节点 $p$ 路径上的字符组成的字符串。</p>
</li>
<li>
<p>对于一字符串 $s$，若 $s$ 包含在字典树中，记 $trienode(s)$ 表示串 $s$ 在字典树上对应的节点。</p>
</li>
<li>
<p>对于一字符串 $s$，若 $trienode(s)$ 在字典树上某节点 $p$ 的子树中，称串 $s$ 穿过节点 $p$。</p>
</li>
</ul>
<p>易知，若串 $s$ 穿过节点 $p$，则 $str§$ 为 $s$ 的前缀。</p>
<p>【例】Ignatius 最近遇到一个难题，老师交给他很多单词（只有小写字母组成，不会有重复的单词出现），现在老师要他统计出以某个字符串为前缀的单词数量（单词本身也是自己的前缀）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></table></figure>
<p>PROBLEM：FIND MAX XOR SUM</p>
<p>给定 $n$ 个数 $a_1, a_2, \dots, a_n$。求 $\mathop{\max}\limits_{1 \le i, j \le n} { a_i \ \text{XOR} \ a_j }$。其中 $\text{XOR}$ 代表按位异或操作。</p>
<p>【方法1】暴力。<br>
时间复杂度：$O(n^2)$。</p>
<p>【方法2】二进制字典树。<br>
时间复杂度：$O(\log \mathop{\max}\limits_{1 \le i \le n} a_i)$</p>
<ul>
<li>不妨将给定的数拆分成二进制位进行考虑。</li>
<li>贪心性质是显然的：答案的二进制表示下高位上 $1$ 越多，答案应该越大。</li>
<li>$\text{XOR}$ 得到 $1$，当且仅当输入为一个 $0$ 和一个 $1$。</li>
<li>对给定的所有数按照其二进制表示构造一颗字典树（此时字典树为一颗二叉树）。维护两个指针，进行 <strong>双指针 DFS</strong> 。每一步都贪心地尽量选择一个指针走向 $0$，一个指针走向 $1$。</li>
<li>双指针 DFS 过程中维护答案即可。</li>
</ul>
<p>双指针 DFS 是树形字符串数据结构（字典树、自动机等）上的常用技巧。</p>
<p>PROBLEM：FIND MAX XOR SUM PLUS</p>
<p>给定 $n$ 个数 $a_1, a_2, \dots, a_n$。求 $\mathop{\max}\limits_{1 \le i, j \le n} { a_i \ \text{XOR} \ a_{i+1} \ \text{XOR} \ \dots \ \text{XOR} \ a_j }$。其中 $\text{XOR}$ 代表按位异或操作。</p>
<ul>
<li>注意到 $\mathop{\text{XOR}}\limits_{i \le k \le j} a_k = \bigg(\mathop{\text{XOR}}\limits_{1 \le k &lt; i} a_k \bigg) \text{XOR} \bigg( \mathop{\text{XOR}}\limits_{1 \le k \le j} a_k \bigg) $，即异或前缀和的性质：</li>
</ul>
<p>$$sum[l, r] = A[l] \text{ xor } A[l + 1] \dots \text{ xor } A[r] = S[r] \text{ xor } S[l - 1]$$</p>
<ul>
<li>预处理数组 ${ a_i }$ 的异或前缀和。随后问题转化为 FIND MAX XOR SUM</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集与最小生成树</title>
    <url>/2022/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=11" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/358091" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-并查集&amp;最小生成树</a> 但是没得密码。。。<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>并查集&amp;最小生成树</h1>
<h2 id="并查集"><a class="header-anchor" href="#并查集">¶</a>并查集</h2>
<h3 id="问题提出"><a class="header-anchor" href="#问题提出">¶</a>问题提出</h3>
<p>假设有 n 个强盗，其中可能有很多帮派，给出关系链（某人和某人是同伙）。然后给出多个查询，询问其中两个人是不是一个帮派</p>
<h3 id="问题解决方法"><a class="header-anchor" href="#问题解决方法">¶</a>问题解决方法</h3>
<h4 id="图染色"><a class="header-anchor" href="#图染色">¶</a>图染色</h4>
<p>将连接两个端点及其所在块涂成一个颜色。合并时复杂度较高，查询时为 $O(1)$ 。</p>
<h4 id="并查集-v2"><a class="header-anchor" href="#并查集-v2">¶</a>并查集</h4>
<p>将某个强盗作为这个团队的代表人物（头目）。在修改时，使原本两个团队的代表人物（头目）具有从属关系（a，b 两个集合合并后，若 b 原来的头目是 a 的头目的下属，那么实际上 b 合并后的最高头目还是 a 的头目，通过修改头目的从属关系合并集合）。对于查询，只需查询是否两个集合的代表元素是同一个。在修改较多时，均摊复杂度优于图染色。</p>
<h3 id="并查集-v3"><a class="header-anchor" href="#并查集-v3">¶</a>并查集</h3>
<h4 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h4>
<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。<br>
基础的并查集能实现以下三个操作：</p>
<ol>
<li>建立集合</li>
<li>查找某个元素是否在一给定集合内（或查找一个元素所在的集合）</li>
<li>合并两个集合</li>
</ol>
<p>“并”“查”“集”三字由此而来。</p>
<p>并查集能解决的问题一般可以转化成这样的形式：初始时 n 个元素分属不同的 n 个集合，通过不断的给出元素间的联系，要求 <strong>实时</strong> 的 <strong>统计元素间的关系</strong> （即是否存在直接或间接的联系）。</p>
<p>并查集本身不具有结构，可以用数组、链表以及树等实现。最常用的是 <strong>数组</strong> 实现</p>
<h4 id="实现"><a class="header-anchor" href="#实现">¶</a>实现</h4>
<p>数组实现：<br>
建立标记数组 father，用 father[i] 表示元素 i 所属集合（头目）的标记。</p>
<h5 id="1-建立集合，初始化"><a class="header-anchor" href="#1-建立集合，初始化">¶</a>1. 建立集合，初始化</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        father[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-合并集合-查找集合所属元素"><a class="header-anchor" href="#2-合并集合-查找集合所属元素">¶</a>2. 合并集合&amp;查找集合所属元素</h5>
<p>查找就是寻找头目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//非递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(father[x]!=x)</span><br><span class="line">        x=father[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)</span><br><span class="line">        <span class="keyword">return</span> find(father[x]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，比较两个元素 x,y 是否是同一集合的方法就是比较 find(x) 是否等于 find(y)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并集合的方法就是将其中一个点所在集合的根结点的父结点设定为另一个点所在集合的根结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><span class="comment">//union是关键字，不能用，函数名可以随便换一个方便的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    father[y] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化"><a class="header-anchor" href="#优化">¶</a>优化</h4>
<h5 id="路径压缩"><a class="header-anchor" href="#路径压缩">¶</a>路径压缩</h5>
<p>路径压缩就是在找完根结点之后，在递归回来的时候顺便把路径上元素的父亲结点都设为根结点</p>
<div align=center><img width = '300' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96%E5%89%8D.png"/></div>
<center>路径压缩前示意图</center><br>
<div align=center><img width = '300' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BC%98%E5%8C%96%E5%90%8E.png"/></div>
<center>路径压缩后示意图</center><br>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//递归写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)</span><br><span class="line">        father[x]=find(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//非递归写法，不太好记但是更快，列几组数据试一下也不难理解</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x,q;</span><br><span class="line">    <span class="keyword">while</span>(r!=father[r])</span><br><span class="line">        r=father[r];</span><br><span class="line">    <span class="keyword">while</span>(x!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        q=father[x];</span><br><span class="line">        father[x]=r;</span><br><span class="line">        x=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（这个优化平时都可以用，但是对于某些题会造成麻烦，例如加权并查集，这样的题需要特殊处理）</p>
<h5 id="按秩合并（启发式合并）"><a class="header-anchor" href="#按秩合并（启发式合并）">¶</a>按秩合并（启发式合并）</h5>
<p>在合并两个集合（就是两棵树）的时候，如果待合并的树的深度不相同，那么就有两种选择：</p>
<ol>
<li>一种是以深度较小的树的根结点为新的根结点</li>
<li>另一种是以深度较大的树的根结点为新的根结点</li>
</ol>
<p>而事实上，选择以深度较大的树的根节点为新的根节点较好，因为这样的话新生成的树深度会更小，可以<strong>防止树的退化</strong>（退化指越来越接近链表，即深度大而分支少），使资源利用更合理。而合并时这样选择，就叫作“<strong>按秩合并</strong>”</p>
<p>按秩合并的<strong>基本思想是将深度较小的树指到深度较大的树的根上</strong></p>
<p>按秩合并需要新开一个数组depth来记录深度，depth[x]是(&quot;以 x 为根结点的树&quot;的某个叶结点到 x 的最长路径上)边的数目的一个最大值。（即以 x 为根结点的树的树高）</p>
<p>（这个优化比较麻烦，简单题一般不用）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        depth[i] = <span class="number">0</span>; <span class="comment">// 如果初值为 0 则可以忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(depth[fx] &gt; depth[fy])</span><br><span class="line">        father[fy] = fx;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        father[fx] = fy;</span><br><span class="line">        <span class="keyword">if</span>(depth[fx] == depth[fy])</span><br><span class="line">            depth[fy]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用"><a class="header-anchor" href="#应用">¶</a>应用</h4>
<ul>
<li>kruskal</li>
</ul>
<h4 id="变种"><a class="header-anchor" href="#变种">¶</a>变种</h4>
<h5 id="加权并查集"><a class="header-anchor" href="#加权并查集">¶</a>加权并查集</h5>
<h2 id="最小生成树"><a class="header-anchor" href="#最小生成树">¶</a>最小生成树</h2>
<h3 id="Prim-算法"><a class="header-anchor" href="#Prim-算法">¶</a>Prim 算法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree_PRIM</span><span class="params">(MGraph G, VertexType u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 Prim 算法从第 u 个顶点出发构造网 G 的最小生成树 T，输出 T 的各条边</span></span><br><span class="line">    <span class="comment">// 记录从顶点集 U 到 V-U 的代价最小的边的辅助数组定义</span></span><br><span class="line">    <span class="comment">// struct &#123;</span></span><br><span class="line">    <span class="comment">//     VertexType adjvex;</span></span><br><span class="line">    <span class="comment">//     VRType lowcost;</span></span><br><span class="line">    <span class="comment">// &#125;closedge[MAX_VERTEX_NUM];</span></span><br><span class="line">    k = LocateVex(G, u);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)       <span class="comment">// 辅助数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (j! = k) closedge[j] = &#123; u, G.arcs[k][j].adj &#125;;    <span class="comment">// &#123;adjvex, lowcost&#125;</span></span><br><span class="line">    closedge[k].lowcost = <span class="number">0</span>;             <span class="comment">// 初始，U = &#123;u&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vexnum; ++i) &#123;     <span class="comment">// 选择其余 G.vexnum - 1 个顶点</span></span><br><span class="line">        k = mininum(closedge);           <span class="comment">// 求出 T 的下一个结点：第 k 顶点</span></span><br><span class="line">        <span class="comment">// 此时 closedge[k].lowcost =</span></span><br><span class="line">        <span class="comment">//              MIN&#123; closedge[Vi].lowcost | closedge[Vi].lowcost &gt; 0, Vi ∈ V-U &#125;</span></span><br><span class="line">        <span class="built_in">printf</span>(closedge[k].adjvex, G.vexs[k]);      <span class="comment">// 输出生成树的边</span></span><br><span class="line">        closedge[k].lowcost = <span class="number">0</span>;                    <span class="comment">// 第 k 顶点并入 U 集</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            <span class="keyword">if</span> (G.arcs[k][j].adj &lt; closedge[j].lowcost) <span class="comment">// 新顶点并入 U 后重新选择最小边</span></span><br><span class="line">                closedge[j] = &#123; G.vexs[k], G.arc[k][j].adj &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// MiniSpanTree</span></span><br></pre></td></tr></table></figure>
<h3 id="Prim-算法的-C-实现"><a class="header-anchor" href="#Prim-算法的-C-实现">¶</a>Prim 算法的 C++ 实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;                       <span class="comment">// 传入起点</span></span><br><span class="line">    <span class="keyword">int</span> sum_mst = <span class="number">0</span>;                    <span class="comment">// 总权值初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;        <span class="comment">// 初始化 lowcost mst 辅助数组</span></span><br><span class="line">                                        <span class="comment">// lowcost[i] 表示以 i 为终点的边的最小权值</span></span><br><span class="line">                                        <span class="comment">// mst[i] 表示对应 lowcost[i] 的起点且 mst[i] = -1 表示起点 i 加入 MST</span></span><br><span class="line">        lowcost[i] = Map[u][i];         <span class="comment">// 数组存图：Map[起点][终点] = 权值</span></span><br><span class="line">        mst[i] = u;                     <span class="comment">// 默认 mst 数组的初始值为 u</span></span><br><span class="line">    &#125;</span><br><span class="line">    mst[u] = <span class="number">-1</span>;                        <span class="comment">// 起点加入 MST(Minimum Spanning Tree)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;         <span class="comment">// 迭代 n-1 次</span></span><br><span class="line">        <span class="keyword">int</span> minn = INF;                 <span class="comment">// INF = 0x3f3f3f3f</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mst[j] != <span class="number">-1</span> &amp;&amp; lowcost[j] &lt; minn)</span><br><span class="line">                                        <span class="comment">// 不在 mst 数组中且其权值小于最小权值</span></span><br><span class="line">            &#123;</span><br><span class="line">                v = j;</span><br><span class="line">                minn = lowcost[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v != <span class="number">-1</span>)                     <span class="comment">// 能找到下一结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此处可输出路径</span></span><br><span class="line">            mst[v] = <span class="number">-1</span>;                <span class="comment">// 下一结点加入 MST</span></span><br><span class="line">            sum_mst += lowcost[v]       <span class="comment">// 更新总权值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">// 更新 lowcost mst 数组</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mst[j] != <span class="number">-1</span> &amp;&amp; lowcost[j] &gt; Map[v][j])</span><br><span class="line">                                        <span class="comment">// j 结点不在 MST 中且目前以 j 为终点的边的权值大于以 v 为起点、j 为终点的边的权值</span></span><br><span class="line">                &#123;</span><br><span class="line">                    lowcost[j] = Map[v][j];</span><br><span class="line">                    mst[j] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       <span class="comment">// 此处可输出总权值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树 Prim</span></span><br><span class="line"><span class="keyword">int</span> edges[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges[from][to] = max(edges[from][to], value);</span><br><span class="line">    edges[to][from] = max(edges[to][from], value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(edges, <span class="number">-1</span>, <span class="keyword">sizeof</span>(edges));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        dist[i] = edges[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dist[j] &gt; dist[x]) x = j;</span><br><span class="line">        ret += dist[x];</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]) dist[j] = min(dist[j], edges[x][j]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal-算法"><a class="header-anchor" href="#Kruskal-算法">¶</a>Kruskal 算法</h3>
<h3 id="Kruskal-算法的-C-实现"><a class="header-anchor" href="#Kruskal-算法的-C-实现">¶</a>Kruskal 算法的 C++ 实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树 Kruskal</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, value;</span><br><span class="line">    <span class="comment">// from 和 to 是两端点，value 是边权</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="comment">// 按边权重载小于号，用于排序</span></span><br><span class="line">        <span class="keyword">return</span> value &lt; rhs.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(Edge* edges, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// edges 是边集，m 是边集大小</span></span><br><span class="line">    sort(edges, edges + n);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">// 生成权</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (find(edges[i].from) == find(edges[i].to))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 已经在同一连通块中</span></span><br><span class="line">        ret += edges[i].value; <span class="comment">// 将边权加入生成权</span></span><br><span class="line">        merge(edges[i].from, edges[i].to); <span class="comment">// 合并连通块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序（Topological sorting）</title>
    <url>/2020/11/30/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2>
<p>对于一个有向无环图 $G = (V, E)$ 来说，其 <strong>拓扑排序</strong> 是 $G$ 中所有结点的一种线性次序<br>
该次序满足如下条件：如果图 $G$ 包括边 $(u, v)$，则结点 u 在拓扑排序中处于结点 $v$ 的前面<a id="more"></a></p>
<h2 id="基本想法"><a class="header-anchor" href="#基本想法">¶</a>基本想法</h2>
<p>本质上是一种依赖关系</p>
<p>给定一个 DAG（有向无环图），如果从 $i$ 到 $j$ 有边，则认为 $j$ 依赖于 $i$ 。如果 $i$ 到 $j$ 有路径（ $i$ 可达 $j$ ），则称 $j$ 间接依赖于 $i$</p>
<p>拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/Topo_sort.png" alt="avatar"></p>
<p>拓扑排序结果：FDCAB</p>
<p>入度最小的先遍历</p>
<p>（1）把入度为 $0$ 的顶点（无前驱）找到并打印<br>
（2）删除入度为 $0$ 顶点，及其所有出边<br>
（3）循环 (1)(2) 直至图为 NULL，即全部顶点均已输出，或是不存在入度为 $0$ 的顶点，这种情况则说明有向图中存在环</p>
<p>采用邻接表作为有向图的存储结构，且在头结点中增加一个存放顶点入度的数组（indegree）。入度为零的顶点即为没有前驱的顶点，删除顶点及以它为尾的弧的操作，则可换以弧头顶点的入度减 $1$ 来实现，为避免重复检测入度为零的顶点，可另设一栈暂存所有入度为零的顶点</p>
<p>下面是 C 语言描述的拓扑排序的 Kahn 算法<br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">TopologicalSort</span><span class="params">(ALGraph G)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有向图 G 采用邻接表存储结构</span></span><br><span class="line">    <span class="comment">// 若 G 无回路，则输出 G 的顶点的一个拓扑序列并返回 OK，否则 ERROR</span></span><br><span class="line">    FindInDegree(G, indegree);              <span class="comment">// 对各顶点求入度 indegree[0..vernum - 1]</span></span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; ++i)          <span class="comment">// 建零入度顶点栈 S</span></span><br><span class="line">        <span class="keyword">if</span> (!indegree[i])   Push(S, i);     <span class="comment">// 入度为 0 者进栈</span></span><br><span class="line">    count = <span class="number">0</span>;                              <span class="comment">// 对输出顶点计数</span></span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(S)) &#123;</span><br><span class="line">        Pop(S, i);  <span class="built_in">printf</span>(i, G.vertices[i].data);  ++count;    <span class="comment">// 输出 i 号顶点并计数</span></span><br><span class="line">        <span class="keyword">for</span> (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;</span><br><span class="line">            k = p-&gt;adjvex;                          <span class="comment">// 对 i 号顶点的每个邻接点的入度减 1</span></span><br><span class="line">            <span class="keyword">if</span> (!(--indegree[k]))   Push(S, k);     <span class="comment">// 若入度减为 0，则入栈</span></span><br><span class="line">        &#125; <span class="comment">// for</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum)   <span class="keyword">return</span> ERROR;           <span class="comment">// 该有向图有回路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// TopologicalSort</span></span><br></pre></td></tr></table></figure>
<br>
<p>对有 $n$ 个顶点和 $e$ 条弧的有向图，进行时间复杂度的分析：<br>
求各顶点入度 $O(e)$ ，建零入度顶点栈 $O(n)$ ，<br>
若无环，则每一个顶点进一次栈，出一次栈，入度减 $1$ 的操作在 while 语句中总共执行 $e$ 次<br>
所以总的时间复杂度为 $O(n + e)$</p>
<p>C++ 伪代码<br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = <span class="keyword">new</span> <span class="built_in">queue</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (in_deg[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="built_in">vector</span>();</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        u = q.pop();</span><br><span class="line">        ans.push_back(u);</span><br><span class="line">        <span class="function"><span class="keyword">for</span> each <span class="title">edge</span><span class="params">(u, v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (--in_deg[v] == <span class="number">0</span>) q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans.size() == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p>下面的例子来自《算法导论》</p>
<p>下图描述的是 Bumstead 教授每天早上起床穿衣所发生的事件的次序图，教授必须先穿某些衣服，才能再穿其他衣服，比如先穿袜子后才能再穿鞋，有些服饰则可以以任意顺序穿上，比如袜子和裤子之间可以以任意次序进行穿戴，在这个有向无环图中，有向边 $(u, v)$ 表明服装 u 必须在服装 v 之前穿上，对该图进行拓扑排序所获得的就是一种合理穿衣的次序</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/Bumstead.png" alt="avatar"></p>
<table>
<thead>
<tr>
<th style="text-align:left">有向无环图的顶点</th>
<th style="text-align:center">手表</th>
<th style="text-align:center">袜子</th>
<th style="text-align:center">内裤</th>
<th style="text-align:center">裤子</th>
<th style="text-align:center">鞋</th>
<th style="text-align:center">腰带</th>
<th style="text-align:center">衬衣</th>
<th style="text-align:center">领带</th>
<th style="text-align:center">夹克</th>
<th style="text-align:left">ans（排序结果变化）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对各顶点求入度</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">建零入度顶点栈 S<br>入度为 0 者进栈</td>
<td style="text-align:center">进栈</td>
<td style="text-align:center">进栈</td>
<td style="text-align:center">进栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">进栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">入度为0<br>进栈</td>
<td style="text-align:center">2</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带 内裤</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center">入度为0<br>进栈</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带 内裤 裤子</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">入度为0<br>进栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带 内裤 裤子 腰带</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">入度为0<br>进栈</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:left">衬衣 领带 内裤 裤子 腰带 夹克</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带 内裤 裤子 腰带 夹克 袜子</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">入度为0<br>进栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带 内裤 裤子 腰带 夹克 袜子 鞋</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">栈顶元素出栈</td>
<td style="text-align:center">出栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left">衬衣 领带 内裤 裤子 腰带 夹克 袜子 鞋 手表</td>
</tr>
<tr>
<td style="text-align:left">邻接点入度减1<br>入度为 0 者进栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><br><br></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/Kahn.png" alt="avatar"></p>
<p>通过上述的排序过程得到了 Bumstead 教授对自己每天早上的穿衣进行的拓扑排序</p>
<br>
<p>当有向图中无环时，也可利用深度优先遍历进行拓扑排序，因为图中无环，则由图中某点出发进行深度优先搜索遍历时，最先退出 DFS 函数的顶点即出度为零的顶点，是拓扑有序序列中的最后一个顶点。由此按退出 DFS 函数的先后记录下来的顶点序列即为逆向的拓扑有序序列</p>
<p>———《数据结构》</p>
<p><br>OI Wiki 中的代码<br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];  <span class="comment">// vector 实现的邻接表</span></span><br><span class="line"><span class="keyword">int</span> c[MAXN];          <span class="comment">// 标志数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topo;     <span class="comment">// 拓扑排序后的节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  c[u] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> v : G[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c[v] &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!c[v])</span><br><span class="line">      <span class="keyword">if</span> (!dfs(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  c[u] = <span class="number">1</span>;</span><br><span class="line">  topo.push_back(u);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  topo.clear();</span><br><span class="line">  <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line">    <span class="keyword">if</span> (!c[u])</span><br><span class="line">      <span class="keyword">if</span> (!dfs(u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  reverse(topo.begin(), topo.end());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>《入门经典》中的代码<br></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="keyword">int</span> topo[maxn], t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    c[u] = <span class="number">-1</span>;  <span class="comment">// 访问标志</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) <span class="keyword">if</span> (G[u][v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[v] &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 存在有向环，失败退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!c[v] &amp;&amp; !dfs(v))  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[u] = <span class="number">1</span>; topo[--t] = u;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t = n;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)  <span class="keyword">if</span> (!c[u])</span><br><span class="line">        <span class="keyword">if</span>(!dfs(u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序与最短路</title>
    <url>/2022/06/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=10" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/358075" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-拓扑排序&amp;&amp;最短路</a> Password: DijkstraduzuoDaiKeSiChua<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>拓扑排序与最短路</h1>
<h2 id="拓扑排序"><a class="header-anchor" href="#拓扑排序">¶</a>拓扑排序</h2>
<p>所谓拓扑排序，是指将一个有向无环图 $G$ 的所有顶点排成一个线性序列，使得有向无环图 $G$ 的边集 $E$ 中的任意一条边 $\left\langle u, v \right\rangle$，始终满足 $u$ 出现在 $v$ 的前面</p>
<p>从离散数学的角度来说，拓扑排序是由某个集合上的一个偏序得到该集合上的一个全序的过程，直观地看，偏序指集合中仅有部分成员可比较，而全序指集合中全体成员之间均可比较，这个全序也称为拓扑有序</p>
<div align=center><img width = '' height = '' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/%E5%81%8F%E5%BA%8F%E5%85%A8%E5%BA%8F.PNG"/></div>
<h3 id="有向无环图-DAG"><a class="header-anchor" href="#有向无环图-DAG">¶</a>有向无环图 DAG</h3>
<ul>
<li>什么是有向无环图</li>
<li>$(b)$ $©$ 皆为有向无环图，$(a)$ 不为有向无环图</li>
</ul>
<div align=center><img width = '' height = '' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/isDAG.PNG"/></div>
<h3 id="拓扑（有）序"><a class="header-anchor" href="#拓扑（有）序">¶</a>拓扑（有）序</h3>
<ul>
<li>在潜入类游戏中，一些敌人互相可以看到，需要暗杀掉所有人而不被发现，一个可行的暗杀序列，就是一个拓扑序</li>
<li>在大学选课时，有些课程存在先修课，就是说你必须上完它的前置课程，你才能够开始这门课程，一个可行的选课序列，就是一个拓扑序</li>
<li>有向无环图是存在拓扑序的充要条件</li>
</ul>
<h3 id="算法描述与实现"><a class="header-anchor" href="#算法描述与实现">¶</a>算法描述与实现</h3>
<ul>
<li>在有向无环图中找到一个没有前驱的结点（或者说是入度为 0 的结点）输出</li>
<li>然后从图中将此结点删除并且删除以该结点为尾的弧</li>
<li>如果所有结点都已输出，则程序结束；否则，返回步骤一</li>
</ul>
<p>拓扑排序的一个 C++ 实现（不是一定要用队列）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[maxn];                          <span class="comment">// 没有 vis 数组会引发什么错误</span></span><br><span class="line"><span class="keyword">int</span> deg[maxn];                          <span class="comment">// 统计点 i 的度数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;                           <span class="comment">// 把所有入度为 0 的点先扔到一个队列里</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;                <span class="comment">// 队列非空</span></span><br><span class="line">        <span class="keyword">int</span> now = q.front(); q.pop();   <span class="comment">// 取队首点 P</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> to : g[now]) &#123;        <span class="comment">// 访问 P 的所有相邻点 Q，将其入度减 1</span></span><br><span class="line">            <span class="keyword">if</span> (vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                deg[to]--;</span><br><span class="line">                <span class="keyword">if</span> (!deg[to]) &#123;</span><br><span class="line">                    vis[to] = <span class="number">1</span>;</span><br><span class="line">                    q.push(to);         <span class="comment">// 若 Q 此时入度为 0，Q 入列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                                   <span class="comment">// 出列顺序就是一个拓扑序</span></span><br><span class="line">    <span class="keyword">if</span> (num == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">// 队列空时，拓扑序列没达到顶点数，则不存在拓扑序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用"><a class="header-anchor" href="#应用">¶</a>应用</h3>
<h4 id="模板题-简单题"><a class="header-anchor" href="#模板题-简单题">¶</a>模板题 + 简单题</h4>
<p>有 $N$ 个队参加比赛（$1 \le N \le 500$），队伍编号依次为 $1$，$2$，$3$，$\dots$，$N$，一共有 $M$ 场比赛，比赛结束后，裁判委员会要将所有的参赛队伍依次排名，但现在裁判委员会只知道每场比赛的结果，比如编号为 $1$ 的队伍赢了编号为 $2$ 的队伍，在输入中用 $1\ 2$ 表示，则排名时队 $1$ 应该在队 $2$ 之前，编写程序，确定最终的排名，若不唯一，则编号小的队伍在前</p>
<p>临近春节，老板决定为每个员工发红包，为了图吉利，每个员工的红包不少于 $888$ 且为整数，一些员工可能提出自己的红包金额应该比某位员工的红包金额要大的要求，在输入中 $1\ 2$ 表示编号为 $1$ 的员工认为自己的红包要比编号为 $2$ 的员工大，员工数 $n \le 10000$，提出的要求数 $m \le 20000$，老板希望满足所有员工的要求的同时发出红包的总金额最小，编写程序计算总金额并输出，若不可能满足所有员工的要求，输出 $-1$ 即可（提示：反向建图，拓扑排序）</p>
<h4 id="最短-长路"><a class="header-anchor" href="#最短-长路">¶</a>最短/长路</h4>
<p>用拓扑排序快速求有向无环图的最短路</p>
<div align=center><img width = '240' height = '240' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E5%9B%BE%E8%AE%BA/topo%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE.png"/></div>
<p>求上图中，2 到 5 的最短路</p>
<ul>
<li>仿照 BFS，定义 dis 数组表示某个点到起点的距离</li>
<li>全部初始化为正无穷，dis[起点] = 0</li>
<li>在拓扑排序的过程中，不断执行<br>
dis[to] = min(dis[to], dis[from] + value)</li>
<li>当拓扑排序完成的时候，也就求出了最短路的长度</li>
<li>同理，可以求最长路</li>
<li>动态规划实际上是在一张有向无环图上进行拓扑排序的过程</li>
</ul>
<h4 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h4>
<p>拓扑排序经常结合其他算法一起出现<br>
比如：拓扑 + 层次遍历、拓扑 + 并查集 等等</p>
<h2 id="最短路"><a class="header-anchor" href="#最短路">¶</a>最短路</h2>
<p>单源最短路</p>
<p>BFS 的局限</p>
<p>SPFA 算法</p>
<p>堆优化的 Dijkstra</p>
<p>Dijkstra</p>
<p>Bellman-Ford</p>
<p>多源最短路</p>
<p>Floyd-Warshall</p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<ul>
<li>Dijkstra 与 Bellman-Ford ：分别被堆优化 Dijkstra 与 SPFA 干掉了，实际是不用的</li>
<li>单源最短路问题：堆优化 Dijkstra 与 SPFA
<ul>
<li>正权图：必须堆优化 Dijkstra，算法复杂度为 $O(E \log E)$</li>
<li>负权图：只能 SPFA</li>
<li>负环：没有最短路，SPFA 可以发现负环</li>
</ul>
</li>
<li>多源最短路问题：
<ul>
<li>Floyd 算法</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数电线上考试一周前</title>
    <url>/2020/06/12/%E6%95%B0%E7%94%B5%E7%BA%BF%E4%B8%8A%E8%80%83%E8%AF%95%E4%B8%80%E5%91%A8%E5%89%8D/</url>
    <content><![CDATA[<h2 id="数电不可怕，微笑面对它"><a class="header-anchor" href="#数电不可怕，微笑面对它">¶</a>数电不可怕，微笑面对它</h2>
<p>一学期一度的一周解决一门课的时间又到了<br>
这一波，这一波是线上数字电路设计</p>
<a id="more"></a>
<h2 id="只需xx元，一周学会Verilog-HDL，看到赚到-qq-就能领取Verilog大礼包"><a class="header-anchor" href="#只需xx元，一周学会Verilog-HDL，看到赚到-qq-就能领取Verilog大礼包">¶</a>只需xx元，一周学会Verilog HDL，看到赚到 +qq 就能领取Verilog大礼包</h2>
<p>线上数字电路设计 &gt;&gt; Verilog HDL 数字设计</p>
<p>什么，不会Verilog语言？咱们不是上了课吗？？上了课也不懂？那你必然没听课；</p>
<p>什么，你说老师上课疯狂改自己代码？？逮着一两个人不停提问？？坐下坐下，风格懂不懂？？个性懂不懂？？</p>
<p>什么，你说这哥们讲Verilog讲得像一坨*** ？？？</p>
<p>。。。。。。</p>
<p>u1s1，确实哦</p>
<p>那么，何不选择——只需xx元，一周学会Verilog HDL，看到赚到 +qq 就能领取Verilog大礼包[手动狗头*3]（自学就完事了好吗）</p>
<p>OK，开始 女娲补天 &amp;&amp; 查漏补缺</p>
]]></content>
      <tags>
        <tag>DIGITAL</tag>
        <tag>Verilog HDL</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法笔记</title>
    <url>/2020/11/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>Dijkstra</li>
<li>Floyd</li>
</ul>
<a id="more"></a>
<h2 id="Dijkstra"><a class="header-anchor" href="#Dijkstra">¶</a>Dijkstra</h2>
<p>讨论带权有向图</p>
<p>路径上的第一个顶点——源点（Source）<br>
最后一个顶点——终点（Destination）</p>
<p>从某个源点到其余各顶点的最短路径</p>
<p>Dijkstra 算法</p>
<p>单源最短路径算法</p>
<p>引进一个辅助向量 $D$</p>
<p>它的每个分量 $D[\ i \ ]$ 表示当前所找到的从始点 $v$ 到每个终点 $v_{i}$ 的最短路径的长度</p>
<p>初态：若从 $v$ 到 $v_{i}$ 有弧，则 $D[\ i \ ]$ 为弧上的权值，否则置 $D[\ i \ ]$ 为 $\infty$</p>
<p>从 $v$ 出发的长度最短的一条最短路径 $(v,v_{j})$ :</p>
$D[\ j \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V \}$
<p><font color='red'> 按路径长度递增的次序来产生各最短路径 </font></p>
<p>下一条长度次短的最短路径：</p>
$D[\ j \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}$
<p>步骤表达式</p>
<p>（1）$D[\ i \ ] = arcs[\  Locate Vex(G, v) \ ]\ [\ i \ ]\ \ \ \ v_{i} \in V$</p>
<p>（2）$D[\ i \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}\ \ \ \ S = S  \bigcup \{j \}$</p>
<p>（3）若$ D[\ i \ ] + arcs[\ j \ ] [\ k \ ] < D[\ k \ ]\ ,\ D[\ k \ ] = D[\ i \ ] + arcs[\ j \ ] [\ k \ ]$</p>
<p>（4）重复(2)(3)共 $n - 1$ 次</p>
<p>算法示例</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/graph.png" alt="avatar"></p>
<table>
<thead>
<tr>
<th>始点</th>
<th>终点</th>
<th>最短路径</th>
<th>路径长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>$v_0$</td>
<td>$v_1$</td>
<td>无</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$v_2$</td>
<td>$(v_0, v_2)$</td>
<td>$10$</td>
</tr>
<tr>
<td></td>
<td>$v_3$</td>
<td>$(v_0, v_2, v_3)$</td>
<td>$60$</td>
</tr>
<tr>
<td></td>
<td>$v_4$</td>
<td>$(v_0, v_4)$</td>
<td>$30$</td>
</tr>
<tr>
<td></td>
<td>$v_5$</td>
<td>$(v_0, v_4, v_3, v_5)$</td>
<td>$60$</td>
</tr>
</tbody>
</table>
<p>邻接矩阵</p>
$\begin{pmatrix}
\infty & \infty & 10 & \infty & 30 & 100 \\
\infty & \infty & 5 & \infty & \infty & \infty \\
\infty & \infty & \infty & 50 & \infty & \infty \\
\infty & \infty & \infty & \infty & \infty & 10 \\
\infty & \infty & \infty & 20 & \infty & 60 \\
\infty & \infty & \infty & \infty & \infty & \infty
\end{pmatrix}$<br><br>
<p>（1）初始化$\ \ \ \ D[\ i \ ] = arcs[\  Locate Vex(G, v) \ ]\ [\ i \ ]\ \ \ \ v_{i} \in V$<br></p>
$\ \ \ \ D[\ 0 \ ] = \infty\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ D[\ 3 \ ] = \infty\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 100$<br>
$\ \ \ \ D[\ 0 \ ] = 0 \ \ \ \ S = \{\ 0 \ \}$ 第一个点，即始点<br>
<p>（2）$D[\ i \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}\ \ \ \ S = S  \bigcup \{j \}$<br></p>
$\ \ \ \ V - S = \{\ 1, 2, 3, 4, 5 \ \}$<br>
<p>找到与 $v_0$ 最近的点：$v_2\ \ \ \ min = 10\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ S = \{\ 0,2 \ \}$<br></p>
<p>（3）若$ D[\ i \ ] + arcs[\ j \ ] [\ k \ ] < D[\ k \ ]\ ,\ D[\ k \ ] = D[\ i \ ] + arcs[\ j \ ] [\ k \ ]$<br></p>
$\ \ \ \ 10(v_0 \rightarrow v_2) + \infty(v_2 \rightarrow v_1) > \infty(v_0 \rightarrow v_1)$ ，不满足， $D[\ 1 \ ] = \infty$<br>
$\ \ \ \ 10(v_0 \rightarrow v_2) + 50(v_2 \rightarrow v_3) < \infty(v_0 \rightarrow v_3)$ ，满足， $D[\ 3 \ ] = 60$<br>
<p>后面皆不满足， $D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 100$<br></p>
<p>重复(2)(3)</p>
<p>（2’）$D[\ i \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}\ \ \ \ S = S  \bigcup \{j \}$<br></p>
$\ \ \ \ V - S = \{\ 1, 3, 4, 5 \ \}$<br>
<p>找到与 $v_0$ 最近的点：$v_4\ \ \ \ min = 30\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ S = \{\ 0,2,4 \ \}$<br></p>
<p>（3’）若$ D[\ i \ ] + arcs[\ j \ ] [\ k \ ] < D[\ k \ ]\ ,\ D[\ k \ ] = D[\ i \ ] + arcs[\ j \ ] [\ k \ ]$<br></p>
$\ \ \ \ 30(v_0 \rightarrow v_4) + \infty(v_4 \rightarrow v_1) > \infty(v_0 \rightarrow v_1)$ ，不满足， $D[\ 1 \ ] = \infty$<br>
$\ \ \ \ 30(v_0 \rightarrow v_4) + 20(v_4 \rightarrow v_3) < 60(v_0 \rightarrow v_3)$ ，满足， $D[\ 3 \ ] = 50$<br>
$\ \ \ \ 30(v_0 \rightarrow v_4) + 60(v_4 \rightarrow v_5) < 100(v_0 \rightarrow v_3)$ ，满足， $D[\ 3 \ ] = 90$<br>
<p>（2’’）$D[\ i \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}\ \ \ \ S = S  \bigcup \{j \}$<br></p>
$\ \ \ \ V - S = \{\ 1, 3, 5 \ \}$<br>
<p>找到与 $v_0$ 最近的点：$v_3\ \ \ \ min = 50\ \ \ \ D[\ 3 \ ] = 50\ \ \ \ S = \{\ 0,2,3,4 \ \}$<br></p>
<p>（3’’）若$ D[\ i \ ] + arcs[\ j \ ] [\ k \ ] < D[\ k \ ]\ ,\ D[\ k \ ] = D[\ i \ ] + arcs[\ j \ ] [\ k \ ]$<br></p>
$\ \ \ \ 50(v_0 \rightarrow v_3) + \infty(v_3 \rightarrow v_1) > \infty(v_0 \rightarrow v_1)$ ，不满足， $D[\ 1 \ ] = \infty$<br>
$\ \ \ \ 50(v_0 \rightarrow v_3) + 10(v_3 \rightarrow v_5) < 90(v_0 \rightarrow v_3)$ ，满足， $D[\ 5 \ ] = 60$<br>
<p>（2’’’）$D[\ i \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}\ \ \ \ S = S  \bigcup \{j \}$<br></p>
$\ \ \ \ V - S = \{\ 1, 5 \ \}$<br>
<p>找到与 $v_0$ 最近的点：$v_5\ \ \ \ min = 60\ \ \ \ D[\ 5 \ ] = 60\ \ \ \ S = \{\ 0,2,3,4,5 \ \}$<br></p>
<p>（3’’’）若$ D[\ i \ ] + arcs[\ j \ ] [\ k \ ] < D[\ k \ ]\ ,\ D[\ k \ ] = D[\ i \ ] + arcs[\ j \ ] [\ k \ ]$<br></p>
$\ \ \ \ 10(v_0 \rightarrow v_5) + \infty(v_5 \rightarrow v_1) > \infty(v_0 \rightarrow v_1)$ ，不满足， $D[\ 1 \ ] = \infty$<br>
<p>（2’’’’）$D[\ i \ ] = Min\{\ D[\ i \ ] \ \big| \ v_{i} \in V - S\}\ \ \ \ S = S  \bigcup \{j \}$<br></p>
$\ \ \ \ V - S = \{\ 1 \ \}$<br>
<p>找到与 $v_0$ 最近的点：$v_1\ \ \ \ min = \infty\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ S = \{\ 0,1,2,3,4,5 \ \}$<br></p>
<p>（3’’’’）pass</p>
<p>(2)(3)共执行 $n-1 = 6-1 = 5$ 次，得到最短路径的带权长度</p>
<p>要想得到每条最短路径的具体路径，需持续更新 PathMatrix 二维数组</p>
<p>下面为 C 语言描述的 Dijkstra 算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortestPath_DIJ</span><span class="params">(MGraph G, <span class="keyword">int</span> v0, PathMatrix &amp;P, ShortPathTable &amp;D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 Dijkstra 算法求有向网 G 的 v0 顶点到其余顶点 v 的最短路径 P[v] 及其带权长度 D[v]</span></span><br><span class="line">    <span class="comment">// 若 p[v][w] 为 TRUE，则 w 是从 v0 到 v 当前求得最短路径上的顶点</span></span><br><span class="line">    <span class="comment">// final[v] 为 TRUE 当且仅当 v in S，即已经求得从 v0 到 v 的最短路径（final 为 S 集）</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        <span class="keyword">final</span>[v] = FALSE; D[v] = G.arcs[v0][v];</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)  P[v][w] = FALSE;</span><br><span class="line">        <span class="keyword">if</span> (D[v] &lt; INFINITY) &#123;P[v][v0] = TRUE; P[v][v] = TRUE;&#125;</span><br><span class="line">    &#125; <span class="comment">// for</span></span><br><span class="line">    D[v0] = <span class="number">0</span>; <span class="keyword">final</span>[v0] = TRUE;        <span class="comment">// 初始化，v0 顶点入 S 集</span></span><br><span class="line">    <span class="comment">// 开始主循环，每次求得 v0 到某个 v 顶点的最短路径，并加 v 到 S 集</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; G.vexnum; ++i) &#123;     <span class="comment">// 其余 G.vexnum - 1 个顶点</span></span><br><span class="line">        min = INFINITY;                 <span class="comment">// 当前所知离 v0 顶点的最近距离</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++w)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">final</span>[w])              <span class="comment">// v0 in V-S 集</span></span><br><span class="line">                <span class="keyword">if</span> (D[w] &lt; min) &#123;v = w; min = D[w];&#125;</span><br><span class="line">                                        <span class="comment">// 找到与 v0 最近的顶点（最小 D[w]）</span></span><br><span class="line">        <span class="keyword">final</span>[v] = TRUE;                <span class="comment">// 找到后即加入 S 集</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.vexnum; ++v)  <span class="comment">// 更新 D[w], P[w]</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (min + G.arcs[v][w] &lt; D[w])) &#123;</span><br><span class="line">                D[w] = min + G.arcs[v][w];      <span class="comment">// w in V-S 集</span></span><br><span class="line">                P[w] = P[v]; P[w][w] = TRUE;    <span class="comment">// P[w] = P[v] + P[w]</span></span><br><span class="line">            &#125; <span class="comment">// if</span></span><br><span class="line">    &#125; <span class="comment">// for</span></span><br><span class="line">&#125; <span class="comment">// ShortestPath_DIJ</span></span><br></pre></td></tr></table></figure>
<p>PathMatrix P 的更新</p>
<p>邻接矩阵<br>
<br></p>
$\begin{pmatrix}
\infty & \infty & 10 & \infty & 30 & 100 \\
\infty & \infty & 5 & \infty & \infty & \infty \\
\infty & \infty & \infty & 50 & \infty & \infty \\
\infty & \infty & \infty & \infty & \infty & 10 \\
\infty & \infty & \infty & 20 & \infty & 60 \\
\infty & \infty & \infty & \infty & \infty & \infty
\end{pmatrix}$<br><br>
<p>$P[\ 6 \ ] [\ 6 \ ]$</p>
<p>初始化 P 全为 FALSE</p>
$D[\ 0 \ ] = \infty\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ D[\ 3 \ ] = \infty\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 100$<br>
$if\ \ \ \ D[\ v \ ] < INFINITY \ \ \ \ P[\ v \ ] [\ v_0 \ ] = TRUE; \ \ \ \ P[\ v \ ] [\ v \ ] = TRUE;$<br>
$\ \ \ \ P[\ 2 \ ] [\ 0 \ ] = TRUE; \ \ \ \ P[\ 2 \ ] [\ 2 \ ] = TRUE;$<br>
$\ \ \ \ P[\ 4 \ ] [\ 0 \ ] = TRUE; \ \ \ \ P[\ 4 \ ] [\ 4 \ ] = TRUE;$<br>
$\ \ \ \ P[\ 5 \ ] [\ 0 \ ] = TRUE; \ \ \ \ P[\ 5 \ ] [\ 5 \ ] = TRUE;$<br>
<p><br>$\begin{pmatrix}
 & & & & & \\
 & & & & & \\
T & & T & & & \\
 & & & & & \\
T & & & & T & \\
T & & & & & T
\end{pmatrix}$<br><br></p>
$P[\ w \ ] = P[\ v \ ]$
<p>$P[w][w] = TRUE$</p>
<p>即 $P[\ w \ ] = P[\ v \ ] + P[\ w \ ]$<br></p>
$10(v_0 \rightarrow v_2) + 50(v_2 \rightarrow v_3) < \infty(v_0 \rightarrow v_3)$ ，满足， $D[\ 3 \ ] = 60$<br>
$D[\ 0 \ ] = 0\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ D[\ 3 \ ] = 60\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 100$<br>
<p><br>$\begin{pmatrix}
 & & & & & \\
 & & & & & \\
T & & T & & & \\
T & & T & T & & \\
T & & & & T & \\
T & & & & & T
\end{pmatrix}$<br><br></p>
$30(v_0 \rightarrow v_4) + 20(v_4 \rightarrow v_3) < 60(v_0 \rightarrow v_3)$ ，满足， $D[\ 3 \ ] = 50$<br>
$30(v_0 \rightarrow v_4) + 60(v_4 \rightarrow v_5) < 100(v_0 \rightarrow v_3)$ ，满足， $D[\ 3 \ ] = 90$<br>
$D[\ 0 \ ] = 0\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ D[\ 3 \ ] = 50\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 90$<br>
<p><br>$\begin{pmatrix}
 & & & & & \\
 & & & & & \\
T & & T & & & \\
T & & & T & T & \\
T & & & & T & \\
T & & & & T & T
\end{pmatrix}$<br><br></p>
$50(v_0 \rightarrow v_3) + 10(v_3 \rightarrow v_5) < 90(v_0 \rightarrow v_3)$ ，满足， $D[\ 5 \ ] = 60$<br>
$D[\ 0 \ ] = 0\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ D[\ 3 \ ] = 50\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 60$<br>
<p><br>$\begin{pmatrix}
 & & & & & \\
 & & & & & \\
T & & T & & & \\
T & & & T & T & \\
T & & & & T & \\
T & & & T & T & T
\end{pmatrix}$<br><br></p>
<p>最终结果：</p>
$D[\ 0 \ ] = 0\ \ \ \ D[\ 1 \ ] = \infty\ \ \ \ D[\ 2 \ ] = 10\ \ \ \ D[\ 3 \ ] = 50\ \ \ \ D[\ 4 \ ] = 30\ \ \ \ D[\ 5 \ ] = 60$
<p>改进 $P$</p>
<p>无须二维数组，可以记录前驱</p>
<p>只须建立一个前驱顶点数组</p>
<p>$prev[\ i \ ]$ 的值为顶点 $v_s$ 到 $v_i$ 的最短路径所经历的全部结点中的 $v_i$ 的前驱</p>
<p>初始化时，$prev[\ i \ ] = 0 \ \ \ \ (i = 0; i < G.vexnum; i++)$</p>
<p>更新 D 数组时，更新 prev 数组，$prev[\ w \ ] = v$</p>
<table>
<thead>
<tr>
<th></th>
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>初始</td>
<td>prev[i]</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>prev[i]</td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>prev[3] = 2</td>
</tr>
<tr>
<td></td>
<td>prev[i]</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td>4</td>
<td>prev[1] = 4; prev[5] = 4</td>
</tr>
<tr>
<td></td>
<td>prev[i]</td>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td>3</td>
<td>prev[5] = 3</td>
</tr>
<tr>
<td></td>
<td>prev[i]</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>结束</td>
<td>prev[i]</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>3</td>
<td></td>
</tr>
</tbody>
</table>
<p>前驱结点初始化？？？</p>
<p>初始化：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>prev[i]</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>$\infty$</td>
</tr>
</tbody>
</table>
<p>邻接矩阵</p>
<p><br>$\begin{pmatrix}
\infty & \infty & 10 & \infty & 30 & 100 \\
\infty & \infty & 5 & \infty & \infty & \infty \\
\infty & \infty & \infty & 50 & \infty & \infty \\
\infty & \infty & \infty & \infty & \infty & 10 \\
\infty & \infty & \infty & 20 & \infty & 60 \\
\infty & \infty & \infty & \infty & \infty & \infty
\end{pmatrix}$<br><br></p>
$if(D[\ v \ ] < INFINITY)\ \ \ \ prev[\ v \ ] = 0;$
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>prev[i]</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>0</td>
<td>$\infty$</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>prev[i]</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>C++ 伪代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prev[i] == INFINITY) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> n = i;</span><br><span class="line">    <span class="keyword">while</span> (prev[n] != INFINITY) &#123;</span><br><span class="line">        path.push(n);               <span class="comment">// 入栈</span></span><br><span class="line">        n = prev[n];</span><br><span class="line">    &#125;</span><br><span class="line">    path.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!path.empty()) &#123;</span><br><span class="line">        path.pop();                 <span class="comment">// 输出路径并出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Floyd"><a class="header-anchor" href="#Floyd">¶</a>Floyd</h2>
<p>Floyd 算法（有向无向 / 边权正负）</p>
<p>多源最短路径算法</p>
<p>$O(n^3)$</p>
<p>讨论有向带权图</p>
<p>对于稠密图，效率高于执行 $|v|$ 次 Dijkstra</p>
<p>引入 $map$ 矩阵</p>
<p>$map(i, j)$ 表示节点 $i$ 至 节点 $j$ 最短路径的距离</p>
<p>对于每个节点 $k$ ，检查 $map(i, k) + map(k, j) < map(i, j)$</p>
<p>若成立，则 $map(i, j) = map(i, k) + map(k, j)$</p>
<p>主要步骤：</p>
<p>（1）初始化 $map$ 矩阵</p>
<p>若不相邻，则 $map[\ i \ ] [\ j \ ] = \infty$</p>
<p>若是相邻（即有边），则 $map[\ i \ ] [\ j \ ] = G.arcs[\ i \ ] [\ j \ ]$</p>
<p>若 $i = j$ ，$map[\ i \ ] [\ j \ ] = 0$</p>
<p>（2）分别以每个顶点为中介点，更新 $map$ 矩阵</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j] &lt; <span class="built_in">map</span>[i][j])</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习知识点总结</title>
    <url>/2021/02/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本学期机器学习课程知识点总结，持续更新中…<br>
由于是双语课所以总结尽量也保持双语…</p>
<a id="more"></a>
<h2 id="引言"><a class="header-anchor" href="#引言">¶</a>引言</h2>
<p>机器学习（Machine Learning）致力于研究如何通过计算的手段，利用经验来改善系统自身的性能。</p>
<h3 id="机器学习的定义"><a class="header-anchor" href="#机器学习的定义">¶</a>机器学习的定义</h3>
<p>“The field of study that gives computers the ability to learn without being explicitly programmed.” in 1959 by Arthur Samuel.</p>
<p>旧的定义：不显式编程地赋予计算机能力的研究领域。</p>
<p>“A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance as tasks in T, as measured by P, improves with experience E.” in 1997 by Tom Mitchell.</p>
<p>新的定义：一个程序的对某些任务 T 的表现 P 会随着相关的经验 E 的增加而变好。</p>
<h3 id="几种机器学习类型与基本术语"><a class="header-anchor" href="#几种机器学习类型与基本术语">¶</a>几种机器学习类型与基本术语</h3>
<p><strong>监督学习</strong>：可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析 regression analysis），或是预测一个分类标签（称作分类 classification）。</p>
<p><strong>无监督学习</strong>：没有给定事先标记过的训练示例，自动对输入的资料进行分类或分群，主要运用包含：聚类分析（cluster analysis）、关系规则（association rule）、维度缩减（dimensionality reduce）。</p>
<p><strong>强化学习</strong>：强调如何基于环境而行动，以取得最大化的预期利益。</p>
<p>在复习前应理解的基本术语：</p>
<p>数据集（data set）样本（sample）特征（feature）标记（label）<br>
维数（dimensionality）训练集（training set）测试集（test set）参数（parameter）<br>
假设（hypothesis）预测（prediction）簇（cluster）分布（distribution）<br>
独立同分布（i.i.d.）泛化（generalization）过拟合（overfitting）<br>
欠拟合（underfitting）错误率（error rate）精度（accuracy）…</p>
<h2 id="监督学习-Supervised-Learning"><a class="header-anchor" href="#监督学习-Supervised-Learning">¶</a>监督学习 (Supervised Learning)</h2>
<h3 id="分类与回归（Classification-and-Regression）"><a class="header-anchor" href="#分类与回归（Classification-and-Regression）">¶</a>分类与回归（Classification and Regression）</h3>
<p>Fundamentally, classification is about predicting a label and regression is about predicting a quantity.</p>
<p>分类预测的是离散值，而回归预测的是连续值。</p>
<h3 id="K-最邻近分类器（K-Nearest-Neighbors-Classifier）"><a class="header-anchor" href="#K-最邻近分类器（K-Nearest-Neighbors-Classifier）">¶</a>K 最邻近分类器（K-Nearest Neighbors Classifier）</h3>
<h4 id="核心思想"><a class="header-anchor" href="#核心思想">¶</a>核心思想</h4>
<p>The KNN algorithm assumes that similar things exist in close proximity. In other words, similar things are near to each other. It can be used to solve both classification and regression problems. However, it is more widely used in classification problems in the industry.</p>
<p>KNN 算法的核心思想是，假设相似的事物在很近的距离内存在，也就是说，相似的事物距离对方很近。KNN 算法既可以解决分类问题也可以解决回归问题，但是我们还是倾向于用它解决回归问题，这大概就是它也被称作 $K$ 最邻近分类器的原因吧。</p>
<h4 id="算法步骤"><a class="header-anchor" href="#算法步骤">¶</a>算法步骤</h4>
<p>Step 1: Calculate Similarity based on distance function<br>
Step 2 : Find K-Nearest Neighbors</p>
<p>(1) 导入一组测试数据；<br>
(2) 计算这组数据与训练集中的所有元素的距离（一般为欧氏距离）；<br>
(3) 对所有计算出的距离进行排序，选择距离测试数据最小的 $K$ 个训练集样本；<br>
(4) 对 $K$ 个样本所属的类别进行统计，将测试样本点分到在 $K$ 个训练集样本点中占比最高的那个类别去。</p>
<h4 id="关键点"><a class="header-anchor" href="#关键点">¶</a>关键点</h4>
<ul>
<li>Key component of the KNN algorithm
<ul>
<li>Distance measures</li>
<li>Value of $K$</li>
</ul>
</li>
</ul>
<p>实现 KNN 算法的关键之一是搞清楚怎样定义两个对象的距离，常用的距离函数有欧氏距离（Euclidean distance）、曼哈顿距离（Manhattan Distance）等。</p>
<ul>
<li><strong>Euclidean distance</strong></li>
</ul>
$$
\begin{array}{lcl}
d(p, q) = d(q, p)
& = & \sqrt{(q_1 - p_1)^2 + (q_2 - p_2)^2 + \cdots + (q_n - p_n)^2}\\
& = & \sqrt{\sum\limits^{n}_{i=1} (q_i - p_i)^2}.
\end{array}
$$
<ul>
<li><strong>Manhattan Distance</strong></li>
</ul>
$$ d_{12} = \sum^{n}_{k=1} \big|x_{1k} - x_{2k} \big|$$
<blockquote>
<p>实现 KNN 算法的关键之二是选择一个合适的 $k$ 值。为了这个目标，我们可以留出一部分训练数据来进行检验，不断改变 $k$ 的值，使得检验的结果最接近实际结果，选择泛化能力最强时的 $k$ 值作为算法使用的 $k$ 值，具体可见下面介绍的评估方法。</p>
</blockquote>
<ul>
<li>Selecting the value of $k$
<ul>
<li>set aside a portion of the training data(validation set)</li>
<li>vary $k$, observe training-&gt;validation error</li>
<li>pick $k$ that gives best generalization performance</li>
</ul>
</li>
</ul>
<blockquote>
<p>实践经验告诉我们，$k$ 应该要足够大，这样才能保证错误率最小，$k$ 如果太小会导致决策边界出现噪声，但是，$k$ 也应该要足够小，这样才能保证只有与测试数据真正邻近的训练集样本才会被选择到 $k$ 个邻居中来，$k$ 如果太大会导致决策边界过度平滑。</p>
</blockquote>
<ul>
<li>In practice
<ul>
<li>$K$ should be large so that error rate is minimized
<ul>
<li>$K$ too small will lead to noisy decision boundaries.</li>
</ul>
</li>
<li>$K$ should be small enough so that only nearby samples are included
<ul>
<li>$K$ too large will lead to over-smoothed boundaries</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="评估方法"><a class="header-anchor" href="#评估方法">¶</a>评估方法</h4>
<p>可以通过实验测试的评估方法来对学习器的泛化误差进行评估并进而做出选择，这里介绍 <strong>交叉检验法</strong>（cross validation）。</p>
<p>交叉检验法（又叫：$k$ 折交叉验证 $k$-fold cross validation）先将数据集 $D$ 划分为 $k$ 个大小相似的互斥子集，即 $D = D_1 \cup D_2 \cup \dots \cup D_k, D_i \cap D_j = \varnothing(i \neq j)$ ，每个子集 $D_i$ 都尽可能保持数据分布的一致性。然后每次用 $k-1$ 个子集的并集作为训练集，余下的那个子集作为测试集，最终返回 $k$ 次测试的结果的均值作为评估的依据。$k$ 的取值又在很大程度上影响着评估结果。</p>
<p>另外，如果让 $k = m$，$m$ 为数据集 $D$ 中的样本数，就得到留一法（Leave-One-Out, 简称 LOO）。</p>
<h3 id="线性模型（Linear-Models）"><a class="header-anchor" href="#线性模型（Linear-Models）">¶</a>线性模型（Linear Models）</h3>
<p>Linear Model make a prediction by using a linear function of the input features.</p>
<p>线性模型用输入特征的线性函数来做预测。</p>
<h4 id="线性回归（Linear-Regression）"><a class="header-anchor" href="#线性回归（Linear-Regression）">¶</a>线性回归（Linear Regression）</h4>
<p>For one feature the prediction is a line, for two features — plane, for more dimensions — hyperplane.</p>
<p>在线性回归中，给定若干个点 $X \in \mathbb{R}^n$，要求尽可能地拟合出一个 $n-1$ 维的超平面，即当 $X \in \mathbb{R}^2$ 时，就是在平面直角坐标系上给出很多个点，要求拟合一条直线经过这些点，这里与之后的 $n$ 都为 features 的数量。</p>
<p>The Linear function(hypothesis)</p>
$$h(x)= \theta_0 x_0 + \theta_1 x_1 + \cdots + \theta_{n-1} x_{n-1} = \sum^{n-1}_{j=0}\theta_j x_j ~~~~\text{where} ~~ x_0 = 1.$$
<p>我们的算法的任务就是要找到所有的参数 $\theta$，用矩阵表示为 $\theta = \begin{bmatrix} \theta_0 \\ \theta_1 \\ \vdots \\ \theta_j \\ \end{bmatrix} $，来构建这样一个线性模型 $h_\theta(x)$ 或者简写为 $h(x)$，使得我们能够对 input X 来较为准确地预测出 output Y。即</p>
<p>$$\text{choose } \theta \text{ such that } h(x) \text{ is close to } y \text{ for the training examples.}\tag{1}$$</p>
<br>
<p>A line, or say a hyperplane that fits the data “best” will be one for which the n prediction errors — one for each observed data point — are as small as possible in some overall sense. One way to achieve this goal is to invoke the “least squares criterion,” which says to “minimize the sum of the squared prediction errors.”</p>
<p>怎样说 $h(x)$-预测值 是足够接近 $y$-真实值 呢？这里关键在于如何衡量 $h(x)$ 与 $y$ 的差别，我们了解到，均方误差是回归任务中最常用的性能度量，均方误差有着非常好的几何意义，它其实就对应了之前在 KNN 算法中用到的 Euclidean distance（欧氏距离）。于是我们得到了基于均方误差最小化来进行模型求解的 <strong>最小二乘法</strong>（least square method），在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。</p>
<p>于是将任务(1)具体为任务(2)</p>
$$\text{choose values of}~~\theta~~\text{that minimizes }\sum^{m}_{i=1}(h_\theta(x^{(i)}) - y^{(i)})^2. \tag{2}$$
<p>这时候我们就地定义一个代价函数，只是在前边拼上一个 $\dfrac{1}{2}$，</p>
$$J(\theta) = \dfrac{1}{2}\sum^{m}_{i=1}(h_\theta(x^{(i)}) - y^{(i)})^2.$$
<p>然后有两种方法使我们能够找到一个合适的 $\theta$ 使得代价函数最小，一种是 <strong>梯度下降法</strong>（Gradient Descent），一种是求最小二乘法估计的 <strong>正规方程</strong>（Normal Equation）。</p>
<p>梯度下降法，顾名思义，用下式进行参数 $\theta$ 的迭代，直至收敛</p>
$$\theta_j := \theta_j - \alpha \dfrac{\partial}{\partial \theta_j}J(\theta).$$
<p>其中，$\alpha$ 为学习率，一般在实践中根据情况设定。</p>
<p>这个式子可以放心地使用，在线性回归中它不会求出来个局部最优解。上式涉及到对代价函数求偏导，可以利用和的导数即为导数之和的性质，先对个体求偏导再求和，将偏导数带入上式得</p>
$$\theta_j := \theta_j - \alpha\sum^{m}_{i=1}(h_{\theta}(x^{(i)}) - y^{(i)}) x_j^{(i)}.$$
<p>最终我们得到 <strong>批量梯度下降</strong>（Batch Gradient Descent）的方法：</p>
$~~~~~~~~\text{Repeat until convergence }\{$
$~~~~~~~~ ~~~~~~~~\theta_j := \theta_j + \alpha\sum^{m}_{i=1}(y^{(i)}-h_{\theta}(x^{(i)})) x_j^{(i)}~~~~~~~~(\text{for every }j)\\$
$~~~~~~~~ \}$
<br>
<br>
<p>接着介绍求最小二乘法估计的正规方程，将代价函数整理为矩阵的形式，并对代价函数求导，令导数为 $0$，可以得到</p>
$$
\dfrac{\partial J(\theta)}{\partial \theta} = \dfrac{\partial }{\partial \theta}\dfrac{1}{2}(X\theta - \vec{y})^T(X\theta - \vec{y}) = 0
$$
<p>方程化简</p>
$$X^T X \theta = X^T \vec{y}$$
<p>于是我们得到了最小化 $J(\theta)$ 的 $\theta$ 最优解的闭式解</p>
$$\theta = (X^T X)^{-1} X^T \vec{y}$$
<h4 id="逻辑回归（Logistic-Regression）"><a class="header-anchor" href="#逻辑回归（Logistic-Regression）">¶</a>逻辑回归（Logistic Regression）</h4>
<p>Logistic Regression is used when the dependent variable(target) is categorical.</p>
<p>Data is fit into linear regression model, which then be acted upon by a logistic function predicting the target categorical dependent variable.</p>
<p>当因变量(目标)是分类变量时，可以使用逻辑回归来进行分类。</p>
<p>考虑一个二分类问题，其输出标记 $y \in \{0, 1\}$，线性回归模型产生的预测值是一个实值，我们需要一个单调可微函数将实值转换为 0/1 值，最理想的单位阶跃函数是不连续的，我们一般用 <strong>对数几率函数</strong>（logistic function）来替代它，即</p>
$$\text{sigmoid}(z) = \dfrac{1}{1 + e^{-z}}.$$
<p>于是我们将 hypotheses $h_\theta(x)$ 变为以下形式</p>
$$h_\theta(x) = g(\theta^T x) = \dfrac{1}{1 + e^{-\theta^T x}},$$
<p>并假设</p>
$$P(y=1~|~x; \theta) = h_\theta(x),$$
$$P(y=0~|~x; \theta) = 1 - h_\theta(x).$$
<p>上面两式可合并写为</p>
$$P(y~|~x; \theta) = (h_\theta(x))^y (1 - h_\theta(x))^{1-y}.$$
<p>假设训练样本是独立地生成的，我们可以用 <strong>最大似然估计</strong>（maximum likelihood estimation, MLE）的方法来估计 $\theta$，其似然函数为</p>
$$
\begin{array}{lcl}
\mathscr{L}(\theta)
& = & p(\vec{y}~|~X; \theta)\\
& = & \prod\limits^{m}_{i=1} p(y^{(i)}~|~x^{(i)}; \theta)\\
& = & \prod\limits^{m}_{i=1} \big(h_\theta(x^{(i)})\big)^{y^{(i)}} \big(1 - h_\theta(x^{(i)})\big)^{1-y^{(i)}}.
\end{array}
$$
<p>对似然函数两边取对数有</p>
$$
\begin{array}{lcl}
ℓ(\theta)
& = & \log \mathscr{L}(\theta)\\
& = & \sum\limits^{m}_{i=1} y^{(i)} \log h(x^{(i)}) + (1 - y^{(i)}) \log (1 - h(x^{(i)}))
\end{array}
$$
<p>最大化 $ℓ(\theta)$ 等价于最小化 $-ℓ(\theta)$，可以使用经典的数值优化算法如梯度下降法（gradient descent）或者牛顿法（Newton method），来求得其最优解，这里以梯度下降法为例，其迭代公式为</p>
$$\theta := \theta - \alpha \nabla_\thetaℓ(\theta).$$
<p>化简得</p>
$$\theta := \theta - \alpha \big(y^{(i)} - h_\theta(x^{(i)}) \big)x_j^{(i)}$$
<h3 id="朴素贝叶斯分类器（Naive-Bayes-Classifiers"><a class="header-anchor" href="#朴素贝叶斯分类器（Naive-Bayes-Classifiers">¶</a>朴素贝叶斯分类器（Naïve Bayes Classifiers)</h3>
<h4 id="贝叶斯准则（Bayes-Rule）"><a class="header-anchor" href="#贝叶斯准则（Bayes-Rule）">¶</a>贝叶斯准则（Bayes Rule）</h4>
<p>贝叶斯准则是关于随机事件 $A$ 和 $B$ 的条件概率和边缘概率的。</p>
<p>设 $A_1, A_2, \cdots, A_n$ 是一组互不相容的事件，形成样本空间的一个分割（每一个试验结果必定使得其中一个事件发生）。又假定对每一个 $i$，$P(A_i) &gt; 0$，即 $A_1, A_2, \cdots, A_n$ 为完备事件组，满足 $\cup^{n}_{i=1} A_i = \Omega$，$A_iA_j = \varnothing$，$P(A_i) &gt; 0$。则对于任何事件 $B$，只要它满足 $P(B) &gt; 0$，下列公式成立</p>
$$
\begin{array}{lcl}
P(A_i | B)
& = & \dfrac{P(B | A_i) P(A_i)}{P(B)} \\
& = & \dfrac{P(B | A_i) P(A_i)}{P(B | A_1)P(A_1) + \cdots + P(B | A_n)P(A_n)}\\
& = & \dfrac{P(B | A_i) P(A_i)}{\sum^{}_{j} P(B | A_j)P(A_j)}
\end{array}
$$
<p>$P(A_i)$ : independent probability of $A_i$ : prior probability（先验概率）<br>
$P(B)$ : independent probability of $B$<br>
$P(B|A_i)$ : conditional probability of $B$ given $A_i$ : likelihood<br>
$P(A_i|B)$ : cond. probability of $A_i$ given $B$ : posterior probability（后验概率）</p>
<p>使用贝叶斯概率术语，上面的方程可以写成如下形式</p>
$$\text{posterior} = \dfrac{\text{prior} \times \text{likelihood}}{\text{evidence}}$$
<h4 id="朴素贝叶斯（naive-Bayes）"><a class="header-anchor" href="#朴素贝叶斯（naive-Bayes）">¶</a>朴素贝叶斯（naive Bayes）</h4>
<p>朴素贝叶斯分类（NBC）是以贝叶斯定理为基础并且假设特征条件之间相互独立的方法，先通过已给定的训练集，以特征词之间独立作为前提假设，学习从输入到输出的联合概率分布，再基于学习到的模型，输入 $X$ 求出使得后验概率最大的输出 $Y$ 。</p>
<p>Abstractly, naive Bayes is a conditional probability model: given a problem instance to be classified, represented by a vector $\mathbf x = (x_1, \dots, x_n)$ representing some $n$ features (independent variables), it assigns to this instance probabilities</p>
$$p(C_k~|~x_1, \dots, x_n)$$
<p>for each of $K$ possible outcomes or classes $C_k$.</p>
<p>In practice, there is interest only in the numerator of that fraction, because the denominator does not depend on $C$ and the values of the features $x_i$ are given, so that the denominator is effectively constant. The numerator is equivalent to the joint probability model（分母实际上是常数。分子等价于联合概率模型）</p>
$$p(C_k, x_1, \dots, x_n)$$
<p>which can be rewritten as follows, using the chain rule for repeated applications of the definition of conditional probability（应用条件概率的链式法则）:</p>
$$
\begin{array}{lcl}
& & p(C_k, x_1, \dots, x_n) \\
& = & p(x_1, \dots, x_n, C_k) \\
& = & p(x_1~|~x_2, \dots, x_n, C_k)p(x_2, \dots, x_n, C_k) \\
& = & p(x_1~|~x_2, \dots, x_n, C_k)p(x_2~|~x_3, \dots, x_n, C_k)p(x_3, \dots, x_n, C_k) \\
& = & \dots \\
& = & p(x_1~|~x_2, \dots, x_n, C_k) \dots p(x_{n-1}~|~x_n, C_k)p(x_n~|~C_k)p(C_k)
\end{array}
$$
<blockquote>
<p>这里对上面的过程做一些解释：<br>
对 $p(C_k~|~x_1, \dots, x_n)$ 应用贝叶斯公式，由于特征值 $x_i$ 是给出的，且分母与 $C_k$ 无关，所以分母 $p(x_1, \dots, x_n)$ 实际上是常数，而分子 $p(x_1, \dots, x_n | C_k) p(C_k)$ 等价于联合概率模型。那么实际上就有：</p>
$$p(C_k~|~x_1, \dots, x_n) = \dfrac{p(x_1, \dots, x_n | C_k) p(C_k)}{p(x_1, \dots, x_n)} \propto p(C_k, x_1, \dots, x_n)$$
</blockquote>
<br>
<p>Now the “naive” conditional independence assumptions come into play: assume that each feature $x_i$ is conditionally independent of every other feature $x_j$ for $j \neq i$, given the category $C_k$. This means that</p>
$$p(x_i~|~x_{i+1}, \dots, x_n, C_k) = p(x_i~|~C_k)$$
<blockquote>
<p>基于有限训练样本直接估计联合概率，在计算上将会遭遇组合爆炸问题，在数据上将会遭遇样本稀疏问题；属性数越多，问题越严重。为了避开这个障碍，naive Bayes 采用了 “<strong>属性条件独立性假设</strong>”（attribute conditional independence assumption）：对已知类别，假设所有属性相互独立。换言之，假设每个属性独立地对分类结果发生影响。</p>
</blockquote>
<br>
<p>Thus, the joint model can be expressed as</p>
$$
\begin{array}{lcl}
p(C_k~|~x_1, \dots, x_n)
& \propto & p(C_k, x_1, \dots, x_n)\\
& = & p(C_k)p(x_1~|~C_k)p(x_2~|~C_k)p(x_3~|~C_k)\cdots\\
& = & p(C_k)\prod\limits^{n}_{i=1}p(x_i~|~C_k),
\end{array}
$$
<p>where $\propto$ denotes proportionality.</p>
<p>The discussion so far has derived the independent feature model, that is, the naive Bayes probability model（朴素贝叶斯概率模型）. The naive Bayes classifier combines this model with a decision rule. One common rule is to pick the hypothesis that is most probable（常见的规则是选择最有可能的假设）; this is known as the maximum a posteriori（<strong>最大后验概率</strong>） or MAP decision rule. The corresponding classifier, a Bayes classifier, is the function that assigns a class label $\widehat y = C_k$ for some $k$ as follows:</p>
$$
\widehat y = \mathop{\arg\max}_{k \in \{ 1, \dots, K \}} p(C_k)\prod^{n}_{i=1}p(x_i~|~C_k)
$$
<blockquote>
<p>$\mathop{\arg\max}$ 函数</p>
$$
\mathop{\arg\max}_{}f(x) := \{ x~|~x \in S \land \forall y \in S : f(y) \le f(x) \}
$$
<p>对一个函数 $f(x)$ 或一个映射 $f:X \rightarrow Y$，当 $x$ 取值范围为 $S$ 的时候（也叫 $x \in S$ ），$\mathop{\arg\max}$ 的结果是使得 $f(x)$ 取得最大值的 $x$ 点集。</p>
</blockquote>
<br>
<p>$p(C_k)$ 是好求的，当属性或者说特征为离散值时，$p(x_i~|~C_k)$ 亦不难求得，而当其为连续值时，则需考虑其概率密度函数，假定 $p(x_i~|~C_k) \sim \mathcal{N}(\mu_{C_k, i}, \sigma^2_{C_k, i})$，其中 $\mu_{C_k, i}, \sigma^2_{C_k, i}$ 分别是第 $k$ 类样本在第 $i$ 个属性上取值的均值和方差，则有</p>
$$p(x_i~|~C_k) = \dfrac{1}{\sqrt{2\pi}\sigma_{C_k, i}}\exp\Big( -\dfrac{(x_i - \mu_{C_k, i})^2}{2\sigma^2_{C_k, i}} \Big)$$
<h4 id="拉普拉斯平滑（Laplace-smoothing）"><a class="header-anchor" href="#拉普拉斯平滑（Laplace-smoothing）">¶</a>拉普拉斯平滑（Laplace smoothing）</h4>
<p>如果某个属性上的概率为 $0$，该样本的其他属性携带的信息将会被抹去，产生零概率问题，为了避免这种情况，在估计概率值时可进行 <strong>拉普拉斯平滑</strong>，修正后的公式为：</p>
$$\widehat P(C_k)=\dfrac{|D_{C_k}|+1}{|D|+N},~~~~\widehat P(x_i~|~C_k) = \dfrac{|D_{C_k, x_i}|+1}{|D_{C_k}|+N_i}$$
<p>其中，$N$ 表示训练集 $D$ 中可能的类别数，$N_i$ 表示第 $i$ 个属性可能的取值数。</p>
<h3 id="决策树（Decision-Trees）"><a class="header-anchor" href="#决策树（Decision-Trees）">¶</a>决策树（Decision Trees）</h3>
<p>Decision tree is a hierarchical tree structure that used to classify classes based on a series of questions (or rules) about the attributes of the class. In short, given a data of attributes together with its classes, a decision tree produces a sequence of rules (or series of questions) that can be used to recognize the class.</p>
<p>决策树是一种分层的树结构，它用于根据一系列关于类属性的问题或是规则来进行分类的问题。简而言之，给定一个包含一些属性及其所属类别的数据，决策树会产生一系列规则(或一系列问题)，这些规则可用于识别该类。</p>
<blockquote>
<p>一颗决策树包含一个根节点、若干个内部结点和若干个叶结点；叶结点对应于决策结果，其他每个结点则对应于一个属性测试；每个结点包含的样本集合根据属性测试的结果被划分到子结点中；根结点包含样本全集，从根结点到每个叶子结点的路径对应了一个判定测试序列。</p>
</blockquote>
<p>决策树的基本特点：贪婪（greedy）、自顶向下（top-down）、递归（recursive）。</p>
<h4 id="基本流程"><a class="header-anchor" href="#基本流程">¶</a>基本流程</h4>
<p>决策树学习的关键在于如何选择最优的划分属性，所谓的最优划分属性，对于二元分类而言，就是尽量使划分的样本属于同一类别，即“纯度”最高的属性。那么如何来度量特征（features）的纯度，这时候就要用到 <strong>信息熵</strong>（information entropy），</p>
$$H(x) = -\sum^{n}_{i=0}P(x_i)\log_bP(x_i)$$
<p>其中，$n$ 为类别的总数，一般取 $b=2$，此时 $H(x)$ 的单位为 $\text{bits}$ 。</p>
<p>信息熵可以衡量一个数据集的信息“纯度”。信息越纯，熵就越低；信息越混杂，熵就越高。</p>
<p>再定义 <strong>信息增益</strong>（information gain）来表示纯度的提升，</p>
$$\text{Information gain}(i) = \text{Entropy of parent table}~D~-\text{Sum}(\dfrac{n_k}{n} \cdot\\ \text{Entropy of each value}~k~\text{of subset table }S_i).$$
<p>即父亲节点的信息熵减去子节点上样本熵的加权平均数。在 ID3 算法中，通过测量各种切分方案的信息增益，选择具有最大信息增益的切分方式，即可确定决策树上这一个父亲节点的切分。</p>
<h4 id="基尼系数（Gini-index）"><a class="header-anchor" href="#基尼系数（Gini-index）">¶</a>基尼系数（Gini index）</h4>
<h4 id="剪枝处理（pruning）"><a class="header-anchor" href="#剪枝处理（pruning）">¶</a>剪枝处理（pruning）</h4>
<h3 id="支持向量机（Support-Vector-Machines）"><a class="header-anchor" href="#支持向量机（Support-Vector-Machines）">¶</a>支持向量机（Support Vector Machines）</h3>
<h3 id="神经网络（Neural-Networks）"><a class="header-anchor" href="#神经网络（Neural-Networks）">¶</a>神经网络（Neural Networks）</h3>
<p>人工神经网络<br>
前馈神经网络<br>
BP 神经网络<br>
卷积神经网络CNN<br>
循环神经网络RNN</p>
<hr>
<p>以上的总结中有的来自下面的书籍或文章：</p>
<p>[1] 机器学习 / 周志华著. 北京：清华大学出版社，2016<br>
[2] 概率导论 /（美）伯特瑟卡斯（Dimitri P．Bertsekas）、齐齐克利斯（John N．Tsitsiklis）著，郑忠国、童行伟译<br>
[3] CS229 Lecture notes / Andrew Ng<br>
[4] <a href="https://www.ruanx.net/ml-review/" target="_blank" rel="noopener">机器学习复习笔记</a> / Ruan Xingzhi<br>
[5] <a href="https://blog.csdn.net/u012328159/article/details/70184415" target="_blank" rel="noopener">决策树（decision tree）(一)——构造决策树方法</a> / 天泽28<br>
[6] <a href="https://blog.csdn.net/u012328159/article/details/79285214" target="_blank" rel="noopener">决策树（decision tree）(二)——剪枝</a> / 天泽28<br>
[7] <a href="https://blog.csdn.net/u012328159/article/details/79396893" target="_blank" rel="noopener">决策树（decision tree）(三)——连续值处理</a> / 天泽28<br>
[8] <a href="https://blog.csdn.net/u012328159/article/details/79413610" target="_blank" rel="noopener">决策树（decision tree）(四)——缺失值处理</a> / 天泽28</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组与线段树</title>
    <url>/2022/06/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=12" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/358521" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-树状数组&amp;线段树</a> 但是没得密码。。。<br>
本篇博文为看视频学习时的记录与自己的一些总结<br>
学习笔记合集：<a href="https://cloudplayer.top/2022/06/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">算法入门基础</a></p>
</blockquote>
<a id="more"></a>
<ul>
<li>树状数组与线段树
<ul>
<li>树状数组
<ul>
<li>由前缀和引入
<ul>
<li>导引问题</li>
</ul>
</li>
<li>引入树状数组
<ul>
<li>$\text{lowbit}(x)$ 的求法</li>
<li>构造树状数组 $C_i$</li>
<li>区间查询操作</li>
<li>单点更新操作</li>
<li>二维树状数组模板</li>
</ul>
</li>
<li>树状数组应用
<ul>
<li>求逆序对</li>
<li>对上面问题的引申——离散化</li>
<li>区间更新，单点查询</li>
<li>区间修改，区间查询</li>
</ul>
</li>
<li>树状数组的优缺点</li>
</ul>
</li>
<li>线段树
<ul>
<li>导引问题</li>
<li>引入线段树
<ul>
<li>线段树的属性</li>
<li>线段树的定义</li>
<li>线段树的构造</li>
<li>单点更新</li>
<li>区间查询</li>
</ul>
</li>
<li>线段树的区间更新
<ul>
<li>lazy 标记与延迟更新</li>
<li>区间更新</li>
<li>区间更新的区间查询</li>
<li>更好的代码</li>
</ul>
</li>
<li>线段树的应用
<ul>
<li>线段树 + 区间合并</li>
</ul>
</li>
<li>线段树的优缺点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>树状数组与线段树</h1>
<h2 id="树状数组"><a class="header-anchor" href="#树状数组">¶</a>树状数组</h2>
<h3 id="由前缀和引入"><a class="header-anchor" href="#由前缀和引入">¶</a>由前缀和引入</h3>
<p>$A$ 为 $N$ 个数所在的数组，$B$ 为另一个新的数组<br>
令 $B$ 数组的第 $i$ 项为 $A$ 数组的 $A_0$ 至 $A_i$ 项之和</p>
<p>即：</p>
<p>$$<br>
B_i = A_0 + A_1 + A_2 + \dots + A_i<br>
$$</p>
<p>则有：</p>
<p>$$<br>
B_i = B_{i-1} + A_i \ \ \ \ (B_0 = A_0)<br>
$$</p>
<p>有时为了方便，$A$、$B$ 数组下标从 $1$ 开始</p>
<p>前缀和的应用：</p>
<p>区间求和，求 $A$ 数组的 $100$ 至 $200$ 项之和</p>
<p>$$<br>
A_{100} + \dots + A_{200} = B_{200} - B_{99} \ \ \ \ O(n) \Rightarrow O(1)<br>
$$</p>
<p>当区间求和量比较大的时候，通过预处理前缀和数组，极大地减少了计算量</p>
<h4 id="导引问题"><a class="header-anchor" href="#导引问题">¶</a>导引问题</h4>
<p>有 $N$ ($N \le 50000$) 个工兵营地，已知每个营地的人数，查询一段连续的工兵营地总人数，询问的次数 $Q \le 50000$</p>
<p>预处理前缀和数组</p>
<p>有 $N$ ($N \le 50000$) 个工兵营地，已知每个营地的人数，但是每个工兵营地的人数都有可能多次发生变动，每次可能增加或减少若干人手，需要查询一段连续的工兵营地总人数，询问的次数 $Q \le 50000$</p>
<p>难以维护前缀和数组，还不如暴力开数组</p>
<h3 id="引入树状数组"><a class="header-anchor" href="#引入树状数组">¶</a>引入树状数组</h3>
<p>提出问题<br>
给长度为 $n$ 的数组 $A_1, A_2, \dots, A_n$，多次修改操作和查询操作，修改操作修改数组某一个元素的值，查询操作查询 $A_1 + A_2 + \dots + A_x$ 的值</p>
<p>朴素做法</p>
<ul>
<li>每次 $O(1)$ 修改数组的值，$O(n)$ 求和</li>
<li>求出前缀和数组 $sum_i = a_1 + a_2 + \dots + a_i$，每次 $O(1)$ 查询，$O(n)$ 修改</li>
</ul>
<p>为了引入树状数组，先构造二叉树，叶子结点代表 $A_1$ ~ $A_8$<br>
对二叉树变形，定义每一列的顶端元素为树状数组元素，其中 $C_i$ 代表子树的叶子结点的权值之和，例如 $C_6 = A_6 + A_5$</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E5%BC%95%E5%85%A5%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.PNG"/></div>
<p>两个规律：</p>
<ul>
<li>$i$ 为奇，$C_i = A_i$</li>
<li>$C_i$ 一定包含 $A_i$，且 $A_i$ 是其包含的最后一个</li>
</ul>
<p>引入树状数组 $C_1, C_2, \dots, C_n$，其中</p>
<p>$$C_i = A_i + A_{i-1} + \dots + A_{i-\text{lowbit}(i)+1}$$</p>
<p>$\text{lowbit}(i)$：将 $i$ 转换为二进制，最低位的 $1$ 所代表的值<br>
$\text{lowbit}(i)$ 决定 $C_i$ 包含多少项</p>
<p>$5 = (101)_2 \ \ \ \ \ \ \text{lowbit}(5) = (1)_2 = 1$<br>
$6 = (110)_2 \ \ \ \ \ \ \text{lowbit}(6) = (10)_2 = 2$<br>
$8 = (1000)_2 \ \ \ \ \text{lowbit}(8) = (1000)_2 = 8$</p>
<p>$\text{lowbit}(1)=1\ \ \ \ C_1 = A_1$<br>
$\text{lowbit}(2)=2\ \ \ \ C_2 = A_2 + A_1$<br>
$\text{lowbit}(3)=1\ \ \ \ C_3 = A_3$<br>
$\text{lowbit}(4)=4\ \ \ \ C_4 = A_4 + A_3 + A_2 + A_1$<br>
$\text{lowbit}(5)=1\ \ \ \ C_5 = A_5$<br>
$\text{lowbit}(6)=2\ \ \ \ C_6 = A_6 + A_5$<br>
$\text{lowbit}(7)=1\ \ \ \ C_7 = A_7$<br>
$\text{lowbit}(1)=8\ \ \ \ C_8 = A_8 + A_7 + A_6 + A_5 + A_4 + A_3 + A_2 + A_1$</p>
<h4 id="text-lowbit-x-的求法"><a class="header-anchor" href="#text-lowbit-x-的求法">¶</a>$\text{lowbit}(x)$ 的求法</h4>
<p>法 1：<br>
若 $x$ 为奇，其二进制的最后一位必为 $1$，则 $x-1$ 的最后一位必为 $0$<br>
则 $x \And (x-1) = x-1$，$x - (x \And (x - 1)) = 1$<br>
奇数的 $\text{lowbit}$ 一定是 $1$<br>
若 $x$ 为偶，$x \And (x-1)$ 使得从最低位的 $1$ 开始全置为 $0$<br>
$x - (x \And (x - 1))$ 减出来的结果就是 $\text{lowbit}(x)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - (x &amp; (x - <span class="number">1</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法 2：<br>
利用补码的性质<br>
负数的二进制补码等于对应正数的反码加一<br>
可以得到 $\text{lowbit(x) = x &amp; (-x)}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造树状数组-C-i"><a class="header-anchor" href="#构造树状数组-C-i">¶</a>构造树状数组 $C_i$</h4>
<p>已知原始的 $A_i$ 数组（初始状态）<br>
现在又有了 $\text{lowbit}(x)$ 函数<br>
如何构造出树状数组 $C_i$ ？<br>
其实树状数组的构造就是更新操作！</p>
<h4 id="区间查询操作"><a class="header-anchor" href="#区间查询操作">¶</a>区间查询操作</h4>
<p>先实现前缀和，利用 $C_i$ 求出 $A$ 数组中的前 $i$ 项的和<br>
比如 $i = 7$ 时，前七项和为：$a_1 + a_2 + \dots + a_7$</p>
$$\begin{array}{lcl}
a_1 + a_2 + \dots + a_7 
& = & (a_7) + (a_6 + a_5) + (a_4 + a_3 + a_2 + a_1)\\
& = & c_7 + c_6 + c_4 \\
& = & c_{(111)_2} + c_{(110)_2} + c_{(100)_2}
\end{array}$$
<p>规律：<br>
$\text{lowbit}(i)$ 决定 $C_i$ 包含多少项<br>
每加上一个 $C_i$ 就让 $i = i - \text{lowbit}(i)$</p>
<p>求和实现代码 $O(\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">        ret += C[i], x -= lowbit(i);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间查询：$sum( R ) - sum( L - 1 )$</p>
<h4 id="单点更新操作"><a class="header-anchor" href="#单点更新操作">¶</a>单点更新操作</h4>
<p>$i$ 结点的父亲结点是 $i + \text{lowbit}(i)$ 结点<br>
每次修改会影响这个结点到根结点的路径上的点</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%93%E7%82%B9%E5%85%B3%E7%B3%BB.PNG"/></div>
<p>更新代码 $O(\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span>             <span class="comment">// 单点更新（影响多个 C 数组元素）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">        c[i] += val, i += lowbit(i);    <span class="comment">// 由叶子结点向上更新 C 数组</span></span><br><span class="line">&#125; <span class="comment">// 更新（从小到大）是查询（从大到小）的逆过程</span></span><br></pre></td></tr></table></figure>
<h4 id="二维树状数组模板"><a class="header-anchor" href="#二维树状数组模板">¶</a>二维树状数组模板</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = y;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= m) &#123;</span><br><span class="line">            c[i][j] += z;</span><br><span class="line">            j += lowbit(j); </span><br><span class="line">        &#125;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = x;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = y;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += c[i][j];</span><br><span class="line">            j -= lowbit(j);</span><br><span class="line">        &#125;</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组应用"><a class="header-anchor" href="#树状数组应用">¶</a>树状数组应用</h3>
<h4 id="求逆序对"><a class="header-anchor" href="#求逆序对">¶</a>求逆序对</h4>
<p>给定 $n$ ($n \le 100000$) 个正整数，希望对其从小到大排序，如果采用冒泡排序算法，请计算需要进行的交换次数</p>
<p>冒泡排序的基本思想是比较相邻的元素，逆序则交换，那么交换次数的本质就是逆序对的总数，问题就转换成了如何求逆序对的总数</p>
<p>基本思想：开一个数组 $a[n+1]$，初始化为 $0$，$a$ 数组下标代表对应的正整数，每计一个数 $i$，就令 $a[i] = 1$，通过计算 $a[i+1]$ ~ $a[n]$ 中有多少个 $1$ 来求出 $i$ 的逆序数，这里需要多次区间求和，于是开一个树状数组 $c[n+1]$，初始化为 $0$，当计一个数 $i$ 时，就向上更新 $c$ 数组，当求 $i$ 的逆序数时，只需计算 $\text{sum}(n)-\text{sum}(i)$ 即可</p>
<h4 id="对上面问题的引申——离散化"><a class="header-anchor" href="#对上面问题的引申——离散化">¶</a>对上面问题的引申——离散化</h4>
<p>给定 $n$ ($n \le 100000$) 个正整数 $A_i$ 组成的数列 ($A_i \le 10^9$，$1 \le i \le n$)，希望对其从小到大排序，如果采用冒泡排序算法，请计算需要进行的交换次数</p>
<p>之前的算法使用数组下标代表对应的正整数，这里正整数最大达到 $10^9$，不可能开这么大的数组，需要进行 <strong>离散化</strong></p>
<p>离散化是一种常用的技巧，有时 <strong>数据范围太大</strong>，自身无法作为数组的下标保存对应的属性，当数据只与它们之间的相对大小有关，而 <strong>与具体值无关</strong> 时，则可以进行离散化，总之，离散化是在 <strong>不改变数据相对大小</strong> 的条件下，对数据进行相应的缩小</p>
<p>方法：把对应的数据和 $1$ 至 $N$ 建立一一映射的关系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;        <span class="comment">// 原始数值</span></span><br><span class="line">    <span class="keyword">int</span> order;      <span class="comment">// 原始下标</span></span><br><span class="line">&#125;a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组 a 按 val 从小到大排序；</span></span><br><span class="line"><span class="comment">// 此时，val 和结构体的新下标就是一个一一映射关系</span></span><br><span class="line"><span class="comment">// 并且满足原来的相对大小关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 b 数组（离散化数组）</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    b[a[i].order] = i;</span><br></pre></td></tr></table></figure>
<p>离散化示例</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%A6%BB%E6%95%A3%E5%8C%96.PNG"/></div>
<p>重复元素处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(a+<span class="number">1</span>, a+<span class="number">1</span>+N, cmp);</span><br><span class="line">b[a[<span class="number">1</span>].order] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>, count = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i].val == a[i - <span class="number">1</span>].val)   b[a[i].order] = count;</span><br><span class="line">    <span class="keyword">else</span> b[a[i].order] = ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间更新，单点查询"><a class="header-anchor" href="#区间更新，单点查询">¶</a>区间更新，单点查询</h4>
<p>有 $N$ ($N \le 100000$) 个气球排成一排，从左到右依次编号为 $1$，$2$，$3$，$\dots$，$N$，每次给定两个整数 $a$ 和 $b$ ($a \le b$)，表示从气球 $a$ 到气球 $b$ 依次给每个气球涂一次颜色，$N$ 次涂色后，计算每个气球被涂过几次颜色</p>
<p>变化：更新的是区间，查询的是单点</p>
<p>需要一个“区间更新，单点查询”的树状数组<br>
通过 <strong>差分</strong> 的方法，数组中记录每个元素与前一个元素的差，这样把问题转化为常规树状数组！</p>
<p>单点查询<br>
若原数组为 $a[i]$，设数组 $d[i] = a[i] - a[i-1]$ ($a[0] = 0$)，则可以通过求 $d[i]$ 的前缀和实现单点查询 $a[i]$<br>
区间修改<br>
当给区间 $[l,r]$ 加上 $x$ 的时候，只需给 $d[l]$ 加上 $x$，给 $d[r+1]$ 减去 $x$ 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单点更新差分，为区间修改做准备（c 为树状数组）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) c[p] += x, p += p &amp; -p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改（通过两个端点的更新，实现区间修改的目的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    add(l, x), add(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点查询（因为差分，所以单点值即前缀和）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) res += c[p], p -= p &amp; -p;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间修改，区间查询"><a class="header-anchor" href="#区间修改，区间查询">¶</a>区间修改，区间查询</h4>
<p>金箍棒由 $N$ 段相同长度的金属棒连接而成，初始每段金属棒的值都是 $1$，并且从 $1$ 至 $N$ 编号，可以增加金箍棒任意连续的一段的所有金属棒的值，可以查询（$Q$ 次）执行 $M$ 次操作后某一段金箍棒的总值</p>
<p>变化：区间修改，区间查询</p>
<p>位置 $p$ 的前缀和：</p>
$$\begin{array}{lcl}
\sum\limits_{i=1}^{p}a[i] 
& = & \sum\limits_{i=1}^{p}\sum\limits_{j=1}^{i}d[j] \\
& = & \sum\limits_{i=1}^{p}d[i] * (p - i + 1) \\
& = & (p + 1)\sum\limits_{i=1}^{p}d[i] - \sum\limits_{i=1}^{p}d[i] * i
\end{array}$$
<p>维护两个数组的前缀和（树状数组）即可，$c1[i] = d[i]$，$c2[i] = d[i] * i$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 维护两个树状数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n; i += i &amp; -i)</span><br><span class="line">        c1[i] += x, c2[i] += x * p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    add(l, x), add(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前缀和查询，即查询区间 [1, p] 的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= i &amp; -i)</span><br><span class="line">        res += (p + <span class="number">1</span>) * c1[i] - c2[i];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">range_ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ask(r) - ask(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组的优缺点"><a class="header-anchor" href="#树状数组的优缺点">¶</a>树状数组的优缺点</h3>
<p>优点：代码短小，实现简单；</p>
<p>缺点：只能求和，不能求最大/小值</p>
<h2 id="线段树"><a class="header-anchor" href="#线段树">¶</a>线段树</h2>
<h3 id="导引问题-v2"><a class="header-anchor" href="#导引问题-v2">¶</a>导引问题</h3>
<p>金箍棒升级了！<br>
金箍棒由 $N$ 段相同长度的金属棒连接而成，初始每段金属棒的值都是 $1$，并且从 $1$ 至 $N$ 编号，可以改变金箍棒任意连续的一段的所有金属棒的值，可以查询（$Q$ 次）执行 $M$ 次操作后某一段金箍棒的总值</p>
<p>区间更新，但不是增加或减少，而是直接修改<br>
树状数组不能解决这个问题</p>
<p>新的数据结构：线段树</p>
<h3 id="引入线段树"><a class="header-anchor" href="#引入线段树">¶</a>引入线段树</h3>
<p>假设有编号从 $1$ 到 $n$ 的 $n$ 个点，每个点都存了一些信息，用 $[L, R]$ 表示下标从 $L$ 到 $R$ 的区间信息</p>
<p>线段树原理：<br>
将 $[1, n]$ 分解成若干特定的子区间（数量不超过 $4 * n$），然后，将每个区间 $[L, R]$ 都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对 $[L, R]$ 的修改或者统计</p>
<p>线段树（Segment Tree）又称为区间树（Internal Tree），是一颗平衡二叉树，非完全二叉树，树上的每一个节点代表一段区间</p>
<p>线段树划分区间采用的是二分的思想，比树状数组更加直白</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%A4%BA%E4%BE%8B.PNG"/></div>
<h4 id="线段树的属性"><a class="header-anchor" href="#线段树的属性">¶</a>线段树的属性</h4>
<ul>
<li>每个区间的长度是区间内整数的个数</li>
<li>叶子结点长度为 $1$，不能再分</li>
<li>若一个结点对应的区间是 $[a, b]$，则其子区间对应的节点分别是 $[a, \dfrac{(a+b)}{2}]$ 和 $[\dfrac{(a+b)}{2} + 1, b]$</li>
<li>线段树的高度是：$\left\lceil \log_{2} (b-a+1) \right\rceil + 1$</li>
<li>线段树把区间上的任意一条线段都分成不超过 $2 \log N$ 条（每层不超过两个）</li>
</ul>
<h4 id="线段树的定义"><a class="header-anchor" href="#线段树的定义">¶</a>线段树的定义</h4>
<p>定义 SegmentNode 结构体与线段树 SegTree 数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL val;             <span class="comment">// 结点值，例如区间最大值 </span></span><br><span class="line">    LL lazy;            <span class="comment">// 懒惰标记，又称延迟更新标记</span></span><br><span class="line">                        <span class="comment">// 可以根据题目增加更多的元素</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A[maxn];            <span class="comment">// 原始数组</span></span><br><span class="line">SegmentNode SegTree[maxn&lt;&lt;<span class="number">2</span>];       <span class="comment">// 定义线段树，开原始数组的 4 倍大</span></span><br><span class="line"><span class="comment">// SegmentNode SegTree[4*maxn];</span></span><br><span class="line"><span class="comment">// 数组存二叉树，用完全二叉树的编号作为数组下标</span></span><br></pre></td></tr></table></figure>
<h4 id="线段树的构造"><a class="header-anchor" href="#线段树的构造">¶</a>线段树的构造</h4>
<p>PushUp 函数更新结点信息<br>
build 函数构造根为 $rt$，$A$ 区间为 $[l, r]$ 的线段树<br>
在 build 函数中调用 PushUp 函数，用于在函数回溯时向上更新线段树的结点信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PushUp 函数更新结点信息，这里以求和为例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    SegTree[rt].val = SegTree[rt&lt;&lt;<span class="number">1</span>].val + SegTree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val;</span><br><span class="line">    <span class="comment">// SegTree[rt].val = SegTree[2*rt].val + SegTree[2*rt + 1].val; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="comment">// 构造根为 rt，A 区间为 [l, r] 的线段树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)                     <span class="comment">// 叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        SegTree[rt].val = A[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(<span class="number">2</span>*rt, l, mid);            <span class="comment">// 递归构造左子树</span></span><br><span class="line">    build(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, r);    <span class="comment">// 递归构造右子树</span></span><br><span class="line">    PushUp(rt);                     <span class="comment">// 回溯，向上更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单点更新"><a class="header-anchor" href="#单点更新">¶</a>单点更新</h4>
<p>假设 $A[L] += k$，区间信息为区间的和</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0%E7%A4%BA%E4%BE%8B.PNG"/></div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tl，tr 表示当前结点区间，rt 表示当前线段树的根结点编号</span></span><br><span class="line"><span class="comment">// k 为变化值，L 为更新点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> tr, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> L, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tl == tr)                               <span class="comment">// 叶结点，直接修改</span></span><br><span class="line">    &#123;</span><br><span class="line">        SegTree[tr].val += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) Update(<span class="number">2</span>*rt, tl, mid, L, k);</span><br><span class="line">    <span class="keyword">else</span> Update(<span class="number">2</span>*tr+<span class="number">1</span>, mid+<span class="number">1</span>, tr, L, k);</span><br><span class="line">    PushUp(rt);                                 <span class="comment">// 回溯，向上更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间查询"><a class="header-anchor" href="#区间查询">¶</a>区间查询</h4>
<p>假设询问 $A[L, R]$ 的和</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%9F%A5%E8%AF%A2%E7%A4%BA%E4%BE%8B.PNG"/></div>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [tl, tr] 表示当前区间，[l, r] 表示操作区间</span></span><br><span class="line"><span class="comment">// rt 表示当前结点编号</span></span><br><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tl == l &amp;&amp; tr == r) <span class="keyword">return</span> SegTree[tr].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> ask(<span class="number">2</span>*rt, tl, mid, l, r); <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> ask(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, tr, l, r); <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ask(<span class="number">2</span>*x, tl, mid, l, mid) + ask(<span class="number">2</span>*x + <span class="number">1</span>, mid + <span class="number">1</span>, tr, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法：在函数递归时保持 $[l, r]$ 操作区间不变<br>
采用这种写法为模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [tl, tr] 表示当前区间，[l, r] 表示操作区间</span></span><br><span class="line"><span class="comment">// rt 表示当前结点编号</span></span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)                 <span class="comment">// 完全包含</span></span><br><span class="line">        <span class="keyword">return</span> SegTree[rt].val;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; tr || r &lt; tl)                   <span class="comment">// 完全不包含</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ANS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ANS += Query(rt&lt;&lt;<span class="number">1</span>, tl, mid, l, r);</span><br><span class="line">    <span class="comment">// 左子区间与 [l, r] 有重叠，递归</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ANS += Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, tr, l, r);</span><br><span class="line">    <span class="comment">// 右子区间与 [l, r] 有重叠，递归</span></span><br><span class="line">    <span class="keyword">return</span> ANS;</span><br><span class="line">    <span class="comment">// return Query(rt&lt;&lt;1, tl, mid, l, r) + Query(rt&lt;&lt;1|1, mid+1, tr, l, r);</span></span><br><span class="line">    <span class="comment">// 这一句与上面四句结果等价，写的时候只写这一句就好了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树的区间更新"><a class="header-anchor" href="#线段树的区间更新">¶</a>线段树的区间更新</h3>
<p>区间更新：<br>
是指更新某个区间内的所有叶子结点的值，因为叶子结点会影响其相应的非叶父结点，那么回溯需要更新的非叶子结点也会有很多，如果一次性更新完，操作的时间复杂度可达 $O(n)$，$N$ 次更新操作时间复杂度就到了 $O(n^2)$</p>
<p>为此，引入了线段树中的延迟标记概念（lazy 标记）</p>
<h4 id="lazy-标记与延迟更新"><a class="header-anchor" href="#lazy-标记与延迟更新">¶</a>lazy 标记与延迟更新</h4>
<p>lazy 标记记录线段树当前结点是否进行了某种将要影响到其子结点的修改，记录后就可以偷懒不向下更新（不将影响传播至子结点），当查询到该结点的时候或者修改到该结点的子结点的时候再向下更新</p>
<p>多次更新，一次下推 / 无需要，不下推</p>
<p>加入 lazy 标记的线段树的 build 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造根为 rt，A 区间为 [l, r] 线段树</span></span><br><span class="line"><span class="comment">// 有 lazy 标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SegTree[rt].lazy = <span class="number">0</span>;           <span class="comment">// 初始化延时标记为 0</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)                     <span class="comment">// 叶子结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        SegTree[rt].val = A[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(<span class="number">2</span>*rt, l, mid);            <span class="comment">// 递归构造左子树</span></span><br><span class="line">    build(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, r);    <span class="comment">// 递归构造右子树</span></span><br><span class="line">    PushUp(rt);                     <span class="comment">// 回溯，向上更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间更新"><a class="header-anchor" href="#区间更新">¶</a>区间更新</h4>
<p>假设 $A[L, R] += k$</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E7%A4%BA%E4%BE%8B.PNG"/></div>
<p>区间更新 change 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [tl, tr] 表示当前区间，[l, r] 表示操作区间</span></span><br><span class="line"><span class="comment">// rt 表示当前结点编号，k 代表区间进行的更新</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tl == l &amp;&amp; tr == r)</span><br><span class="line">    &#123;</span><br><span class="line">        SegTree[rt].lazy += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SegTree[rt].lazy) PushDown(rt, tl, tr);</span><br><span class="line">    <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) change(<span class="number">2</span>*rt, tl, mid, l, r, k); <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) change(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, tr, l, r, k); <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        change(<span class="number">2</span>*rt, tl, mid, l, mid, k);</span><br><span class="line">        change(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, tr, mid + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    SegTree[rt].val = SegTree[<span class="number">2</span>*rt].val + (mid - tl + <span class="number">1</span>)*SegTree[<span class="number">2</span>*rt].lazy + SegTree[<span class="number">2</span>*rt + <span class="number">1</span>].val + (tr - mid)*SegTree[<span class="number">2</span>*rt + <span class="number">1</span>].lazy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下推更新 PushDown 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SegTree[rt].val = SegTree[rt].val + (tr - tl + <span class="number">1</span>)*SegTree[rt].lazy;</span><br><span class="line">    <span class="keyword">if</span> (tl != tr)</span><br><span class="line">    &#123;</span><br><span class="line">        SegTree[<span class="number">2</span>*rt].lazy += SegTree[rt].lazy;</span><br><span class="line">        SegTree[<span class="number">2</span>*rt + <span class="number">1</span>].lazy += SegTree[rt].lazy;</span><br><span class="line">    &#125;</span><br><span class="line">    SegTree[rt].lazy = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区间更新的区间查询"><a class="header-anchor" href="#区间更新的区间查询">¶</a>区间更新的区间查询</h4>
<p>假设询问 $A[L, R]$ 的和</p>
<p>区间查询 ask 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SegTree[rt].lazy) update(x, tl, tr);</span><br><span class="line">    <span class="keyword">if</span> (tl == l &amp;&amp; tr == r) <span class="keyword">return</span> SegTree[x].sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (tl + tr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> ask(<span class="number">2</span>*rt, tl, mid, l, r); <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> ask(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, tr, l, r); <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ask(<span class="number">2</span>*rt, tl, mid, l, mid) + ask(<span class="number">2</span>*rt + <span class="number">1</span>, mid + <span class="number">1</span>, tr, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更好的代码"><a class="header-anchor" href="#更好的代码">¶</a>更好的代码</h4>
<p>上面的区间更新的代码更符合直觉，但下面的代码更加流畅简洁<br>
采用下面的代码作为模板<br>
注意到，同样是完成区间更新功能的函数<br>
上面的 change 函数在进第一个 if（return 前）时不更新当前结点的 val，而下面的 Update 函数是要更新的<br>
并且 change 函数在递归过程中可能改变操作区间，而 Update函数在递归时保持 $[l, r]$ 操作区间不变<br>
还要注意到两个函数 if 分类讨论情况的不同</p>
<p>区间更新 Update 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [tl, tr] 表示当前区间，[l, r] 表示操作区间</span></span><br><span class="line"><span class="comment">// rt 表示当前结点编号，k 代表区间进行的更新</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)&#123;</span><br><span class="line">        SegTree[rt].val += k*(tr-tl+<span class="number">1</span>);                 <span class="comment">// 更新数字和，向上保持正确</span></span><br><span class="line">        SegTree[rt].lazy += k;                          <span class="comment">// 累加还是赋值，看需求</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (tl+tr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    PushDown(rt, mid-tl+<span class="number">1</span>, tr-mid);                     <span class="comment">// 下推以后，才准确更新子结点</span></span><br><span class="line">                                                        <span class="comment">// 一定要搞清楚这里为什么下推，不下推有什么后果</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) Update(l, r, k, tl, mid, rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) Update(l, r, k, mid+<span class="number">1</span>, tr, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    PushUp(rt);                                         <span class="comment">// 更新本结点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下推更新 PushDown 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ln，rn 分别为左子树和右子树的区间大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> ln, <span class="keyword">int</span> rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(SegTree[rt].lazy)&#123;                               <span class="comment">// 下推标记</span></span><br><span class="line">        SegTree[rt&lt;&lt;<span class="number">1</span>].lazy += SegTree[rt].lazy;</span><br><span class="line">        SegTree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lazy += SegTree[rt].lazy;</span><br><span class="line">        SegTree[rt&lt;&lt;<span class="number">1</span>].val += SegTree[rt].lazy*ln;</span><br><span class="line">        SegTree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].val += SegTree[rt].lazy*rn;</span><br><span class="line"></span><br><span class="line">        SegTree[rt].lazy = <span class="number">0</span>;                           <span class="comment">// 清除本结点标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间查询 Query 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [tl, tr] 表示当前区间，[l, r] 表示操作区间</span></span><br><span class="line"><span class="comment">// rt 表示当前结点编号</span></span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tl &amp;&amp; tr &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> SegTree[rt].val;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; tr || r &lt; tl)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tl+tr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    PushDown(rt, mid-tl+<span class="number">1</span>, tr-mid);                     <span class="comment">// 下推后才准确查询子结点</span></span><br><span class="line">    <span class="keyword">return</span> Query(l, r, tl, mid, rt&lt;&lt;<span class="number">1</span>) + Query(l, r, mid+<span class="number">1</span>, tr, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，可以根据自己的习惯定义结构体，加入一些参数使得计算更方便</p>
<h3 id="线段树的应用"><a class="header-anchor" href="#线段树的应用">¶</a>线段树的应用</h3>
<p>要用线段树统计，必须符合区间“加法”<br>
否则不可以通过二分子区间来得到 $[L, R]$ 的统计结果<br>
常见的例子有：<br>
区间数字之和 = 左区间数字之和 + 右区间数字之和<br>
区间最大值 = $\max$ ( 左区间最大值，右区间最大值 )<br>
区间最大公因树(GCD) = $\gcd$( 左区间 GCD，右区间 GCD )</p>
<p>一个问题只要能转化成对一些连续点的修改与统计问题，基本可以使用线段树来解决</p>
<h4 id="线段树-区间合并"><a class="header-anchor" href="#线段树-区间合并">¶</a>线段树 + 区间合并</h4>
<p>给定 $n$ 个整数和 $m$ 个操作，输出查询结果，操作有两类：<br>
U A B：将第 $A$ 个元素替换为 $B$（索引从 $0$ 开始计数）<br>
Q A B：输出 $[a, b]$ 中最长的连续递增子序列（LCIS）的长度</p>
<p>$[a, b]$ 中最长的连续递增子序列 $\neq$ $\text{MAX}$ ( 左区间 $max$，右区间 $max$ )<br>
有可能跨越左右两个区间，涉及区间合并的思想</p>
<p>对任意一个结点：<br>
$max$ 为当前结点综合整个区间得到的 LCIS 长度<br>
$lmax$ 为从当前结点最左端开始的 LCIS 长度；$rmax$ 为从当前结点最右端结束的 LCIS 长度</p>
<p>分类讨论：</p>
<ul>
<li>左区间最右边的值 $\ge$ 右区间最左边的值<br>
$max$ = $\text{MAX}$ ( 左区间 $max$，右区间 $max$)</li>
<li>左区间最右边的值 $&lt;$ 右区间最左边的值，即 $a[mid] &lt; a[mid + 1]$<br>
$lmax$ =（左区间 $lmax$ == 左区间长度 $llen$）? 左区间长度 $llen$ + 右区间 $lmax$ : 左区间 $lmax$<br>
$rmax$ =（右区间 $rmax$ == 右区间长度 $rlen$）? 右区间长度 $rlen$ + 左区间 $rmax$ : 右区间 $rmax$<br>
$max = \text{MAX}$ ( 左区间的 $max$，右区间的 $max$，左区间 $rmax$ + 右区间 $lmax$ )</li>
</ul>
<h3 id="线段树的优缺点"><a class="header-anchor" href="#线段树的优缺点">¶</a>线段树的优缺点</h3>
<p>优点：应用范围广，经常用于辅助实现其他算法的优化，并且可以完全代替树状数组</p>
<p>缺点：代码实现稍显麻烦</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>模电第三次作业</title>
    <url>/2020/04/24/%E6%A8%A1%E7%94%B5%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>使用教材：<br>
清华大学电子学教研组编 . 杨素行主编 . 模拟电子技术基础简明教程 . 3版 . 北京：高等教育出版社，2006.<br>
作业内容：<br>
模电作业是这样的：<br>
第五章是6 8 9 14题以及PPT上的一个图标出饱和区截止区和放大区<br>
27号前交</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="5-6"><a class="header-anchor" href="#5-6">¶</a>5-6</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-6-1.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-6-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p><strong>求静态工作点：</strong></p>
<p>由三极管基极回路可知：</p>
$V_{EE}=U_{BEQ}+R_1 \cdot I_{BQ}+2R_e \cdot I_{EQ}$
<p>估得： $U_{BEQ} \approx 0.7\ V$<br>
则有：<br>
静态基极电流为：</p>
$I_{BQ}={\dfrac {V_{EE}-U_{BEQ}}{R_1+2R_e(1+\beta)}}={\dfrac {15-0.7}{1.8k+2\times 56k\times (1+40)}}=3.112891\times 10^{-6}\ A\approx 3\ \mu A$
<p>静态集电极电流与电位（对地）：</p>
$I_{CQ}=(1+\beta)I_{BQ}\approx \beta I_{BQ}=120\ \mu A=0.12\ mA$<br>
$U_{CQ}=V_{CC}-I_{CQ}R_c-{\dfrac 1 2}R_WI_{CQ}=(15-0.12m\times 75.5k)\ V=5.94\ V$（对地）
<p>（ $R_W$ 的滑动端处于中点）</p>
<p>静态基极电位（对地）：</p>
$U_{BQ}=-R_1\cdot I_{BQ}=-1.8k\cdot 3\mu A=-5.4mV$（对地）
<p><strong>求差模放大倍数：</strong></p>
<p>根据交流通路可得：</p>
$\Delta i_{B1}={\dfrac {\Delta u_{I1}}{R_1+r_{be}}}, \ \ \ \ \Delta i_{C1}=\beta \Delta i_{B1}$
<p>则 $\Delta u_{C1}=-\Delta i_{C1}(R_c//{\dfrac {R_L} 2})=-{\dfrac {\beta (R'_{c1}//{\dfrac {R_L} 2})}{R_1+r_{be}}}\Delta u_{I1}$</p>
<p>同理：$\Delta u_{C2}=-\Delta i_{C2}(R_c//{\dfrac {R_L} 2})=-{\dfrac {\beta (R'_{c2}//{\dfrac {R_L} 2})}{R_2+r_{be}}}\Delta u_{I2}$</p>
<p>故输出电压为：$\Delta u_{O}=\Delta u_{C1}-\Delta u_{C2}=-{\dfrac {\beta (R'_{c}//{\dfrac {R_L} 2})}{R+r_{be}}}(\Delta u_{I1}-\Delta u_{I2})$</p>
<p>则差模电压放大倍数为：$A_d={\dfrac {\Delta u_{O}}{\Delta u_{I1}-\Delta u_{I2}}}=-{\dfrac {\beta (R'_{c}//{\dfrac {R_L} 2})}{R+r_{be}}}$</p>
<p>其中：$R_c=R_{c1}=R_{c2}=75\ k\Omega,\ \ \ \ R_W=1\ k\Omega$<br>
则 $R'_c=R'_{c1}=R'_{c2}=R_c+{\dfrac 1 2}R_W=75.5\ k\Omega$<br>
又有：$R=R_1=R_2=1.8\ k\Omega ,\ \ \ \ r_{be}=8.2\ k\Omega,\ \ \ \ R_L=30\ k\Omega$<br>
得：$A_d=-50$</p>
<p><strong>求输入电阻：</strong></p>
<p>从两管输入端向里看，差模输入电阻为：$R_{id}=2(R+r_{be})=2(1.8\ k\Omega +8.2\ k\Omega)=20\ k\Omega$</p>
<hr>
<h2 id="5-8"><a class="header-anchor" href="#5-8">¶</a>5-8</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-8-1.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-8-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>集电极回路加电位器调零比较简单，但静态调到零后，动态仍有可能不平衡；电位器的阻值较大，通常为几千欧至几十千欧。发射极加电位器调零由于引入负反馈，因此对静态和动态均有调零作用；所用电位器阻值较小，一般为几十欧至几百欧；但引入负反馈后使电压放大倍数有所下降。</p>
<hr>
<h2 id="5-9"><a class="header-anchor" href="#5-9">¶</a>5-9</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-9-1.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-9-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p><strong>估算静态工作点：</strong></p>
<p>静态分析：<br>
先确定恒流管的电流：<br>
当忽略 $VT3$ 的基流时，可得到 $R_{b1}$ 上的电压为：$U_{R_{b1}}={\dfrac {R_{b1}}{R_{b1}+R_{b2}}}(V_{CC}+V_{EE})\approx 3.3\ V$<br>
则恒流管的静态电流为：</p>
$I_{CQ3}\approx I_{EQ3}={\dfrac {U_{R_{b1}}-U_{BEQ3}}{R_e}}={\dfrac {3.3-0.7}{13k}}\ A=0.2\ mA$
<p>于是可以得到两个放大管的静态电流和电压为：</p>
$I_{CQ1}=I_{CQ2}\approx {\dfrac 1 2}I_{CQ3}=0.1\ mA$
<br>
$U_{CQ1}=U_{CQ2}=V_{CC}-I_{CQ1}R_{c1}=V_{CC}-I_{CQ2}R_{c2}=(9-0.1m\times 47k)\ V=4.3\ V$（对地）
<br>
$I_{BQ1}=I_{BQ2}={\dfrac {I_{CQ1}}{\beta}}={\dfrac {I_{CQ2}}{\beta}}={\dfrac {0.1\ mA}{30}}\approx 3.3\ \mu A=0.0033\ mA$
<br>
$U_{BQ1}=U_{BQ2}=-I_{BQ1}R_1==-I_{BQ2}R_2=-33\ mV$（对地）
<p><strong>估算差模电压放大倍数：</strong></p>
<p>由静态分析结果可得：</p>
$r_{be}=r_{bb'}+(1+\beta){\dfrac{U_T}{I_{EQ}}}=r_{bb'}+{\dfrac{U_T}{I_{BQ}}}=300\ \Omega + {\dfrac {26\ mV}{0.0033\ mA}} \approx 8178.79\ \Omega \approx 8.2\ k\Omega$
<p>对其进行动态分析，由其交流通路可得：</p>
$R'_L=R_{c}//{\dfrac {R_L} 2}=47\ k\Omega// 10 \ k\Omega={\dfrac {47\times 10}{47+10}}\ k\Omega \approx 8.25\ k\Omega$
<br>
$A_d={\dfrac {u_O}{u_{id}}}=-{\dfrac {2\beta i_BR'_L}{2i_B(R_1+r_{be})}}=-{\dfrac {\beta R'_L}{R_1+r_{be}}}=-{\dfrac {30\times 8.25}{10+8.2}}\approx -13.6$
<hr>
<h2 id="5-14"><a class="header-anchor" href="#5-14">¶</a>5-14</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-14-1.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/5-14-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p><strong>分析接法：</strong></p>
<p>差分输入级属于单端输入单端输出接法</p>
<p><strong>求第二级的集电极负载电阻 $R_{c3}$ ：</strong></p>
<p>恒流源电流为 $I=0.2\ mA$ ，则 $I_{CQ1}\approx 0.5I=0.5\times 0.2\ mA=0.1\ mA$</p>
<p>从图中可以看出：$R_{c1}$ 两端电压即为 $VT3$ 的 $U_{BEQ3}$（发射极与基极之间的电压）</p>
$I_{R_{c1}}={\dfrac {U_{BEQ3}}{R_{c1}}}={\dfrac {0.7}{10}}\ mA=0.07\ mA$
<p>分流（KCL）：</p>
$I_{BQ3}=I_{CQ1}-I_{R_{c1}}=(0.1-0.07)\ mA=0.03\ mA$
<br>
$I_{CQ3}=\beta I_{BQ3}=50\times 0.03\ mA=1.5\ mA$
<p>欲使 $u_I=0$ 时，$u_O=0$ ：<br>
则 $R_{c3}$ 上压降为 $V_{EE}$ ，$R_{c3}={\dfrac {V_{EE}}{I_{CQ3}}}={\dfrac {15}{1.5}}\ k\Omega=10\ k\Omega$</p>
<p><strong>分别估算第一级和第二级的电压放大倍数 $A_{u1}$ 和 $A_{u2}$ ，以及总的电压放大倍数 $A_u$：</strong></p>
<p>由其交流通路得：$A_{u1}=-{\dfrac 1 2}{\dfrac {\beta R'_L}{R+r_be}}=-{\dfrac 1 2}{\dfrac {\beta \times (R_{c1}//r_{be3})}{R+r_be}}=-{\dfrac 1 2}\times {\dfrac {50\times (10k//1.2k)}{1k+13.5k}}\approx -1.90$</p>
$A_{u2}=-{\dfrac {\beta R_{c3}}{r_{be3}}}=-{\dfrac {50\times 10}{1.2}}\approx -416.67$
<p>总的电压放大倍数为：$A_{u}=A_{u1}\cdot A_{u2}\approx791.67\approx 792$</p>
<hr>
<h2 id="附加题"><a class="header-anchor" href="#附加题">¶</a>附加题</h2>
<p>PPT上的一个图标出饱和区截止区和放大区</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/2-ppt-0.PNG" alt="avatar"></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%B8%89%EF%BC%89/2-ppt.PNG" alt="avatar"></p>
<hr>
<p>参考文献：<br>
模拟电子技术基础简明教程第3版及其教学指导书</p>
<hr>
]]></content>
      <tags>
        <tag>ANALOG</tag>
        <tag>作业区</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟与暴力</title>
    <url>/2022/06/22/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=2" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356465" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-模拟与暴力</a><br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>模拟 &amp;&amp; 暴力</h1>
<h2 id="模拟（implementation）"><a class="header-anchor" href="#模拟（implementation）">¶</a>模拟（implementation）</h2>
<h3 id="释义"><a class="header-anchor" href="#释义">¶</a>释义</h3>
<p>在自然界和日常生活中,许多现象具有不确定的性质，有些问题甚至很难建立数学模型，或者很难用计算机建立递推、递归、枚举、回溯法等算法。在这种情况下，一般采用模拟策略。所谓模拟策略就是模拟某个过程，通过改变数学模型的各种参数，进而观察变更这些参数所引起过程状态的变化，由此展开算法设计。</p>
<p>通俗的讲：<br>
  <strong>找不到更高效的做法时，题目怎么描述就让程序怎么运行</strong></p>
<h3 id="特点"><a class="header-anchor" href="#特点">¶</a>特点</h3>
<p>思考量不大，但阅读量和代码量可以很大<br>
可以很简单，也可以很复杂<br>
形式多样：走迷宫，斗地主，打麻将，打三国杀，魔塔…</p>
<p>注意：弄清题意，建立模型，注意细节</p>
<h3 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h3>
<h4 id="约瑟夫环"><a class="header-anchor" href="#约瑟夫环">¶</a>约瑟夫环</h4>
<p><strong>问题背景</strong></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">约瑟夫问题</a>（有时也称为约瑟夫斯置换，是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。又称“丢手绢问题”.）</p>
<p>据说著名犹太历史学家 Josephus 有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与 Josephus 及他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，每报数到第 3 人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而 Josephus 和他的朋友并不想遵从。首先从一个人开始，越过 k-2 个人（因为第一个人已经被越过），并杀掉第 k 个人。接着，再越过 k-1 个人，并杀掉第 k 个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus 要他的朋友先假装遵从，他将朋友与自己安排在第 16 个与第 31 个位置，于是逃过了这场死亡游戏。</p>
<p><strong>问题描述</strong></p>
<p>已知n个人（编号1、2、…n）围坐在一张圆桌周围。从编号为1的人开始报数，数到m的那个人出列；他的下一个又从1开始报数，数到m的那个人又出列；依次规律重复下去，直到圆桌周围的人全部出列。给定n、m，输出出列人员先后顺序和最后剩下的人。</p>
<p><strong>实现</strong></p>
<blockquote>
<p>数组实现：<br>
利用公式 (p+m-1)%n ，找出要输出数组的下标<br>
其中 p 为开始报数的人的编号，n 为当前剩下的人数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Joseph</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>], k = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        a[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (p + m - <span class="number">1</span>) % n;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; ++k &lt;&lt; <span class="string">"个出圈的是："</span> &lt;&lt; a[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = p + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span>(p == n) p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最后剩下的是："</span> &lt;&lt; a[p] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/Joseph.PNG" alt="avatar"></p>
<h4 id="Online-judge-HDU-1073"><a class="header-anchor" href="#Online-judge-HDU-1073">¶</a>Online judge <a href="https://vjudge.net/problem/HDU-1073" target="_blank" rel="noopener">HDU-1073</a></h4>
<p>给定两个输入，分别表示用户的输出和正确的输出，你来模拟测评机，对两个输出进行比较<br>
完全相同输出 “Accepted”<br>
只有空格，tab，回车的不同，输出 “Presentation Error”<br>
否则输出 “Wrong Answer”</p>
<p><strong>Presentation Error</strong><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/PE.PNG" alt="avatar"></p>
<p><strong>Wrong Answer</strong><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/WA.PNG" alt="avatar"></p>
<p><strong>分析</strong></p>
<p>直接模拟比较过程即可</p>
<p>先将输入的两组数据去掉 ‘\n’,’\t’ 和 ’ ’ ，得到新的两组数据，那么这两组数据如果不是完全匹配的，结果一定是 WA 。如果这两组匹配了，去掉 ‘\n’,’\t’ 和 ’ ’ 前的不完全匹配则是 PE 。如果去掉前的两组数据完全匹配，则是 AC 。</p>
<h4 id="False-Coin-POJ-1029"><a class="header-anchor" href="#False-Coin-POJ-1029">¶</a>False Coin <a href="https://vjudge.net/problem/POJ-1029" target="_blank" rel="noopener">POJ-1029</a></h4>
<p>给你n个硬币，k组称量结果。在这n个硬币中有一个是假的，它的重量跟其他的不一样（不知道大小），真硬币的重量都相同，每组第一个数字代表左右放置硬币的数量，后面则是硬币的编号，每组后面的符号则是称量结果。问能不能确定哪个是假币，如果不能输出0。</p>
<p><strong>Sample Input</strong><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/FalseCoin1.PNG" alt="avatar"></p>
<p><strong>Sample Onput</strong><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/FC2.PNG" alt="avatar"></p>
<p><strong>分析</strong></p>
<p>结果为等号两边一定是真硬币，结果为不等号肯定含有假硬币<br>
所以对于所有的不等式，将轻硬币放在 <strong>lightCoins</strong> 里，将重硬币放在 <strong>heavyCoins</strong> 里<br>
因为只有一个假硬币，且假硬币不会一会儿轻，一会儿重，所以最后假硬币出现在 lightCoins 或者 heavyCoins 的次数一定和不等号出现的次数相等<br>
若恰有一个满足条件的疑似硬币，则输出</p>
<h4 id="Lytchen-loves-JSON"><a class="header-anchor" href="#Lytchen-loves-JSON">¶</a>Lytchen loves JSON</h4>
<p>本题来自：<a href="http://codeforces.com/gym/102426" target="_blank" rel="noopener">The 7-th BIT Campus Programming Contest for Junior Grade Group</a></p>
<p><strong>很大的大模拟</strong><br>
你需要编写一个程序，这个程序以一个合法的JSON文件作为输入，然后响应一系列查询，每个查询均会要求查询在这个JSON文档所包含的对象图上的一个值。</p>
<p><s>有兴趣可以自行体验</s></p>
<hr>
<h2 id="暴力（brute-force）"><a class="header-anchor" href="#暴力（brute-force）">¶</a>暴力（brute force）</h2>
<h3 id="释义-v2"><a class="header-anchor" href="#释义-v2">¶</a>释义</h3>
<p>暴力是什么？</p>
<p>暴力就是<strong>枚举</strong>，指的是从问题所有可能的解的集合中一一枚举各元素，用题目中给定的检验条件判定哪些是无用的，哪些是有用的。能使命题成立，即为其解。</p>
<h3 id="特点-v2"><a class="header-anchor" href="#特点-v2">¶</a>特点</h3>
<p>优点是算法简单，在局部地方使用枚举法，效果会十分的好<br>
缺点是运算量过大，当问题的规模变大的时候，循环的阶数越大，执行速度越慢，计算量容易过大，可能获得一个TLE<br>
所以需要先计算时间复杂度，并对其进行优化<br>
<strong>一般直接暴力是不行的，需要有一些小小的优化</strong></p>
<h3 id="时间复杂度"><a class="header-anchor" href="#时间复杂度">¶</a>时间复杂度</h3>
<p>时间复杂度：估算算法需要执行的运算次数<br>
题目通常有时间限制，一秒、两秒、五秒、十秒等<br>
计算机一秒能够进行的运算次数约为 $1e8$ 次<br>
一次运算：赋值、比较、加减乘除模等运算，虽然实际运算时间不一样，但都可以近似看做一次运算<br>
时间复杂度表达为 $O(f(n))$，$f(n)$ 是运算次数，关于问题规模 $n$ 的函数</p>
<p>由于近似性，可以忽略常数和低次项<br>
$f(n)=n^2+3n+ \log_{2}(n)+4$ 与 $f(n)=n^2+3n+ \log_{2}(n)+1$ 运算次数不同，但时间复杂度相同，都为 $O(n^2)$</p>
<p>简单的例子：</p>
<blockquote>
<p>求下列程序的时间复杂度</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;)</span><br><span class="line">&#123;</span><br><span class="line">    i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(\log_{2}n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i;)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n;)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> * m;)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n+m)$</p>
<h3 id="例题-v2"><a class="header-anchor" href="#例题-v2">¶</a>例题</h3>
<h4 id="一个简单的例子"><a class="header-anchor" href="#一个简单的例子">¶</a>一个简单的例子</h4>
<p>已知 $S_n=1+1/2+1/3+…+1/n$. 给出一个整数 $k(1\le k\le 15)$ 计算出一个最小的 $n$，使得 $S_n&gt;k$.</p>
<p>分析：<br>
$S_n$ 为无穷级数，不收敛，对于任意 $k$ 总能找到一个 $S_n&gt;k$<br>
写一个程序算一下发现 $S_{1835421}&gt;15$，不用担心超时<br>
所以直接暴力即可</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="number">1.0</span> / i;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; k) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果每个用例有 $q(1\le q\le 100000)$ 次询问呢？<br>
每次都重新算太费时间，预处理！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)   ans[i] = query(i);</span><br></pre></td></tr></table></figure>
<h4 id="百钱买百鸡问题"><a class="header-anchor" href="#百钱买百鸡问题">¶</a>百钱买百鸡问题</h4>
<p>有一个人有100块钱，打算买100只鸡<br>
到市场一看，公鸡一只三元，母鸡一只五元，小鸡三只一元<br>
试求用100元买100只鸡，各为多少才合适？输出所有方案</p>
<p>分析：</p>
<p>根据题意我们可以得到方程组：</p>
<p>$3X+5Y+Z/3=100$</p>
<p>$X+Y+Z=100$</p>
<p>问题转化为求不定方程的非负整数解</p>
<p>解法1：for for for 枚举x，y，z，然后check              $O(n^3)$<br>
解法2：for for 枚举x，y，让 $z=100-x-y$ ，然后check方程一   $O(n^2)$<br>
解法3：for 枚举x，把x看作已知，解出y，z              $O(n)$</p>
<p>解法3代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">25</span>; x++)   <span class="comment">//注意x，y，z的取值范围</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">200</span> - <span class="number">8</span> * x) % <span class="number">14</span> == <span class="number">0</span> &amp;&amp; ( <span class="number">1200</span> - <span class="number">6</span> * x ) % <span class="number">14</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;(<span class="number">200</span> - <span class="number">8</span> * x) / <span class="number">14</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;( <span class="number">1200</span> - <span class="number">6</span> * x ) / <span class="number">14</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/chicken.PNG" alt="avatar"></p>
<h4 id="Division-Uva-725"><a class="header-anchor" href="#Division-Uva-725">¶</a>Division <a href="https://vjudge.net/problem/UVA-725" target="_blank" rel="noopener">Uva-725</a></h4>
<p>输入正整数 $n（2\le n\le 79$），按照从小到大的顺序输出所有形如 $abcde/fghij=n$ 的表达式，其中a~j恰好为数字0到9的一个排列（可以有前导0）<br>
Sample Input：$62$<br>
Sample Output：$79546/01283 = 62$  $94736/01528 = 62$</p>
<p>分析:</p>
<p>可不可以枚举0到9的所有排列？<br>
一共需要 $10！=3628800$ 可以接受，但是没必要<br>
只需枚举fghij就可以算出abcde，再判断是否所有数字都不相同即可（对于判重存在多种方法）<br>
枚举次数减少到一万以内</p>
<p><a href="https://blog.csdn.net/qq_40738840/article/details/104440707" target="_blank" rel="noopener">点这里传送到大佬的题解</a></p>
<p><strong>大佬提示的注意点：</strong><br>
可用sprintf完成数值到字符串的格式转换，注意string此时不可直接作为接受字符串，需用字符数组</p>
<p><strong>大佬的代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) == <span class="number">1</span> &amp;&amp; N != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">""</span>); num++; <span class="comment">// 连续的测试用例间需有空行</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>]; <span class="built_in">string</span> s; <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fj=<span class="number">1234</span>; ; fj++) &#123; <span class="comment">// 枚举1234 - 98765</span></span><br><span class="line">            <span class="built_in">sprintf</span>(buf, <span class="string">"%05d%05d"</span>, fj*N, fj); <span class="comment">// 分子，分母转为字符串</span></span><br><span class="line">            s = buf;</span><br><span class="line">            <span class="keyword">if</span> (s.size() &gt; <span class="number">10</span>) <span class="keyword">break</span>; <span class="comment">// 其中一个超过5位数</span></span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; _set(s.begin(), s.end()); <span class="comment">// 判重</span></span><br><span class="line">            <span class="keyword">if</span> (_set.size() == <span class="number">10</span>) &#123; <span class="comment">// 刚好整除且无重复数字</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s / %s = %d\n"</span>, s.substr(<span class="number">0</span>,<span class="number">5</span>).c_str(), s.substr(<span class="number">5</span>).c_str(), N);</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"There are no solutions for %d.\n"</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Four-Operations-HDU-5938"><a class="header-anchor" href="#Four-Operations-HDU-5938">¶</a>Four Operations <a href="https://vjudge.net/problem/HDU-5938" target="_blank" rel="noopener">HDU-5938</a></h4>
<p>给定一个全是数字的字符串（长度为 $5$ 到 $20$），按照顺序加入 $‘+’、‘-’、‘*’、‘/’$ 四个运算符<br>
求最大的计算结果，有 $q$ 组询问$（1\le q\le 100000）$</p>
<p>Sample Input：12345<br>
Sample Output：1</p>
<p>分析：</p>
<p>直接暴力会超时，约 $20^4$ 种情况<br>
计算形式总是 $a+b-c*d/e$，我们希望a、b、e大一些，c和d小一些<br>
给c和d各一位，给e一位或两位，a和b中的一个拿一位，另一个拿光<br>
共枚举4种情况即可</p>
<h4 id="白学串"><a class="header-anchor" href="#白学串">¶</a>白学串</h4>
<p>本题也来自：<a href="http://codeforces.com/gym/102426" target="_blank" rel="noopener">The 7-th BIT Campus Programming Contest for Junior Grade Group</a></p>
<p>给定一个n个数的数字序列，每个数不超过 $1e9$ 有 $q$ 次询问，每次询问一个区间是否存在三个数可以组成一个三角形，输出YES或NO $（1\le q\le 100000）$</p>
<p>分析：</p>
<p>不难发现，一组数不能构成三角形的充要条件是排完序后的任意三个相邻的数构不成三角形<br>
换句话说，要写出尽可能多的数就要让相邻的三个数刚好构不成三角形<br>
不能构成三角形的极限情况，就是 <strong>斐波那契数列</strong><br>
$1，1，2，3，5，8，13，21…$<br>
而斐波那契数列增长很快，约第40项就达到了 $1e9$ ，而题目给的数不超过 $1e9$<br>
所以当区间长度超过40，直接输出YES，否则排序后判断或直接暴力</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>模电第二次作业</title>
    <url>/2020/04/03/%E6%A8%A1%E7%94%B5%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>使用教材：<br>
清华大学电子学教研组编 . 杨素行主编 . 模拟电子技术基础简明教程 . 3版 . 北京：高等教育出版社，2006.<br>
作业内容：<br>
P101<br>
5, 6, 10, 11, 16, 18, 22, 25<br>
加一道题：3-7</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="2-5"><a class="header-anchor" href="#2-5">¶</a>2-5</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-5.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>由直流通路可得：<br>
$V_{CC}=(I_{BQ}+I_{CQ})R_{c}+R_{b}I_{BQ}+U_{BEQ}$<br>
则有：</p>
$I_{BQ}={V_{CC}-U_{BEQ} \over (1+\beta)R_c+R_b}\approx0.027$ mA，$I_{CQ}\approx2.7$ mA
<p>那么：<br>
$U_{CEQ}=V_{CC}-(I_{CQ}+I_{BQ})R_c\approx3.819$ V</p>
<hr>
<h2 id="2-6"><a class="header-anchor" href="#2-6">¶</a>2-6</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-6-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-6-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>用图解法求电路的静态工作点：<br>
即在三极管的输出特性曲线上绘制直流负载线：<br>
$u_{CE}=V_{CC}-i_CR_c$<br>
其中：$V_{CC}=10$V $R_c=10k\Omega$<br>
则有：$u_{CE}=10-10i_C$ 与 $i_B=20\mu$A 的一条特性曲线交于点 $Q_1$<br>
可以估算 $I_{BQ}$：设$U_{BEQ}=0.7$V</p>
$I_{BQ}={V_{CC}-U_{BEQ} \over R_b}\approx20\mu$A
<p>$Q_1$ 即为此时的静态工作点，此时的$U_{CEQ}=u_{CE}\approx0.5$V，$I_{CQ}=i_C\approx0.95$ mA<br>
从图中即可看出，这个静态工作点$Q_1$靠近饱和区，容易产生失真，选得并不合适。<br>
<br></p>
<p>为将 $U_{CEQ}$ 提高到 $5$V 左右，需将 $R_c$ 与 $R_b$ 同时减小。<br>
<br></p>
<p>由$I_{CQ}=2$ mA，$U_{CEQ}=2$ V：<br>
直流负载线：$u_{CE}=V_{CC}-i_CR_c$， $R_c={V_{CC}-U_{CEQ} \over I_{CQ}}={10-2 \over 2}k\Omega=4k{\Omega}$<br>
由直流负载线与三极管的输出特性曲线的交点可得:<br>
$I_{BQ}=40\mu$A<br>
则有：$R_b={V_{CC}-U_{BEQ} \over I_{BQ}}={10-0.7 \over 40{\cdot}10^{-3}}k\Omega\approx250k\Omega$</p>
<hr>
<h2 id="2-10"><a class="header-anchor" href="#2-10">¶</a>2-10</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-10-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-10-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>估算静态工作点：<br>
设 $U_{BEQ}=0.7$V<br>
则：$I_{BQ}={V_{CC}-U_{BEQ} \over R_b}={6-0.7 \over 530}$ mA $=0.01$ mA<br>
$I_{CQ}={\beta}I_{BQ}=0.6$ mA， $U_{CEQ}={V_{CC}-I_{CQ}R_c}=(6-0.6\times5)$ V $=3$ V 即有 $U_{CEQ}\approx3$ V</p>
<p>求$r_{be}$值：<br>
$I_{EQ}=(1+\beta)I_{BQ}=0.61$ mA</p>
$r_{be}=r_{bb'}+(1+\beta){U_T \over I_{EQ}}$
<p>$r_{bb’}$ 约为 $300\Omega$， $U_T\approx26$ mA，<br>
则 $r_{be}=300\Omega + (1+60){26 \over 0.61}\Omega=0.3k\Omega+2.6k\Omega=2.9k\Omega$</p>
<p>求电压放大倍数$\dot {A_u}$，输入电阻$R_i$和输出电阻$R_o$：</p>
$\dot{A_u}={\dot{u_o} \over \dot{u_i}}={-i_C{\cdot}R_L//R_c \over i_B{\cdot}r_{be}}={{-\beta}{\cdot}R_L//R_c \over r_{be}}\approx-51.72$
$R_i=R_b//r_{be}={2.9k\cdot5k \over 2.9k+5k}\Omega\approx1.84k\Omega$
<p>$R_o=R_c=5k\Omega$</p>
<hr>
<h2 id="2-11"><a class="header-anchor" href="#2-11">¶</a>2-11</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-11.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>首先应当估算静态工作点即Q点：<br>
由三极管的输出特性曲线可得：<br>
$\beta={i_C \over i_B}={12mA \over 80\mu A}=150$<br>
设 $U_{BEQ}=0.7$ V<br>
则由直流通路可得：</p>
$V'_{CC}={R_{b1} \over R_{b1}+R_{b2}}V_{CC}$
<p>$R_{b1}//R_{b2}{\cdot}I_{BQ}+R_eI_{EQ}+U_{BEQ}=V’_{CC}$</p>
<p>求得：$I_{BQ}={V'_{CC}-U_{BEQ} \over R_{b1}//R_{b2}+(1+\beta)R_e}$</p>
<p>将数据代入得到：$V’_{CC}={2.5k \over 2.5k+10k}\cdot 15$V $=3$ V</p>
<p>$I_{BQ}\approx19.96 \mu $A $\approx20 \mu $A</p>
<p>又有：$I_{EQ}=(1+\beta)I_{BQ}$</p>
$r_{be}=r_{bb'}+(1+\beta){U_T \over I_{EQ}}$， $r_{bb'}\approx300\Omega$
<p>则可得出：$r_{be}\approx1.6k\Omega$</p>
$\dot {A_u}={\dot{u_o} \over \dot{u_i}}={-i_C{\cdot}R_L//R_c \over i_B{\cdot}r_{be}}={{-\beta}{\cdot}R_L//R_c \over r_{be}}={-150\times1.5k\Omega//2k\Omega \over 1.6k\Omega}\approx-80.36$
<p>$R_i=r_{be}//R_b1//R_b2\approx0.89k\Omega$</p>
<p>$R_o=R_c=2k\Omega$</p>
<hr>
<h2 id="2-16"><a class="header-anchor" href="#2-16">¶</a>2-16</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-16-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-16-2.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-16-3.PNG" alt="avatar"></p>
<p>求解如下：<br>
<br>1.</p>
$I_{BQ}={V_{CC}-U_{BEQ} \over R_b+(1+\beta)R_e}={12-0.7 \over 560+101\times5.6}$ mA $\approx0.01$ mA
<p>$I_{EQ}=(1+\beta)I_{BQ}\approx1.01$ mA</p>
<p>$U_{CEQ}=V_{CC}-I_{EQ}R_e\approx6.4$ V<br>
<br>2.</p>
$\dot{A_u}={(1+\beta)R'_e \over r_{be}+(1+\beta)R'_e}$， 其中 $R'_e=R_e//R_L$
$r_{be}=r_{bb'}+(1+\beta){U_T \over I_{EQ}}=2.9k\Omega$
<p>当 $R_L=\infty$ 时，$R’_e=R_e//R_L=5.6k\Omega$<br>
可得：$\dot{A_u}\approx0.99$</p>
<p>当 $R_L=1.2k\Omega$ 时，$R'_e=R_e//R_L=0.99k\Omega$<br>
可得：$\dot{A_u}\approx0.97$<br>
<br>3.</p>
$R_i=[r_{be}+(1+\beta)R'_e]//R_b$
<p>当 $R_L=\infty$ 时，<br>
可得：$R_i\approx282k\Omega$</p>
<p>当 $R_L=1.2k\Omega$ 时，<br>
可得：$R_i\approx87k\Omega$<br>
<br>4.</p>
$R_o={r_{be}+R'_s \over 1+\beta}//R_e\approx29\Omega$
<hr>
<h2 id="2-18"><a class="header-anchor" href="#2-18">¶</a>2-18</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-18.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>对共基极放大电路进行静态分析：</p>
$I_{EQ}={U_{BQ}-U_{BEQ} \over R_e}\approx{1 \over R_e}\cdot(U_{BQ}-U_{BEQ})={1 \over R_e}\cdot({R_{b1} \over R_{b1}+R_{b2}}V_{CC}-U_{BEQ})\approx I_{CQ}$
<p>（由于静态基极电流极小，相对于 $R_{b1}$ 、$R_{b2}$ 分压回路中的电流可以忽略不计）<br>
其中：<br>
$U_{BEQ}=0.6$ V， $\beta=50$， $r_{bb’}=300\Omega$<br>
若要求$I_{EQ}=2$ mA<br>
则：</p>
$R_e={1 \over I_{EQ}}\cdot ({R_{b1} \over R_{b1}+R_{b2}}V_{CC}-U_{BEQ})={1 \over 2\times 10^{-3}}(3-0.6)\Omega=1.2k\Omega$
<p>发射极电阻 $R_e$ 应选$1.2k\Omega$</p>
<p>估算$I_{BQ}$ 与 $U_{CEQ}$：</p>
$I_{BQ}={I_{EQ} \over (1+\beta)}={2mA \over (1+50)}\approx 0.04$ mA
<p>$U_{CEQ}=V_{CC}-I_{CQ}R_c-I_{EQ}R_e\approx V_{CC}-I_{EQ}(R_c+R_e)=[15-2\times (3+1.2)]$ V $=6.6$ V</p>
<p>求 $\dot{A_u}$， $R_i$ 与 $R_o$：</p>
$r_{be}=r_{bb'}+(1+\beta){U_T \over I_{EQ}}\approx 300\Omega+(1+50){26mA \over 2mA}=963\Omega = 0.963k\Omega$<br>
$\dot {A_u}={\dot{u_o} \over \dot{u_i}}={\beta {\cdot}R_L//R_c \over r_{be}}\approx77.88\approx77.9$<br>
$R_i={r_{be} \over (1+\beta)}//R_e\approx 0.0186k\Omega \approx 18.6\Omega$<br>
$R_o=r_{cb}//R_c\approx R_c=3k\Omega$
<hr>
<h2 id="2-22"><a class="header-anchor" href="#2-22">¶</a>2-22</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-22-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-22-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>对源极输出器做静态分析：<br>
由于MOS场效应管的栅极电流几乎为零，即可认为 $R_g$ 上无电压降，又因为静态漏极电流流过电阻 $R_s$ 产生一个自偏压，则有：<br>
$U_{GSQ}=V_{GG}-I_{DQ}R_s$<br>
N沟道增强型MOSFET的漏极电流 $i_D$ 与栅极电压 $u_{GS}$ 之间近似满足：</p>
$i_D=I_{DO}{({u_{GS} \over U_{GS(th)}}-1)}^2$ （ 当 $u_{GS}\ge U_{GS(th)}$ ）
<p>则有：</p>
$I_{DQ}=I_{DO}{({U_{GSQ} \over U_{GS(th)}}-1)}^2$
<p>联立方程可得，静态漏极电流 $I_{DQ}$ 有两个解：<br>
$I_{DQ1}=0.27mA$，$I_{DQ2}=0.67mA$</p>
<p>则可求得静态栅极电压为：<br>
$U_{GSQ1}=V_{GG}-I_{DQ1}R_s=2.73V$<br>
$U_{GSQ2}=V_{GG}-I_{DQ2}R_s=0.85V$</p>
<p>又因为 $U_{GSQ2}&lt;U_{GS(th)}$，舍去 $U_{GSQ2}$：<br>
$I_{DQ}=0.27mA$， $U_{GSQ}=2.73V$</p>
<p>静态漏极电压为：<br>
$U_{DSQ}=V_{DD}-I_{DQ}R_S=(20-2\times 4.7)$ V $=10.6$ V</p>
<p>对源极输出器做动态分析：<br>
场效应管的跨导：</p>
$g_m={2 \over U_{GS(th)}}\sqrt {I_{DO}I_{DQ}}=0.735$ mS
<p>由场效应管的微变等效电路可知：</p>
$\dot{A_u}={\dot{u_o} \over \dot{u_i}}={g_m\dot U_{gs}R_s \over g_m\dot U_{gs}R_s+\dot U_{gs}}={g_mR_s \over 1+g_mR_s}\approx 0.78$
<p>采用外加电压源的方法求 $R_o$：</p>
$R_o={\dot U_o \over \dot I_o}={1 \over g_m+{1 \over R_s}}={1 \over g_m}//R_s\approx 1.05k\Omega$
<hr>
<h2 id="2-25"><a class="header-anchor" href="#2-25">¶</a>2-25</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-25-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-25-2.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-25-3.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>1.估算 $R_i$ 和 $R_o$：<br>
根据习题2-25电路图绘出其交流通路：<br>
从 $R_{b1}$ 向右看：用外加电源法可求得 $R'_i$：<br>
设外加电源的电压为 $U’$，经过外加电源的电流为 $I’$，<br>
由基尔霍夫电压定律可求得 $U'=I'\cdot r_{be1}+(1+\beta_1)I'\cdot R'_{e1}$<br>
其中：$R'_{e1}=R_{e1}//R_{b21}//R_{b22}//r_{be2}$<br>
解得：$R'_i={U' \over I'}=r_{be1}+(1+\beta_1)R'_{e1}\approx 303.6k \Omega$<br>
则可求得输入电阻：$R_i=R'_i//r_{b1}\approx 252.5k \Omega$<br>
输出电阻：$R_o=R_{c2}=12k \Omega$</p>
<p>2.设 $R_L=\infty$，分别求出当 $R_s=0$ 和 $R_s=20k \Omega$ 时的 $\dot A_{us}$：</p>
<p>当 $R_s=0$ 时，</p>
$\dot A_{u1}={\dot U_{o1} \over \dot U_{i1}}={(1+\beta_1)i_{B1}R'_{e1} \over i_{B1}r_{be1}+(1+\beta_1)i_{B1}R'_{e1}}={(1+\beta_1)R'_{e1} \over r_{be1}+(1+\beta_1)R'_{e1}}\approx {298 \over 303.6}\approx 0.98$<br>
$\dot A_{u2}={\dot U_{o2} \over \dot U_{i2}}={-\beta_2{\cdot}R_L//R_{c2} \over r_{be2}}=-{100\times 12 \over 6.2}\approx -193.5$<br>
<p>$\dot A_{us}=\dot A_{u1}{\cdot}\dot A_{u2}=0.98\times (-193.5)=-189.6$</p>
<p>当 $R_s=20k\Omega$ 时，</p>
$\dot A_{us}={\dot U_o \over \dot U_s}={\dot U_o \over \dot U_i}{\cdot}{\dot U_i \over \dot U_s}$， 其中：${\dot U_o \over \dot U_i}=\dot A_u$（即当 $R_s=0$ 时得到的$\dot A_{us}$）
<p>${\dot U_i \over \dot U_s}={R_i \over R_i+R_s}$</p>
<p>那么则有： $\dot A_{us}=\dot A_u{\cdot}{R_i \over R_i+R_s}=(-189.6){\cdot}{252.5 \over 252.5+20}\approx -175.7$</p>
<p>$R_s$ 从 $0$ 改变为 $20k\Omega$ ： 第二种方法（跟它硬刚？）</p>
<p>不妨设电流 $i_{B1}=1$：<br>
则加在 $R_{b1}$ 上的电压为：$303.6k$， 流经它的电流为：$0.2024$<br>
则：流经 $R_s$ 的电流为：$1.2024$<br>
$U_s=i_sR_s+i_sR_i=272.5k\times 1.2024=327654$</p>
$i_{E1}=(1+\beta_1)i_{B1}=101$<br>$U'_{e1}=i_{E1}R'_{e1}=298k$
<p>则：$i_{B2}=298k/6.2k=48.06$， $i_{C2}=100\times 48.06=4806$</p>
$U_o= 12k\times(-4806)=-57672000$<br>
$\dot A_{us}={\dot U_o \over \dot U_s}\approx -176$
<p>3.当 $R_s=20k\Omega$ 时，去掉射极输出器：</p>
<p>$R_i=R_{b21}//R_{b22}//r_{be2}\approx 4.86k\Omega$</p>
<p>$\dot A_{us}={4.86 \over 4.86+20}\times (-193.5)\approx -37.8$</p>
<p>与第二小题的计算结果相比，放大倍数急剧缩小，输入电阻也急剧缩小，可以看出将射极输出器作为输入级的好处。</p>
<blockquote>
<p>下图是老师给的 2-25题 交流等效电路图</p>
</blockquote>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/2-25-4.PNG" alt="avatar"></p>
<hr>
<h2 id="3-7"><a class="header-anchor" href="#3-7">¶</a>3-7</h2>
<p>乱入一道第三章的题：</p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/3-7-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%8C%EF%BC%89/3-7-2.PNG" alt="avatar"></p>
<p>求解如下：</p>
<p>根据本题所给电路分别绘出其交流通路的低频段与高频段的等效电路：</p>
<p>在低频段时：<br>
将 $C_2$ 视为下一级电路的耦合电容<br>
对 $C_1$ 构成的高通电路进行分析：<br>
等效电阻为： $R_{eq}=R_b//r_{be}$<br>
由于 $R_b>>r_{be}$<br>
则有：$R_{eq}\approx r_{be}=1.6k\Omega$<br>
则可求得时间常数为：$\tau_L=R_{eq}C_1=0.016$ S<br>
那么下限截止频率为：$f_L={1 \over 2\pi\tau_L}\approx9.95$ Hz</p>
<p>在高频段时：<br>
$C_1$ 与 $C_2$ 均视为短路<br>
对 $C’$ 构成的低通电路进行分析：</p>
$C'=C_{b'e}+(1-\dot{K})C_{b'c}={g_m \over 2\pi f_T}+(1+g_mR_c)C_{b'c}\approx85\times10^{-11}$ F
<p>等效电阻为：$R=r_{bb'}//r_{b'e}=(300//1300)\Omega \approx 243.75\Omega$<br>
根据 $f_H={1 \over 2\pi \tau_H}$， $\tau_H=RC'$<br>
得到上限截止频率为：$f_H\approx 768.168$ kHz</p>
<hr>
<p>参考文献：<br>
模拟电子技术基础简明教程第3版及其教学指导书</p>
<hr>
]]></content>
      <tags>
        <tag>ANALOG</tag>
        <tag>作业区</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习讲义</title>
    <url>/2021/02/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%B2%E4%B9%89/</url>
    <content><![CDATA[<h1>Stanford CS229: Machine Learning (Autumn 2018)</h1>
<h2 id="Lecture-1-Welcome"><a class="header-anchor" href="#Lecture-1-Welcome">¶</a>Lecture 1 - Welcome</h2>
<h3 id="Machine-Learning-Definition"><a class="header-anchor" href="#Machine-Learning-Definition">¶</a>Machine Learning Definition</h3>
<ul>
<li>Arthur Samuel (1959). Machine Learning:<br>
Field of study that gives computers the ability to learn without being explicitly programmed.</li>
<li>Tom Mitchell (1998) Well-posed Learning Problem:<br>
A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measure by P, improves with experience E.<a id="more"></a></li>
</ul>
<h3 id="Supervised-Learning"><a class="header-anchor" href="#Supervised-Learning">¶</a>Supervised Learning</h3>
<p>The most widely used machine learning tool today is supervised learning.<br>
One Example: a database of housing prices</p>
<div align=center><img width = '600' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/Housing_prices_table.PNG"/></div>
<p>We can plot this data:</p>
<div align=center><img width = '900' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/Housing_prices_map.PNG"/></div>
<p>Given this dataset, one thing you can do is, um, fit a straight line to it. And then you could estimate or predicts the price to be whatever value you read off on the, um, vertical axis.</p>
<p>So in supervised learning, you are given a dataset with inputs X and labels Y, and you goal is to learn a mapping from X to Y.</p>
<p>Now, fitting a straight line to data is maybe the simplest possible learning algorithm. Given a dataset like this, there are many possible ways to learn a mapping, to learn the function mapping from the input size to estimated price. And so, maybe you wanna fit a quadratic function instead, maybe that actually fits the data a little better.</p>
<p>To define a few more things, this example is a problem called a <strong>regression</strong> problem. And the term regression refers to that the value y you’re trying to predict is continuous.</p>
<p>In contrast, here’s a different type of problem. It was a healthcare problem. They were looking at breast cancer or breast tumors, and trying to decide if a tumor is benign or malignant. A tumor is a lump in a woman’s breast and it can be malign or cancerous, or benign meaning roughly it’s not that harmful.</p>
<div align=center><img width = '500' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/tumor.PNG"/></div>
<p>So this is an example of a <strong>classification</strong> problem and the term classification refers to that Y here takes on a discrete number of variables. For a regression problem, Y is a real number. So we call housing price prediction to be a regression problem, whereas if you have two values of possible output, 0 and 1, call it a classification problem. Um, if you have K discrete outputs, that’s also a classification problem.</p>
<p>Now, I wanna find a different way to visualize this dataset. Let me draw a line on top and map all this data on the horizontal axis upward onto a line. And I use O’s to denote negative examples and I use crosses to denote positive examples.</p>
<div align=center><img width = '500' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/tumor_line.PNG"/></div>
<p>For most of machine learning applications you work with, the input X will be multi-dimensional. You won’t be given just one number and asked to predict another number. Instead, you’ll often be given multiple features and multiple numbers to predict another number. So for example, instead of just using a tumor size to predict- to estimate malignant versus benign tumors, you may have two features where one is tumor size and the second is age of the patient, and be given a dataset that looks like that. where now you task is given two input features, you know, like a two-dimensional vector, to predict whether a given tumor is malignant or benign.</p>
<div align=center><img width = '500' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/tumor_age_size.PNG"/></div>
<p>So if a new patient walks in a doctor’s office and that the tumor size is here and the age is here, so that point there, then hope you can conclude that, you know, this patient’s tumor is probably benign, right? Corresponding the O, that negative example.</p>
<div align=center><img width = '500' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/tumor_new_patient.PNG"/></div>
<p>And so, one thing you’ll learn next week is a learning algorithm(the logistic regression algorithm) that can fit a straight line to the data as follows, kinda like that, to separate out the positive and nagative examples.</p>
<div align=center><img width = '500' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/tumor_algorithm.PNG"/></div>
<p>For an actual breast cancer prediction problem, were using many other features such as clump thickness, uniformity of cell size, uniformity of cell shape, adhesion … A lot more features than just two, which means that you actually can’t plot this data.</p>
<p>you’ll also learn about an algorithm called the <strong>Support Vector Machine</strong> which uses not one or two or three or 10 or 100 or a million input features, but uses an infinite number of input features(infinite-dimensional vector) to represent a patient.</p>
<p>At the heart of supervised learning is the idea that during training, you are given inputs X together with the labels Y and You give it both at the same time, and the job of you algorithm is to find a mapping so that given a new X, you can map it to the most appropriate output Y.</p>
<h3 id="Unsupervised-Learning"><a class="header-anchor" href="#Unsupervised-Learning">¶</a>Unsupervised Learning</h3>
<p>Unsupervised learning is that giving you a dataset with no labels, which means you’re just given inputs X and no Y, and you’re asked to find me something interesting in this data, figure out interesting structure in this data.</p>
<div align=center><img width = '500' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/unsupervised.PNG"/></div>
<p>Clustering Algorithm:<br>
Organize computing clusters, figure out what machines workflows are more related to each other and organize computing clusters appropriately<br>
Social network like Linkedln or Facebook or other social networks and figure out which are the groups of friends and which are the cohesive communities within a social network<br>
Market segmentation, look at the customer database and cluster the users together<br>
Astronomical data analysis, group together galaxies</p>
<p>Cocktail party problem:<br>
How can you have an algorithm separate out these voices so you get clean recordings of just one voice at a time. The algorithm you use to do this is called ICA, independent Components Analysis.</p>
<h3 id="Something-Else"><a class="header-anchor" href="#Something-Else">¶</a>Something Else</h3>
<p>During this lecture, the instructor also mentioned about machine learning strategy, deep learning and reinforcement learning.</p>
<p>An example of reinforcement learning:<br>
I don’t know what’s the optimal way to fly a helicopter. So you let the helicopter do whatever it wants and then whenever it flies well, you know, does some maneuver you want, or flies accurately without jetting around too much, you go, “Oh, good helicopter”. And when it crashes you go, “Bad helicopter” and it’s the job of the reinforcement learning algorithms to figure out how to control it over time so as to get more of the good helicopter things and fewer of the bad helicopter things.</p>
<h2 id="Lecture-2-Linear-Regression-and-Gradient-Descent"><a class="header-anchor" href="#Lecture-2-Linear-Regression-and-Gradient-Descent">¶</a>Lecture 2 - Linear Regression and Gradient Descent</h2>
<ul>
<li>Outline
<ul>
<li>Linear Regression</li>
<li>Batch and stochastic gradient descent</li>
<li>Normal Equation</li>
</ul>
</li>
</ul>
<h3 id="Linear-Regression"><a class="header-anchor" href="#Linear-Regression">¶</a>Linear Regression</h3>
<p>You remember the ALVINN video, the autonomous driving video that I had shown in class on Monday, um, for the self-driving car video, that was a supervised learning problem. And the term supervised learning meant that you were given Xs which was a picture of what’s in front of the car, and the algorithm had to map that to an output Y which was the steering direction. And that was a regression problem, because the output Y that you want is a continuous value, right? As opposed to a classification problem where Y is the speed.</p>
<p>So I think the simplest, maybe the simplest possible learning algorithm, a supervised learning regression problem, is linear regression. And to motivate that, rather than using a self-driving car example which is quite complicated, we’ll build up a supervised learning algorithm using a simpler example.</p>
<p>Back to our housing prices prediction example, let’s say you want to predict or estimate the prices of houses.</p>
<div align=center><img width = '600' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/Housing_prices_table.PNG"/></div>
<div align=center><img width = '900' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/Housing_prices_map.PNG"/></div>
<p>This is data from Portland, Oregon. So you have some dataset like that. And what we’ll end up doing today is fit a straight line to this data.</p>
<p>The process of supervised learning</p>
<div align=center><img width = '400' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/the_process_of_supervised_learning.PNG"/></div>
<p>The job of the learning algorithm is to output a function, uh, to make predictions about housing prices. And by convention, I’m gonna call this a function that it outputs a <strong>hypothesis</strong>. And the job of the hypothesis is, you know, it can input the size of a new house, or the size of a different house that you haven’t seen yet, and will output the estimated price.</p>
<p>So when designing a learning algorithm the first thing we need to ask is, how do you represent the hypothesis, H. And in linear regression, for the purpose of this lecture, we’re going to say that, the hypothesis is going to be that:</p>
$$h(x) = \theta_0 + \theta_1 x.$$
<p>The machine learning sometimes just calls this a linear function, but technically it’s an affine function. Doesn’t matter.</p>
<p>More generally, if you have multiple input features, so if you have more information about these houses, such as number of bedrooms. (&quot;#bedroom&quot; stands for the number of bedrooms.)</p>
<div align=center><img width = '500' height ='250' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/housing_example_more_interesting.PNG"/></div>
$$h(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_2 ~~~~~~~~(x_1 = \text{size, } x_2 = \text{# bedrooms})$$
<p>In order to make that notation a little bit more compact, we want to write a hypothesis.</p>
$$h(x) = \sum^{2}_{j=0} \theta_j x_j ~~~~~~~~\text{where } x_0 = 1$$
<p>And so here theta becomes a three-dimensional parameter:</p>
$$\theta =
\begin{bmatrix}
\theta_0 \\
\theta_1 \\
\theta_2 \\
\end{bmatrix}
$$
<p>The features become a three dimensional feature vector:</p>
$$x =
\begin{bmatrix}
x_0 \\
x_1 \\
x_2 \\
\end{bmatrix}
$$
<p>To introduce a bit more terminology: $~~~~\theta\text{ : parameters}$<br>
and the job of the learning algorithm is to choose parameters theta, that allows you to make good predictions about your prices of houses.</p>
$m : \text{# training examples}\\~~~~~~\text{# rows in the table above}\\n : \text{# features}\\x : \text{inputs / feature} ~~~~ y : \text{output / target variable}\\(x,y) : \text{training example}\\(x^{(i)}, y^{(i)}) : \text{the } i^{th} \text{ training example}$
<p><br>Back to the problem:</p>
<p>$$\text{choose } \theta \text{ such that } h(x) \text{ is close to } y \text{ for the training examples}$$</p>
<p>Notice: a abbreviation in notation, $h_{\theta}(x) : h(x)$, we use $h_\theta(x)$ to emphasize that the hypothesis depends both on the parameters and on the input features $x$.</p>
<p>So in order to learn a set of parameters what we’ll want to do is choose a parameters $\theta$ so that at least for the houses whose prices you know, that, you know, the learning algorithm outputs prices that are close to what you know where the correct price is for that set of houses.</p>
<p>More formally, in the linear regression algorithm, also called ordinary least squares, we want to</p>
$$\text{choose values of}~~\theta~~\text{that minimizes }\sum^{m}_{i=1}(h_\theta(x^{(i)}) - y^{(i)})^2. $$
<p>And so in linear regression, we’re gonna define the cost function:</p>
$$J(\theta) = \dfrac{1}{2}\sum^{m}_{i=1}(h_\theta(x^{(i)}) - y^{(i)})^2.$$
<p>so next let’s see how you can implement an algorithm to find the value of Theta that the cost function J of Theta. We’re going to use an algorithm called gradient descent.</p>
<h3 id="Gradient-Descent"><a class="header-anchor" href="#Gradient-Descent">¶</a>Gradient Descent</h3>
<p>We are going to start with some value of $~\theta~$(say $\theta = \vec{0}$), and we’re going to keep changing $\theta$ to reduce $J(\theta)$</p>
<p>let me show you a visualization of gradient descent, and then we’ll write out the math.</p>
<div align=center><img width = '400' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/Gradient_Descent_point.PNG"/></div><br>
<p>One property of gradient descent is that, depend on where you initialize parameters, you can get to local different points. If you had run gradient descent from a new point, then you would have gotten to a different local optimum, to a different local minima. It turns out that when you run gradient descents on linear regression, there will not be local optimum.</p>
<p>So let’s formalize the gradient descent algorithm.</p>
$$\theta_j := \theta_j - \alpha \dfrac{\partial}{\partial \theta_j}J(\theta)$$
<p>The notation “$:=$” denote assignment. And $\alpha$ is called the learning rate.</p>
<p>Q: How do you determine the learning rate?</p>
<p>A: uh, you know, there’s a theory and there’s a practice.<br>
Uh, in practice, you set to 0.01. [LAUGHTER]</p>
<p>In order to implement this algorithm, we have to work out what is the partial derivative term on the right hand side. Lets first work it out for the case of if we have only one training example $(x, y)$, so that we can neglect the sum in the definition of $J$. We have:</p>
$$\begin{array}{lcl}
\dfrac{\partial}{\partial \theta_j}J(\theta)
& = & \dfrac{\partial}{\partial \theta_j}\dfrac{1}{2}(h_\theta(x) - y)^2
\\
& = & 2\cdot\dfrac{1}{2}(h_\theta(x) - y)\cdot\dfrac{\partial}{\partial \theta_j}(h_\theta(x) - y)
\\
& = & (h_\theta(x) - y)\cdot\dfrac{\partial}{\partial \theta_j}\Big(\sum\limits^{n}_{i=0} \theta_i x_i - y \Big)
\\
& = & (h_\theta(x) - y) x_j
\end{array}$$
<p>For a single training example:</p>
$$\theta_j := \theta_j - \alpha (h_\theta(x) - y) x_j$$
<p>So I did this with one training example, but, this kind of used definition of $J(\theta)$ defined using just one single training example, you actually have M training examples. Um, the derivative, you know, the derivative of a sum is the sum of the derivatives:</p>
$$\theta_j := \theta_j - \alpha\sum^{m}_{i=1}(h_{\theta}(x^{(i)}) - y^{(i)}) x_j^{(i)}$$
<p>So the gradient descent algorithm:</p>
$~~~~~~~~\text{Repeat until convergence }\{\\~~~~~~~~ ~~~~~~~~\theta_j := \theta_j + \alpha\sum\limits^{m}_{i=1}(y^{(i)}-h_{\theta}(x^{(i)})) x_j^{(i)}~~~~~~~~(\text{for every }j)\\~~~~~~~~ \}$
<p><br>This method looks at every example in the entire training set on every step, and is called <strong>batch gradient descent</strong>.</p>
<p>Unlike the earlier diagram above which has local optima, it turns out that if $J(\theta)$ is defined the way that, you know, we just defined it for linear regression, is the sum of squared terms, then $J(\theta)$ turns out to be a quadratic function, and so, $J(\theta)$ will always look like a big bowl like this.</p>
<div align=center><img width = '400' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/big_bowl.PNG"/></div><br>
<p>And so $J(\theta)$ does not have local optima, or the only local optima is also the global optimum.</p>
<p>The other way to look at the function is taking horizontal slices and plotting.</p>
<div align=center><img width = '500' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/contours_of_quadratic_function.PNG"/></div>
<p>As you take steps downhill, because there’s only one global minimum, this algorithm will eventually converge to the global minimum.</p>
<p>And so the question just now about the choice of the learning rate $\alpha$. Um, if you set $\alpha$ to be very very large, then they can overshoot. The steps you take can be too large and you can run past the minimum. If you set to be too small, then you need a lot of iterations and the algorithm will be slow. And so what happens in practice is, uh, usually you try a few values and and and see what value of the learning rate allows you to most efficiently, you know, drive down the value of $J(\theta)$.</p>
<p>I want to visualize this in one other way, which is with the data. So this is the actual dataset, and there are actually 49 points in this dataset, the number of training examples is 49. When we run batch gradient descent to fit $\theta$ on our previous dataset, to learn to predict housing price as a function of living area, we obtain $\theta_0 = 71.27$, $\theta_1 = 0.1345$. If we plot $h_\theta(x)$ as a function of $x$ (area), along with the training data, we obtain the following figure:</p>
<div align=center><img width = '500' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/run_batch_gradient_descent.PNG"/></div>
<p>If the number of bedrooms were included as one of the input features as well, we get $\theta_0 = 89.60$, $\theta_1 = 0.1392$, $\theta_2 = 8.738$.</p>
<p>The main disadvantage of batch gradient descent is, every single step of gradient descent requires that you read through your entire data-set, maybe terabytes of data-sets, maybe tens or hundreds of terabytes of data, before you can even update the parameters just once. And if gradient descent needs hundreds of iterations to converge, then you’ll be scanning through your entire data-set hundreds of times. And so this gets expensive. So there’s an alternative to batch gradient descent.</p>
<p>Consider the following algorithm:</p>
$~~~~~~~~ \text{Repeat }\{ \\~~~~~~~~ ~~~~~~~~\text{for i = 1 to m, }\{ \\~~~~~~~~ ~~~~~~~~~~~~~~~~\theta_j := \theta_j + \alpha(y^{(i)}-h_{\theta}(x^{(i)})) x_j^{(i)}~~~~~~~~(\text{for every }j) \\~~~~~~~~ ~~~~~~~~\} \\~~~~~~~~ \}$
<p><br>In this algorithm, we repeatedly run through the training set, and each time we encounter a training example, we update the parameters according to the gradient of the error with respect to that single training example only. This algorithm is called <strong>stochastic gradient descent</strong> (also <strong>incremental gradient descent</strong>).</p>
<p>Whereas batch gradient descent has to scan through the entire training set before taking a single step—a costly operation if $m$ is large—stochastic gradient descent can start making progress right away, and continues to make progress with each example it looks at. Often, stochastic gradient descent gets $\theta$ “close” to the minimum much faster than batch gradient descent. (Note however that it may never “converge” to the minimum, and the parameters $\theta$ will keep oscillating around the minimum of $J(\theta)$; but in practice most of the values near the minimum will be reasonably good approximations to the true minimum.) For these reasons, particularly when the training set is large, stochastic gradient descent is often preferred over batch gradient descent.</p>
<h3 id="Normal-Equation"><a class="header-anchor" href="#Normal-Equation">¶</a>Normal Equation</h3>
<p>Gradient descent gives one way of minimizing $J$. Lets discuss a second way of doing so, this time performing the minimization explicitly and without resorting to an iterative algorithm. In this method, we will minimize $J$ by explicitly taking its derivatives with respect to the $\theta_j$'s, and setting them to zero. To enable us to do this without having to write reams of algebra and pages full of matrices of derivatives, lets introduce some notation for doing calculus with matrices.</p>
<h4 id="Matrix-derivatives"><a class="header-anchor" href="#Matrix-derivatives">¶</a>Matrix derivatives</h4>
<p>For a function $f$ : $\mathbb{R}^{m \times n}\longmapsto \mathbb{R}$ mapping from $m$-by-$n$ matrices to the real numbers, we define the derivative of $f$ with respect to $A$ to be:</p>
$$
\nabla_A f(A) =
\begin{bmatrix}
\dfrac{\partial f}{\partial A_{11}} & \cdots & \dfrac{\partial f}{\partial A_{1n}} \\
\vdots & \ddots & \vdots \\
\dfrac{\partial f}{\partial A_{m1}} & \cdots & \dfrac{\partial f}{\partial A_{mn}}
\end{bmatrix}
$$
<p>Thus, the gradient $\nabla_A f(A)$ is itself an $m$-by-$n$ matrix, whose $(i, j)$-element is $\partial f/\partial A_{ij}$. For example, suppose $A = \begin{bmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{bmatrix}$ is a $2$-by-$2$ matrix, and the function $f$ : $\mathbb{R}^{m \times n}\longmapsto \mathbb{R}$ is given by</p>
$$f(A) = \dfrac{3}{2}A_{11} + 5A^2_{12} + A_{21}A_{22}.$$
<p>Here, $A_{ij}$ denotes the $(i, j)$ entry of the matrix $A$. We then have</p>
$$
\nabla_Af(A) =
\begin{bmatrix}
\frac{3}{2} & 10A_{12} \\
A_{22} & A_{21}
\end{bmatrix}.
$$
<p>We also introduce the <strong>trace</strong> operator, written “tr.” For an $n$-by-$n$ (square) matrix $A$, the trace of $A$ is defined to be the sum of its diagonal entries:</p>
$$\text{tr }A = \sum_{i=1}^{n} A_{ii}$$
<p>If $a$ is a real number (i.e., a $1$-by-$1$ matrix), then $\text{tr } a = a$. (If you haven’t seen this “operator notation” before, you should think of the trace of $A$ as $\text{tr}(A)$, or as application of the “trace” function to the matrix $A$. It’s more commonly written without the parentheses, however.)</p>
<p>The trace operator has the property that for two matrices $A$ and $B$ such that $AB$ is square, we have that $\text{tr}AB = \text{tr}BA$. (Check this yourself!) As corollaries of this, we also have, e.g.,</p>
<p>$$\text{tr}ABC = \text{tr}CAB = \text{tr}BCA,$$</p>
<p>$$\text{tr}ABCD = \text{tr}DABC = \text{tr}CDAB = \text{tr}BCDA.$$</p>
<p>The following properties of the trace operator are also easily verified. Here, $A$ and $B$ are square matrices, and $a$ is a real number:</p>
<p>$$\text{tr}A = \text{tr}A^T$$</p>
<p>$$\text{tr}(A+B) = \text{tr}A + \text{tr}B$$</p>
<p>$$\text{tr}aA = a\text{tr}A$$</p>
<p>We now state without proof some facts of matrix derivatives (we won’t need some of these until later this quarter). Equation $(4)$ applies only to non-singular square matrices $A$, where $|A|$ denotes the determinant of $A$. We have:</p>
$$\nabla_A\text{tr}AB = B^T \tag{1}$$
$$\nabla_{A^T} f(A) = (\nabla_A f(A))^T \tag{2}$$
$$\nabla_A\text{tr}ABA^TC = CAB + C^TAB^T \tag{3}$$
$$\nabla_A|A| = |A|(A^{-1})^T. \tag{4}$$
<p>The proofs of these equations are left as an exercise to the reader.</p>
<h4 id="Least-squares-revisited"><a class="header-anchor" href="#Least-squares-revisited">¶</a>Least squares revisited</h4>
<p>Armed with the tools of matrix derivatives, let us now proceed to find in closed-form the value of $\theta$ that minimizes $J(\theta)$. We begin by re-writing $J$ in matrix-vectorial notation.</p>
<p>Giving a training set, define the <strong>design matrix</strong> $X$ to be the $m$-by-$n$ matrix (actually $m$-by-$n$ $+ 1$, if we include the intercept term) that contains the training examples’ input values in its rows:</p>
$$
X =
\begin{bmatrix}
 — ~~(x^{(1)})^T~~ —\\
 — ~~(x^{(2)})^T~~ —\\
 — ~~(x^{(3)})^T~~ —\\
\vdots \\
 — ~~(x^{(m)})^T~~ —\\
\end{bmatrix}.
$$
<p>Also, let $\vec{y}$ be the $m$-dimensional vector containing all the target values from the training set:</p>
$$
\vec{y} =
\begin{bmatrix}
&y^{(1)}&\\
&y^{(2)}&\\
&\vdots& \\
&y^{(m)}&\\
\end{bmatrix}.
$$
<p>Now, since $h_\theta(x^{(i)}) = (x^{(i)})^T \theta$, we can easily verify that</p>
$$\begin{array}{lcl}
X\theta - \vec{y}
& = & \begin{bmatrix}
&(x^{(1)})^T\theta&\\
&\vdots& \\
&(x^{(m)})^T\theta&\\
\end{bmatrix}
-\begin{bmatrix}
&y^{(1)}&\\
&\vdots& \\
&y^{(m)}&\\
\end{bmatrix}
\\
& = & \begin{bmatrix}
&h_\theta(x^{(i)}) - y^{(1)}& \\
&\vdots& \\
&h_\theta(x^{(i)}) - y^{(1)}&
\end{bmatrix}.
\end{array}$$
<p>Thus, using the fact that for a vector $z$, we have that $zz^T = \sum_i z_i^2$:</p>
$$\begin{array}{lcl}
\dfrac{1}{2}(X\theta - \vec{y})^T(X\theta - \vec{y})
& = & \dfrac{1}{2}\sum\limits^{m}_{i=1}(h_\theta(x^{(i)}) - y^{(i)})^2 \\
& = & J(\theta)
\end{array}$$
<p>Finally, to minimize $J$, lets find its derivatives with respect to $\theta$. Combining Equations $(2)$ and $(3)$, we find that</p>
$$\nabla_{A^T}\text{tr}ABA^TC = B^TA^TC^T + BA^TC \tag{5}$$
<p>Hence,</p>
$$\begin{array}{lcl}
\nabla_\theta J(\theta)
& = & \nabla_\theta\dfrac{1}{2}(X\theta - \vec{y})^T(X\theta - \vec{y})\\
& = & \dfrac{1}{2}\nabla_\theta(\theta^T X^T - \vec{y}^T)(X\theta - \vec{y})\\
& = & \dfrac{1}{2}\nabla_\theta(\theta^TX^TX\theta - \theta^TX^T\vec{y} - \vec{y}^TX\theta + \vec{y}^T\vec{y})\\
& = & \dfrac{1}{2}\nabla_\theta \text{tr}(\theta^TX^TX\theta - \theta^TX^T\vec{y} - \vec{y}^TX\theta + \vec{y}^T\vec{y})\\
& = & \dfrac{1}{2}\nabla_\theta(\text{tr }\theta^TX^TX\theta - 2\text{tr }\vec{y}^TX\theta)\\
& = & \dfrac{1}{2}(X^TX\theta + X^TX\theta - 2X^T\vec{y})\\
& = & X^TX\theta - X^T\vec{y}
\end{array}$$
<p>In the fourth step, we used the fact that the trace of a real number is just the real number; the fourth step used the fact that $\text{tr}A = \text{tr}A^T$, and the sixth step used Equation $(5)$ with $A^T = \theta$, $B = B^T = X^T X$, and $C = I$, and Equation $(1)$. To minimize $J$, we set its derivatives to zero, and obtain the <strong>normal equations</strong>:</p>
$$X^T X \theta = X^T \vec{y}$$
<p>Thus, the value of $\theta$ that minimizes $J(\theta)$ is given in closed form by the equation</p>
$$\theta = (X^TX)^{-1}X^T\vec{y}.$$
<p>A common question I get is what if X is non-invertible. Uh, that usually means you have redundant features, that your features are linearly dependent, so go and figure out what features are actually repeated leading to this problem.</p>
<h2 id="Lecture-3-Locally-Weighted-Logistic-Regression"><a class="header-anchor" href="#Lecture-3-Locally-Weighted-Logistic-Regression">¶</a>Lecture 3 - Locally Weighted &amp; Logistic Regression</h2>
<ul>
<li>Outline
<ul>
<li>Linear regression (recap)</li>
<li>Locally weighted regression</li>
<li>Probabilistic interpretation</li>
<li>Logistic regression</li>
<li>Newton’s method</li>
</ul>
</li>
</ul>
<p>So last Wednesday, you saw the linear regression algorithm, uh, including both gradient descent, how to formulate the problem, then gradient descent, and then the normal equations. What I’d like to do today is, um, talk about locally weighted regression which is a way to modify linear regressions and make it fit very non-linear functions so you aren’t just fitting straight lines. And then I’ll talk about a probabilistic interpretation of linear regression and that will lead us into the first classification algorithm you see in this class called logistic regression, and we’ll talk about an algorithm called Newton’s method for logistic regression.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/linear_regression_dependency.PNG"/></div>
<h3 id="Recap-the-notation"><a class="header-anchor" href="#Recap-the-notation">¶</a>Recap the notation</h3>
<p>We use this notation $\big(x^{(i)}, y^{(i)}\big)$ to denote a single training example $(i^{th} \text{example})$ where $x^{(i)} \in \mathbb{R}^{n+1}$ $(x_0 = 1)$, $y^{(i)} \in \mathbb{R}$. And $m$ is the number of training examples and $n$ is the number of features.</p>
$$h_\theta(x) = \sum^{n}_{j = 0}\theta_j x_j = \theta^Tx$$
<p>the hypothesis, which is a linear function of the features $x$, including this feature $x_0$ which is always set to $1.$</p>
$$J(\theta) = \dfrac{1}{2}\sum^{m}_{i=1} \Big(h_\theta\big(x^{(i)}\big) - y^{(i)} \Big)^2$$
<p>$J$ was the cost function you would minimize, you minimize this to find the parameters $\theta$ for your straight line fit to the data.</p>
<h3 id="Locally-weighted-linear-regression"><a class="header-anchor" href="#Locally-weighted-linear-regression">¶</a>Locally weighted linear regression</h3>
<p>What I want to share with you today is a different way(not feature selection algorithms) of addressing this problem of whether the data isn’t just fit well by a straight line and in particular I wanna share with you an idea called, locally weighted regression or locally weighted linear regression.</p>
<p>Consider the problem of predicting $y$ from $x \in \mathbb{R}$ (or say $x \in \mathbb{R}^2$ and $x_0 = 1$). The leftmost figure below shows the result of fitting a $y = \theta_0 + \theta_1 x$ to a dataset. We see that the data doesn’t really lie on straight line, and so the fit is not very good.</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/under_over_fited_0.PNG"/></div><br>
<p>Instead, if we had added an extra feature $x^2$, and fit $y = \theta_0 + \theta_1x + \theta_2x^2$, then we obtain a slightly better fit to the data. (See middle figure) Naively, it might seem that the more features we add, the better. However, there is also a danger in adding too many features: The rightmost figure is the result of fitting a 5-th order polynomial $y = \sum^{5}_{j=0} \theta_jx^j$. We see that even though the fitted curve passes through the data perfectly, we would not expect this to be a very good predictor of, say, housing prices $(y)$ for different living areas $(x)$. Without formally defining what these terms mean, we’ll say the figure on the left shows an instance of <strong>underfitting</strong>—in which the data clearly shows structure not captured by the model—and the figure on the right is an example of <strong>overfitting</strong>. (Later in this class, when we talk about learning theory we’ll formalize some of these notions, and also define more carefully just what it means for a hypothesis to be good or bad.)</p>
<p>As discussed previously, and as shown in the example above, the choice of features is important to ensuring good performance of a learning algorithm. (When we talk about model selection, we’ll also see algorithms for automatically choosing a good set of features.) In this section, let us talk briefly talk about the locally weighted linear regression (LWR) algorithm which, assuming there is sufficient training data, makes the choice of features less critical. This treatment will be brief, since you’ll get a chance to explore some of the properties of the LWR algorithm yourself in the homework.</p>
<p>To evaluate $h$ at certain $x$ :</p>
<p>LR algorithm: $~~~~ \text{Fit} ~\theta~ \text{to minimize} ~~\dfrac{1}{2} \sum\limits^{}_{i} \big( y^{(i)} - \theta^T x^{(i)} \big)^2~~ \text{Return} ~~ \theta^T x$</p>
<p>LWR algorithm: $~~~~ \text{Fit} ~\theta~ \text{to minimize} ~~\sum\limits^{m}_{i=1}w^{(i)} \big(y^{(i)} - \theta^T x^{(i)} \big)^2~~\text{Return} ~~ \theta^T x$</p>
<p>Here, the $w^{(i)}$'s are non-negative valued weights. Intuitively, if $w^{(i)}$ is large for a particular value of $i$, then in picking $\theta$, we’ll try hard to make $\big(y^{(i)} - \theta^T x^{(i)}\big)^2$ small. If $w^{(i)}$ is small, then the $\big(y^{(i)} - \theta^T x^{(i)}\big)^2$ error term will be pretty much ignored in the fit.</p>
<p>A fairly standard choice for the weights is</p>
$$w^{(i)} = \exp \Big( -\dfrac{(x^{(i)} - x)^2}{2 \tau^2} \Big)$$
<p>If $x$ is vector-valued, this is generalized to be</p>
$$w^{(i)} = \exp\Big(-\dfrac{(x^{(i)}-x)^T(x^{(i)}-x)}{2\tau^2}\Big),$$
<p>or</p>
$$w^{(i)} = \exp\Big(-\dfrac{(x^{(i)}-x)^T\Sigma^{-1}(x^{(i)}-x)}{2}\Big),$$
<p>for an appropriate choice of $\tau$ or $\Sigma$.</p>
<p>Note that the weights depend on the particular point $x$ at which we’re trying to evaluate $x$. Moreover, if $|x^{(i)} - x|$ is small, then $w^{(i)}$ is close to $1$; and if $|x^{(i)} - x|$ is large, then $w^{(i)}$ is small. Hence, $\theta$ is chosen giving a much higher “weight” to the (errors on) training examples close to the query point $x$. (Note also that while the formula for the weights takes a form that is cosmetically similar to the density of a Gaussian distribution, the $w^{(i)}$'s do not directly have anything to do with Gaussians, and in particular the $w^{(i)}$ are not random variables, normally distributed or otherwise.) The parameter $\tau$ controls how quickly the weight of a training example falls off with distance of its $x^{(i)}$ from the query point $x$; $\tau$ is called the <strong>bandwidth</strong> parameter, and is also something that you’ll get to experiment with in your homework.</p>
<p>Locally weighted linear regression is the first example we’re seeing of a <strong>non-parametric</strong> algorithm. The (unweighted) linear regression algorithm that we saw earlier is known as a <strong>parametric</strong> learning algorithm, because it has a fixed, finite number of parameters (the $\theta_i$'s), which are fit to the data. Once we’ve fit the $\theta_i$'s and stored them away, we no longer need to keep the training data around to make future predictions. In contrast, to make predictions using locally weighted linear regression, we need to keep the entire training set around. The term “non-parametric” (roughly) refers to the fact that the amount of stuff we need to keep in order to represent the hypothesis $h$ grows linearly with the size of the training set.</p>
<p>So I tend to use locally weighted linear regression when I have a relatively low dimensional data set, when the number of features is not too big. So when $n$ is quite small like $2$ or $3$ or something and we have a lot of data. And you don’t wanna think about what features to use, right. So that’s the scenario. So if you actually have a data set that looks like these up in drawing, you know, locally weighted linear regression is a pretty good algorithm.</p>
<h3 id="Probabilistic-interpretation"><a class="header-anchor" href="#Probabilistic-interpretation">¶</a>Probabilistic interpretation</h3>
<p>When faced with a regression problem, why might linear regression, and specifically why might the least-squares cost function $J$, be a reasonable choice? In this section, we will give a set of probabilistic assumptions, under which least-squares regression is derived as a very natural algorithm.</p>
<p>Let us assume that the target variables and the inputs are related via the equation</p>
$$y^{(i)} = \theta^T x^{(i)} + \epsilon^{(i)},$$
<p>where $\epsilon^{(i)}$ is an error term that captures either unmodeled effects (such as if there are some features very pertinent to predicting housing price, but that we’d left out of the regression), or random noise. Let us further assume that the $\epsilon^{(i)}$ are distributed IID (independently and identically distributed) according to a Gaussian distribution (also called a Normal distribution) with mean zero and some variance $\sigma^2$. We can write this assumption as $“\epsilon^{(i)} \sim \mathcal{N}(0, \sigma^2).”$ I.e., the density of $\epsilon^{(i)}$ is given by</p>
$$p(\epsilon^{(i)}) = \dfrac{1}{\sqrt{2\pi} \sigma} \exp\Big( -\dfrac{(\epsilon^{(i)})^2}{2 \sigma^2} \Big)$$
<p>This implies that</p>
$$p(y^{(i)}|x^{(i)}; \theta) = \dfrac{1}{\sqrt{2\pi}\sigma} \exp \Big( -\dfrac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2} \Big)$$
<p>The notation $“p(y^{(i)}|x^{(i)}; \theta)”$ indicates that this is the distribution of $y^{(i)}$ given $x^{(i)}$ and parameterized by $\theta$. Note that we should not condition on $\theta(“p(y^{(i)}|x^{(i)}, \theta)”)$, since $\theta$ is not a random variable. We can also write the distribution of $y^{(i)}$ as $y^{(i)} | x^{(i)}$; $\theta ∼ \mathcal{N} (\theta^T x^{(i)}, \sigma^2)$.</p>
<p>Given $X$ ( the design matrix, which contains all the $x^{(i)}$'s ) and $\theta$, what is the distribution of the $y^{(i)}$'s? The probability of the data is given by $p(\vec{y}|X; \theta)$. This quantity is typically viewed a function of $\vec{y}$ (and perhaps $X$), for a fixed value of $\theta$. When we wish to explicitly view this as a function of $\theta$, we will instead call it the <strong>likelihood</strong> function:</p>
$$\mathscr{L}(\theta) = \mathscr{L}(\theta; X, \vec{y}) = p(\vec{y}|X; \theta).$$
<p>Note that by the independence assumption on the $\epsilon^{(i)}$'s (and hence also the $y^{(i)}$'s given the $x^{(i)}$'s), this can also be written</p>
$$
\begin{array}{lcl}
\mathscr{L}(\theta)
& = & \prod\limits^{m}_{i=1} p(y^{(i)}|x^{(i)}; \theta)\\
& = & \prod\limits^{m}_{i=1} \dfrac{1}{\sqrt{2\pi}\sigma} \exp \Big( -\dfrac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2} \Big)
\end{array}
$$
<p>Now, given this probabilistic model relating the $y^{(i)}$'s and the $x^{(i)}$'s, what is a reasonable way of choosing our best guess of the parameters $\theta$? The principal of <strong>maximum likelihood</strong> (MLE) says that we should should choose $\theta$ so as to make the data as high probability as possible. I.e., we should choose $\theta$ to maximize $\mathscr{L}(\theta)$.</p>
<p>Instead of maximizing $\mathscr{L}(\theta)$, we can also maximize any strictly increasing function of $\mathscr{L}(\theta)$. In particular, the derivations will be a bit simpler if we instead maximize the <strong>log likelihood</strong> $ℓ(\theta)$:</p>
$$
\begin{array}{lcl}
ℓ(\theta)
& = & \log \mathscr{L}(\theta)\\
& = & \log \prod\limits^{m}_{i=1} \dfrac{1}{\sqrt{2\pi}\sigma} \exp \Big( -\dfrac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2} \Big)\\
& = & \sum\limits^{m}_{i=1} \log \dfrac{1}{\sqrt{2\pi}\sigma} \exp \Big( -\dfrac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2} \Big)\\
& = & m\log\dfrac{1}{\sqrt{2\pi}\sigma} - \dfrac{1}{\sigma^2} \cdot \dfrac{1}{2} \sum\limits^{m}_{i=1} \big(y^{(i)} - \theta^T x^{(i)}\big)^2
\end{array}
$$
<p>Hence, maximizing $ℓ(\theta)$ gives the same answer as minimizing</p>
$$\dfrac{1}{2} \sum^{m}_{i=1} \big(y^{(i)} - \theta^T x^{(i)}\big)^2,$$
<p>which we recognize to be $J(\theta)$, our original least-squares cost function.</p>
<p>To summarize: Under the previous probabilistic assumptions on the data, least-squares regression corresponds to finding the maximum likelihood estimate of $\theta$. This is thus one set of assumptions under which least-squares regression can be justified as a very natural method that’s just doing maximum likelihood estimation. (Note however that the probabilistic assumptions are by no means $necessary$ for least-squares to be a perfectly good and rational procedure, and there may—and indeed there are—other natural assumptions that can also be used to justify it.)</p>
<p>Note also that, in our previous discussion, our final choice of $\theta$ did not depend on what was $\sigma^2$, and indeed we’d have arrived at the same result even if $\sigma^2$ were unknown. We will use this fact again later, when we talk about the exponential family and generalized linear models.</p>
<p>Q &amp; A</p>
<p>Q: what’s the difference between likelihood and probability?</p>
<p>A: The likelihood of the parameters is exactly the same thing as the probability of the data, but the reason we sometimes talk about likelihood, and sometimes talk of probability is, um, if you think of the training set the data as a fixed thing, and then varying parameters theta, then I’m going to use the term likelihood. Whereas if you view the parameters theta as fixed and maybe varying the data, I’m gonna say probability, right?</p>
<p>Q: why is epsilon i Gaussian?</p>
<p>A: So, uh, uh, turns out because of central limit theorem, uh, from statistics, uh, most error distributions are Gaussian, right? If there’s an era that’s made up of lots of little noise sources which are not too correlated, then by central limit theorem it will be Gaussian. So if you think that, most perturbations are, the mood of the seller, what’s the school district, you know, what’s the weather like, or access to transportation, and all of these sources are not too correlated, and you add them up then the distribution will be Gaussian. So you can use the central limit theorem, I think the Gaussian has become a default noise distribution. But for things where the true noise distribution is very far from Gaussian, uh, this model does do that as well. And in fact, for when you see generalized linear models on Wednesday, you see how to generalize all of these algorithms to very different distributions like Poisson, and so on.</p>
<h3 id="Logistic-regression"><a class="header-anchor" href="#Logistic-regression">¶</a>Logistic regression</h3>
<p>Lets now talk about the classification problem. This is just like the regression problem, except that the values $y$ we now want to predict take on only a small number of discrete values. For now, we will focus on the <strong>binary classification</strong> problem in which $y$ can take on only two values, $0$ and $1$. (Most of what we say here will also generalize to the multiple-class case.) For instance, if we are trying to build a spam classifier for email, then $x^{(i)}$ may be some features of a piece of email, and $y$ may be $1$ if it is a piece of spam mail, and $0$ otherwise. $0$ is also called the <strong>negative class</strong>, and 1 the <strong>positive class</strong>, and they are sometimes also denoted by the symbols “$-$” and “$+$.” Given $x^{(i)}$, the corresponding $y^{(i)}$ is also called the <strong>label</strong> for the training example.</p>
<p>We could approach the classification problem ignoring the fact that $y$ is discrete-valued, and use our old linear regression algorithm to try to predict $y$ given $x$. However, it is easy to construct examples where this method performs very poorly. Intuitively, it also doesn’t make sense for $h_\theta(x)$ to take values larger than $1$ or smaller than $0$ when we know that $y \in \{0, 1\}$.</p>
<div align=center><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/LR_for_classification.PNG"/></div>
<p>To fix this, lets change the form for our hypotheses $h_\theta(x)$. We will choose</p>
$$h_\theta(x) = g(\theta^T x) = \dfrac{1}{1 + e^{-\theta^T x}},$$
<p>where</p>
$$g(z) = \dfrac{1}{1 + e^{-z}}$$
<p>is called the <strong>logistic function</strong> or the <strong>sigmoid function</strong>. Here is a plot showing $g(z)$:</p>
<div align=center><img width = '400' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/logistic_function.PNG"/></div>
<p>Notice that $g(z)$ tends towards $1$ as $z \rightarrow \infty$, and $g(z)$ tends towards $0$ as $z \rightarrow −\infty$. Moreover, $g(z)$, and hence also $h(x)$, is always bounded between $0$ and $1$. As before, we are keeping the convention of letting $x_0 = 1$, so that $\theta^T x = \theta_0 + \sum\limits^{n}_{j=1} \theta_jx_j$ .</p>
<p>For now, lets take the choice of $g$ as given. Other functions that smoothly increase from $0$ to $1$ can also be used, but for a couple of reasons that we’ll see later (when we talk about GLMs, and when we talk about generative learning algorithms), the choice of the logistic function is a fairly natural one. Before moving on, here’s a useful property of the derivative of the sigmoid function, which we write a $g′$:</p>
$$
\begin{array}{lcl}
g'(z)
& = & \dfrac{\mathrm{d}}{\mathrm{d}z} \dfrac{1}{1 + e^{-z}}\\
& = & \dfrac{1}{(1 + e^{-z})^2} (e^{-z})\\
& = & \dfrac{1}{(1 + e^{-z})} \cdot \Big( 1 - \dfrac{1}{(1 + e^{-z})}\Big)\\
& = & g(z)(1 - g(z)).
\end{array}
$$
<p>So, given the logistic regression model, how do we fit $\theta$ for it? Following how we saw least squares regression could be derived as the maximum likelihood estimator under a set of assumptions, lets endow our classification model with a set of probabilistic assumptions, and then fit the parameters via maximum likelihood.</p>
<p>Let us assume that</p>
$$P(y=1~|~x; \theta) = h_\theta(x)$$
$$P(y=0~|~x; \theta) = 1 - h_\theta(x)$$
<p>Note that this can be written more compactly as</p>
$$P(y~|~x; \theta) = (h_\theta(x))^y (1 - h_\theta(x))^{1-y}$$
<p>Assuming that the $m$ training examples were generated independently, we can then write down the likelihood of the parameters as</p>
$$
\begin{array}{lcl}
\mathscr{L}(\theta)
& = & p(\vec{y}~|~X; \theta)\\
& = & \prod\limits^{m}_{i=1} p(y^{(i)}~|~x^{(i)}; \theta)\\
& = & \prod\limits^{m}_{i=1} \big(h_\theta(x^{(i)})\big)^{y^{(i)}} \big(1 - h_\theta(x^{(i)})\big)^{1-y^{(i)}}
\end{array}
$$
<p>As before, it will be easier to maximize the log likelihood:</p>
$$
\begin{array}{lcl}
ℓ(\theta)
& = & \log \mathscr{L}(\theta)\\
& = & \sum\limits^{m}_{i=1} y^{(i)} \log h(x^{(i)}) + (1 - y^{(i)}) \log (1 - h(x^{(i)}))
\end{array}
$$
<p>How do we maximize the likelihood? Similar to our derivation in the case of linear regression, we can use gradient ascent. Written in vectorial notation, our updates will therefore be given by</p>
$$\theta := \theta + \alpha \nabla_\thetaℓ(\theta).$$
<p>(Note the positive rather than negative sign in the update formula, since we’re maximizing, rather than minimizing, a function now.) Lets start by working with just one training example $(x, y)$, and take derivatives to derive the stochastic gradient ascent rule:</p>
$$
\begin{array}{lcl}
\dfrac{\partial}{\partial \theta_j} ℓ(\theta)
& = & \Big( y \dfrac{1}{g(\theta^T x)} - (1-y) \dfrac{1}{1 - g(\theta^T x)}\Big) \dfrac{\partial}{\partial \theta_j}g(\theta^T x)\\
& = & \Big( y \dfrac{1}{g(\theta^T x)} - (1-y) \dfrac{1}{1 - g(\theta^T x)}\Big)g(\theta^T x)(1 - g(\theta^T x)) \dfrac{\partial}{\partial \theta_j} \theta^T x\\
& = & \big( y (1 - g(\theta^T x)) - (1-y) g(\theta^T x)\big) x_j\\
& = & (y - h_\theta(x)) x_j
\end{array}
$$
<p>Above, we used the fact that $g′(z) = g(z)(1 - g(z))$. This therefore gives us the stochastic gradient ascent rule</p>
$$\theta := \theta + \alpha \big( y^{(i)} - h_\theta(x^{(i)}) \big)x_j^{(i)}$$
<p>If we compare this to the LMS update rule, we see that it looks identical; but this is not the same algorithm, because $h_\theta(x^{(i)})$ is now defined as a non-linear function of $\theta^T x^{(i)}$. Nonetheless, it’s a little surprising that we end up with the same update rule for a rather different algorithm and learning problem. Is this coincidence, or is there a deeper reason behind this? We’ll answer this when get to GLM models.</p>
<h3 id="Digression-The-perceptron-learning-algorithm"><a class="header-anchor" href="#Digression-The-perceptron-learning-algorithm">¶</a>Digression: The perceptron learning algorithm</h3>
<p>For further information, please refer to the relevant books.</p>
<h3 id="Newton’s-method"><a class="header-anchor" href="#Newton’s-method">¶</a>Newton’s method</h3>
<p>Returning to logistic regression with $g(z)$ being the sigmoid function, lets now talk about a different algorithm for minimizing $ℓ(\theta)$.</p>
<p>To get us started, lets consider Newton’s method for finding a zero of a function. Specifically, suppose we have some function $f$ : $\mathbb{R} \longmapsto \mathbb{R}$, and we wish to find a value of $\theta$ so that $f(\theta) = 0$. Here, $\theta \in \mathbb{R}$ is a real number. Newton’s method performs the following update:</p>
$$\theta := \theta - \dfrac{f(\theta)}{f'(\theta)}.$$
<p>This method has a natural interpretation in which we can think of it as approximating the function f via a linear function that is tangent to $f$ at the current guess $\theta$, solving for where that linear function equals to zero, and letting the next guess for $\theta$ be where that linear function is zero.</p>
<p>Here’s a picture of the Newton’s method in action:</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/CS229:%20Machine%20Learning/Newton's_method.PNG"/></div><br>
<p>In the leftmost figure, we see the function $f$ plotted along with the line $y = 0$. We’re trying to find $\theta$ so that $f(\theta) = 0$; the value of $\theta$ that achieves this is about $1.3$. Suppose we initialized the algorithm with $\theta = 4.5$. Newton’s method then fits a straight line tangent to $f$ at $\theta = 4.5$, and solves for the where that line evaluates to $0$. (Middle figure.) This give us the next guess for $\theta$, which is about $2.8$. The rightmost figure shows the result of running one more iteration, which the updates $\theta$ to about $1.8$. After a few more iterations, we rapidly approach $\theta = 1.3$.</p>
<p>Newton’s method gives a way of getting to $f(\theta) = 0$. What if we want to use it to maximize some function $ℓ$? The maxima of $ℓ$ correspond to points where its first derivative $ℓ’(\theta)$ is zero. So, by letting $f(\theta) = ℓ’(\theta)$, we can use the same algorithm to maximize $ℓ$, and we obtain update rule:</p>
$$\theta := \theta - \dfrac{ℓ'(\theta)}{ℓ''(\theta)}.$$
<p>(Something to think about: How would this change if we wanted to use Newton’s method to minimize rather than maximize a function?)</p>
<p>Lastly, in our logistic regression setting, $\theta$ is vector-valued, so we need to generalize Newton’s method to this setting. The generalization of Newton’s method to this multidimensional setting (also called the Newton-Raphson method) is given by</p>
$$\theta := \theta - H^{-1} \nabla_\thetaℓ(\theta).$$
<p>Here, $\nabla_\theta ℓ(\theta)$ is, as usual, the vector of partial derivatives of $ℓ(\theta)$ with respect to the $\theta_i’s$; and $H$ is an $n$-by-$n$ matrix (actually, $n + 1$-by-$n + 1$, assuming that we include the intercept term) called the <strong>Hessian</strong>, whose entries are given by</p>
$$H_{ij} = \dfrac{\partial^2 ℓ(\theta)}{\partial \theta_i \partial \theta_j}$$
<p>Newton’s method typically enjoys faster convergence than (batch) gradient descent, and requires many fewer iterations to get very close to the minimum. One iteration of Newton’s can, however, be more expensive than one iteration of gradient descent, since it requires finding and inverting an $n$-by-$n$ Hessian; but so long as $n$ is not too large, it is usually much faster overall. When Newton’s method is applied to maximize the logistic regression log likelihood function $ℓ(\theta)$, the resulting method is also called <strong>Fisher scoring</strong>.</p>
<h1>To Be Continued…</h1>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>模电第五次作业</title>
    <url>/2020/05/07/%E6%A8%A1%E7%94%B5%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>使用教材：<br>
清华大学电子学教研组编 . 杨素行主编 . 模拟电子技术基础简明教程 . 3版 . 北京：高等教育出版社，2006.<br>
作业内容：<br>
模电作业是这样的：<br>
第七章1 2 6 7 10 14 15<br>
5月8号前交</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="7-1"><a class="header-anchor" href="#7-1">¶</a>7-1</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-1-2.PNG" alt="avatar"></p>
<p>(1)<br>
通常选择： $R_3=R_1//R_2=5k\Omega$<br>
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ R_4=R_5//R_6=10k\Omega // 20k\Omega\approx 6.67k\Omega$</p>
<p>(2)<br>
由 $A_1$ 虚短虚断可知：${\dfrac {u_{O1}}{R_2}}+{\dfrac {u_{I1}}{R_1}}=0$<br>
求得：$u_{O1}=-{\dfrac {R_2}{R_1}}\cdot u_{I1}=-u_{I1}$<br>
由 $A_2$ 虚短虚断可知：$u_{I2}=u_P=u_N={\dfrac {R_6}{R_5+R_6}}\cdot u_{O2}$<br>
求得：$u_{O2}=(1+{\dfrac {R_5}{R_6}})\cdot u_{I2}=1.5\cdot u_{I2}$<br>
由 $A_3$ 虚短虚短可知：$u_N=u_P={\dfrac {R_{10}}{R_8+R_{10}}}\cdot u_{O2}$<br>
则在 $A_3$ 的反相输入端列写 $KCL$ 方程：${\dfrac {u_{O1}-u_N}{R_7}}+{\dfrac {u_{O}-u_N}{R_9}}=0$<br>
求得：$u_O={\dfrac {R_7+R_9}{R_7}}\cdot u_N-{\dfrac {R_9}{R_7}}\cdot u_{O1}$<br>
代入 $u_N$ 得：$u_O={\dfrac {R_7+R_9}{R_7}}\cdot {\dfrac {R_{10}}{R_8+R_{10}}}\cdot u_{O2}-{\dfrac {R_9}{R_7}}\cdot u_{O1}$<br>
其中 $R_7=R_8\ \ \ \ R_9=R_{10}$<br>
则可将上式化简得：</p>
$u_{O}=-{\dfrac {R_9}{R_7}}\cdot (u_{O1}-u_{O2})=(-2)\cdot (-u_{I1}-1.5\cdot u_{O2})=2\cdot u_{I1}+3\cdot u_{I2}$
<p>(3)<br>
将 $u_{I1}=3V\ \ \ \ u_{I2}=1V$ 代入 $u_O$ 的表达式：<br>
$u_O=(2\times 3+3\times 1)V=9V$</p>
<hr>
<h2 id="7-2"><a class="header-anchor" href="#7-2">¶</a>7-2</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-2-1.PNG" alt="avatar"></p>
<p>设输出端正端子电位为 $u_{O+}$  输出端负端子电位为 $u_{O-}$<br>
由 $A_1$ 虚短虚断可知：$u_{I}=u_P=u_N={\dfrac {R_1}{R_1+R_2}}\cdot u_{O+}$<br>
求得：$u_{O+}={\dfrac {R_1+R_2}{R_1}}\cdot u_I$<br>
由 $A_2$ 虚短虚断可知：${\dfrac {u_I-u_P}{R_4}}+{\dfrac {u_{O-}-u_P}{R_5}}=0$<br>
求得：$u_{O-}=-{\dfrac {R_5}{R_4}}\cdot u_I$<br>
则有：$u_O=u_{O+}-u_{O-}={\dfrac {R_1+R_2}{R_1}}\cdot u_I+{\dfrac {R_5}{R_4}}\cdot u_I=[(1+{\dfrac {R_2}{R_1}})+{\dfrac {R_5}{R_4}}]\cdot u_I$</p>
<hr>
<h2 id="7-6"><a class="header-anchor" href="#7-6">¶</a>7-6</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-6-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-6-2.PNG" alt="avatar"><br>
两个反向比例运算电路解决问题<br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-6-3.PNG" alt="avatar"></p>
<hr>
<h2 id="7-7"><a class="header-anchor" href="#7-7">¶</a>7-7</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-7-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-7-2.PNG" alt="avatar"></p>
<p>因为 $R_2=R_3\ \ \ \ R_4=R_5\ \ \ \ R_6=R_7$<br>
那么由三运放数据放大器输入对输出的表达式：$u_O=-{\dfrac {R_6}{R_4}}\cdot (1+{\dfrac {2R_2}{R1}})\cdot u_I$<br>
将 $R_1=1k\Omega$ 与 $R_1=10k\Omega$ 分别代入上式：</p>
<p>当 $R_1=1k\Omega$ 时，$u_O=-{\dfrac {100k}{33k}}\cdot (1+{\dfrac {40k}{1k}})\cdot u_I\approx-124.24\cdot u_I$</p>
<p>当 $R_1=10k\Omega$ 时，$u_O=-{\dfrac {100k}{33k}}\cdot (1+{\dfrac {40k}{10k}})\cdot u_I\approx-15.15\cdot u_I$</p>
<p>比例系数的可调范围为：$-15.15\sim 124.24$</p>
<hr>
<h2 id="7-10"><a class="header-anchor" href="#7-10">¶</a>7-10</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-10-1.PNG" alt="avatar"><br>
两个反相输入求和电路解决问题<br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-10-2.PNG" alt="avatar"></p>
<hr>
<h2 id="7-14"><a class="header-anchor" href="#7-14">¶</a>7-14</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-14-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-14-2.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-14-3.PNG" alt="avatar"></p>
<p>先将 $u_{O1}$ 与 $u_{O}$ 的表达式求出来：<br>
图（a）所示电路的第一级为积分电路<br>
由于集成运放反相输入端“虚地”，故有：$u_{O1}=-u_C$<br>
又由于“虚断”，运放反相输入端的电流为零，则 $i_I=i_C$<br>
故有：$u_I=i_IR=i_CR$<br>
那么则有：$u_{O1}=-u_C=-{\dfrac {1}{C}}\int_{-\infty}^{t} i_C\, \mathrm{d}t=-{\dfrac {1}{RC}}\int_{0}^{t} u_I\, \mathrm{d}t+U_{O1}(0)$</p>
<p>将 $R=10k\Omega\ \ \ \ C=1\mu F\ \ \ \ U_{O1}(0)=0$ 代入上式</p>
<p>化简得：</p>
$u_{O1}=-{\dfrac {1}{RC}}\int_{0}^{t} u_I\, \mathrm{d}t+U_{O1}(0)=-{\dfrac {u_I}{10^{4}\times 10^{-6}}}t+U_{O1}(0)=-100u_I\times t\ \ (V)$
<p>又有：</p>
$u_O=-[{\dfrac {R_F}{R_1}}u_{O1}+{\dfrac {R_F}{R_2}}\times (-1)]=-{\dfrac {10^4}{10^4}}u_{O1}-{\dfrac {10^4}{2\times 10^4}}\times (-1)=-u_{O1}+0.5\ \ (V)$
<p>(1) $t=0$ 时，$u_{O1}=0$ ， $u_O=0.5V$</p>
<p>(2) $t=(0\sim 10)\ ms$ 时，$u_I=-1V$</p>
<p>故当 $t=10\ ms$ 时，$u_{O1}=1V$ ， $u_O=-0.5V$</p>
<p>(3) $t=(10\sim 20)\ ms$ 时，$u_I=1V$</p>
<p>根据：</p>
$u_{O1}=-u_C=-{\dfrac {1}{C}}\int_{-\infty}^{t} i_C\, \mathrm{d}t=-{\dfrac {1}{RC}}\int_{t_0}^{t} u_I\, \mathrm{d}t+U_{O1}(t_0) ， U_{O1}(t_0)=1V$
<p>故当 $t=20\ ms$ 时，$u_{O1}=0V$ ， $u_O=0.5V$</p>
<p>(4)波形图如下图所示：<br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-14-5.PNG" alt="avatar"></p>
<h2 id="7-15"><a class="header-anchor" href="#7-15">¶</a>7-15</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-15-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-15-2.PNG" alt="avatar"></p>
<p>$A_1、A_2$ 和 $A_3$ 均组成电压跟随器，$A_4$ 组成同相输入求和电路</p>
<p>则有：$u_{O1}=u_{I1}\ \ \ \ u_{O2}=u_{I2}\ \ \ \ u_{O3}=u_{I3}$</p>
<p>由 $A_4$ 虚短虚断可得 $A_4$ 同相输入端 $KCL$ 方程为：</p>
${\dfrac {u_{O1}-u_O}{R_1}}+{\dfrac {u_{O2}-u_O}{R_2}}+{\dfrac {u_{O3}-u_O}{R_3}}=0$
<p>其中 $R_1=R_2=R_3=R$</p>
<p>则有：$u_O={\dfrac {1}{3}}(u_{O1}+u_{O2}+u_{O3})={\dfrac {1}{3}}(u_{I1}+u_{I2}+u_{I3})$</p>
<h2 id="附：数据放大器"><a class="header-anchor" href="#附：数据放大器">¶</a>附：数据放大器</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-addition-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-addition-2.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E4%BA%94%EF%BC%89/7-addition-3.PNG" alt="avatar"></p>
<hr>
<p>参考文献：<br>
模拟电子技术基础简明教程第3版及其教学指导书</p>
<hr>
]]></content>
      <tags>
        <tag>ANALOG</tag>
        <tag>作业区</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 7</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-7-寻址方式在结构化数据访问中的应用"><a class="header-anchor" href="#实验-7-寻址方式在结构化数据访问中的应用">¶</a>实验 7 寻址方式在结构化数据访问中的应用</h2>
<h3 id="数据处理的基本问题"><a class="header-anchor" href="#数据处理的基本问题">¶</a>数据处理的基本问题</h3>
<p>数据处理的两个基本问题：<br>
1）处理的数据在何处？<br>
2）处理的数据有多长？</p>
<h3 id="在何处？"><a class="header-anchor" href="#在何处？">¶</a>在何处？</h3>
<p>汇编语言中用三个概念来表达数据的位置，即立即数、寄存器、段地址（SA）和偏移地址（EA）</p>
<p>立即数：直接包含在机器指令中的数据</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2000H</span></span><br></pre></td></tr></table></figure>
<p>寄存器：指令要处理的数据在寄存器中</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br></pre></td></tr></table></figure>
<p>段地址（SA）和偏移地址（EA）：指令要处理的数据在内存中，在指令中用 <code>[X]</code> 的格式给出 EA，SA 在某个段寄存器中<br>
注意，只有 bx、si、di 和 bp 这 4 个寄存器可以用在 <code>[...]</code> 中来进行内存单元的寻址</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">8</span>]              <span class="comment">;隐式给出存放段地址的寄存器</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">es</span>:[<span class="built_in">bx</span>]                <span class="comment">;显式给出存放段地址的寄存器</span></span><br></pre></td></tr></table></figure>
<br>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">寻址方式总结</a></p>
<h3 id="有多长？"><a class="header-anchor" href="#有多长？">¶</a>有多长？</h3>
<p>8086CPU 的指令，可以处理两种尺寸的数据，byte 和 word，在机器指令中要指明，指令进行的是字操作还是字节操作，常见的处理方法有三种</p>
<p>1）通过寄存器名指明指令进行的是字操作还是字节操作</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="built_in">ax</span>                 <span class="comment">;字操作</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="number">0</span>]                 <span class="comment">;字节操作</span></span><br></pre></td></tr></table></figure>
<p>2）用操作符 <code>word ptr</code> 和 <code>byte ptr</code> 指明内存单元的长度，注意，在没有寄存器参与的内存单元访问指令中，用操作符显性地指明所要访问的内存单元的长度是很有必要的</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>],<span class="number">1</span>         <span class="comment">;字操作</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]           <span class="comment">;字节操作</span></span><br></pre></td></tr></table></figure>
<p>3）有些指令默认了访问的是字单元还是字节单元，例如 <code>push</code> 指令就只进行字操作</p>
<h3 id="结构化数据访问"><a class="header-anchor" href="#结构化数据访问">¶</a>结构化数据访问</h3>
<p><code>[bx+si+idata]</code> 的寻址方式为结构化数据的处理提供了方便，我们可以用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的每个元素，为此，有更贴切的书写方式：<code>[bx].idata</code>、<code>[bx].idata[si]</code></p>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C7/experiment_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C7/experiment_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C7/experiment_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C7/experiment_4.PNG"/></div>
<br>
<p>思路都写在注释中了</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1975'</span>,<span class="string">'1976'</span>,<span class="string">'1977'</span>,<span class="string">'1978'</span>,<span class="string">'1979'</span>,<span class="string">'1980'</span>,<span class="string">'1981'</span>,<span class="string">'1982'</span>,<span class="string">'1983'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1984'</span>,<span class="string">'1985'</span>,<span class="string">'1986'</span>,<span class="string">'1987'</span>,<span class="string">'1988'</span>,<span class="string">'1989'</span>,<span class="string">'1990'</span>,<span class="string">'1991'</span>,<span class="string">'1992'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1993'</span>,<span class="string">'1994'</span>,<span class="string">'1995'</span></span><br><span class="line">      <span class="comment">;以上表示 21 年的 21 个字符串（84 个字节）</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dd</span> <span class="number">16</span>,<span class="number">22</span>,<span class="number">382</span>,<span class="number">1356</span>,<span class="number">2390</span>,<span class="number">8000</span>,<span class="number">16000</span>,<span class="number">24486</span>,<span class="number">50065</span>,<span class="number">97479</span>,<span class="number">140417</span>,<span class="number">197514</span></span><br><span class="line">      <span class="built_in">dd</span> <span class="number">345980</span>,<span class="number">590827</span>,<span class="number">803530</span>,<span class="number">1183000</span>,<span class="number">1843000</span>,<span class="number">2759000</span>,<span class="number">3753000</span>,<span class="number">4649000</span>,<span class="number">5937000</span></span><br><span class="line">      <span class="comment">;以上是表示 21 年公司总收入的 21 个 dword 型数据（84 个字节）（dd 即 define double word）</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">38</span>,<span class="number">130</span>,<span class="number">220</span>,<span class="number">476</span>,<span class="number">778</span>,<span class="number">1001</span>,<span class="number">1442</span>,<span class="number">2258</span>,<span class="number">2793</span>,<span class="number">4037</span>,<span class="number">5635</span>,<span class="number">8226</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">11542</span>,<span class="number">11430</span>,<span class="number">15257</span>,<span class="number">17800</span></span><br><span class="line">      <span class="comment">;以上是表示 21 年公司雇员的 21 个 word 型数据（42 个字节）</span></span><br><span class="line">      <span class="comment">;data 段一共占 E0H 的内存空间（重要）</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">21</span> dup (<span class="string">'year summ ne ?? '</span>)</span><br><span class="line">      <span class="comment">;dup 用来进行数据的重复，这里为 21 个 16 字节</span></span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>                     <span class="comment">;ds 存储 data 段的段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span>                     <span class="comment">;设置 16 个字节的栈空间</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">21</span>                     <span class="comment">;设置外层循环的 cx</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">push</span> <span class="built_in">cx</span>                       <span class="comment">;保存外层循环的 cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span>                      <span class="comment">;设置内层循环的 cx，年份长度为 4 个字节，(cx)=4</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s2:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">bp</span>+<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>].<span class="number">0e0h</span>[<span class="built_in">si</span>],<span class="built_in">al</span>       <span class="comment">;e0h 为 data 段长度</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s2                       <span class="comment">;完成年份的复制</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>:[<span class="built_in">bp</span>].<span class="number">54h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>+<span class="number">5</span>].<span class="number">0e0h</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="built_in">bp</span>+<span class="number">2</span>].<span class="number">54h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>+<span class="number">7</span>].<span class="number">0e0h</span>,<span class="built_in">dx</span>         <span class="comment">;完成收入的复制，同时做好除法指令的准备</span></span><br><span class="line">                                          <span class="comment">;被除数为 32 位，dx 存放高 16 位，ax 存放低 16 位</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">di</span>].<span class="number">0a8h</span>     <span class="comment">;做除法</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="built_in">di</span>].<span class="number">0a8h</span>           </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>+<span class="number">0ah</span>].<span class="number">0e0h</span>,<span class="built_in">dx</span>       <span class="comment">;完成雇员数的复制</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>+<span class="number">0dh</span>].<span class="number">0e0h</span>,<span class="built_in">ax</span>       <span class="comment">;ax 中存放的是除法的商，即人均收入</span></span><br><span class="line">                                          <span class="comment">;将其复制到 table 段中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span>                     <span class="comment">;换行</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bp</span>,<span class="number">4</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span>                        <span class="comment">;恢复外层循环的 cx</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">      </span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C7/7_1_1.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 1</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-1-查看-CPU-和内存，用机器指令和汇编指令编程"><a class="header-anchor" href="#实验-1-查看-CPU-和内存，用机器指令和汇编指令编程">¶</a>实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</h2>
<h3 id="预备知识"><a class="header-anchor" href="#预备知识">¶</a>预备知识</h3>
<p>本次实验中需要用到的命令</p>
<p>查看、修改 CPU 中寄存器的内容：R 命令<br>
查看内存中的内容：D 命令<br>
修改内存中的内容：E 命令（可以写入数据、指令、在内存中，它们实际上没有区别）<br>
将内存中的内容解释为机器指令和对应的汇编指令：U 命令<br>
执行 <code>CS:IP</code> 指向的内存单元处的指令：T 命令<br>
以汇编指令的形式向内存中写入指令：A 命令</p>
<p>在做实验的过程中，慢慢将解锁其他的用法</p>
<h3 id="实验任务（1）"><a class="header-anchor" href="#实验任务（1）">¶</a>实验任务（1）</h3>
<p>将程序段写入内存并逐条执行，注意 <code>CS:IP</code> 的指向</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">b8 <span class="number">20</span> 4e        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4E20H</span></span><br><span class="line"><span class="number">05</span> <span class="number">16</span> <span class="number">14</span>        <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">1416H</span></span><br><span class="line">bb <span class="number">00</span> <span class="number">20</span>        <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">2000H</span></span><br><span class="line"><span class="number">01</span> d8           <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line"><span class="number">89</span> c3           <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="number">01</span> d8           <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">b8 1a <span class="number">00</span>        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">001AH</span></span><br><span class="line">bb <span class="number">26</span> <span class="number">00</span>        <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0026H</span></span><br><span class="line"><span class="number">00</span> d8           <span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="number">00</span> dc           <span class="keyword">add</span> <span class="number">ah</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="number">00</span> c7           <span class="keyword">add</span> <span class="number">bh</span>,<span class="built_in">al</span></span><br><span class="line">b4 <span class="number">00</span>           <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line"><span class="number">00</span> d8           <span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span></span><br><span class="line"><span class="number">04</span> 9c           <span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">9CH</span></span><br></pre></td></tr></table></figure>
<p>可以用 E 命令和 A 命令两种方式将指令写入内存</p>
<p>用 R 命令查看 CPU 中的寄存器的值</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/R%E5%91%BD%E4%BB%A41.PNG"/></div><br>
<p>我们将以上的程序段写到从 <code>1000:0000</code> 开始的内存中，为了执行这段程序，将 <code>CS:IP</code> 指向段地址为 <code>1000</code>、偏移地址为 <code>0000</code> 的内存单元</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/R%E5%91%BD%E4%BB%A4csip.PNG"/></div><br>
<p>写入后的状态，可以看到内存中的指令是以一个个的机器码的形式存在的，数据与指令在内存中的形式是一样的，说明它们在本质上是没有区别的</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/D%E5%91%BD%E4%BB%A41.PNG"/></div><br>
<p>用 U 命令查看我们写入的汇编指令</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/U%E5%91%BD%E4%BB%A41.PNG"/></div><br>
<p>用 T 命令逐条执行我们写入的汇编指令</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/T%E5%91%BD%E4%BB%A41.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/T%E5%91%BD%E4%BB%A42.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/T%E5%91%BD%E4%BB%A43.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/T%E5%91%BD%E4%BB%A44.PNG"/></div><br>
<p>也可以直接让 Debug 执行全部的 14 条指令，在 T 命令的后面加上要执行命令的条数，注意 14 的十六进制数为 <code>0x0e</code></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E6%B3%A8%E9%87%8A%E6%97%B6%E5%86%99%E7%9A%84R%E5%91%BD%E4%BB%A4.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E6%B3%A8%E9%87%8A%E6%97%B6%E5%86%99%E7%9A%84T%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9.PNG"/></div>
<h3 id="实验任务（2）"><a class="header-anchor" href="#实验任务（2）">¶</a>实验任务（2）</h3>
<p>将下面 3 条指令写入从 <code>2000:0</code> 开始的内存单元中，利用这 3 条指令计算 2 的 8 次方</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="number">2000</span>:<span class="number">0003</span></span><br></pre></td></tr></table></figure>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E8%AE%A1%E7%AE%972%E7%9A%848%E6%AC%A1%E6%96%B9A%E5%91%BD%E4%BB%A4.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E8%AE%A1%E7%AE%972%E7%9A%848%E6%AC%A1%E6%96%B9T%E5%91%BD%E4%BB%A4.PNG"/></div>
<div align=center>...</div><br>
<div align=center>...</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E8%AE%A1%E7%AE%972%E7%9A%848%E6%AC%A1%E6%96%B9%E7%BB%93%E6%9E%9C.PNG"/></div><br>
<p>2 的 8 次方即 16 的平方，即 1 x 16^2，所以当 <code>AX=0100</code> 时我们知道已经计算完毕</p>
<p>8086CPU 在工作过程中总是从 <code>CS:IP</code> 指向的内存单元读取指令，读取的指令进入指令缓冲器，然后使 <code>IP = IP + 所读取指令的长度</code>，从而使 <code>CS:IP</code> 指向下一条指令，如此循环。现在我们可以界定 CPU 根据什么将内存中的信息（机器码）看作指令而不是简单的数据，即，CPU 将 <code>CS:IP</code> 指向的内存单元中的内容看作指令，<code>CS:IP</code> 存储了下一个将要执行的指令的物理地址</p>
<p><code>jmp</code> 指令是一个转移指令，转移指令是指可以修改 <code>IP</code> 或同时修改 <code>CS</code> 和 <code>IP</code> 的指令，而 <code>jmp</code> 属于转移指令中的无条件转移指令</p>
<p>若要同时修改 <code>CS:IP</code> 的内容，可使用 <code>jmp 段地址:偏移地址</code> 的指令来完成，用指令中给出的段地址修改 <code>CS</code>，偏移地址修改 <code>IP</code></p>
<p><code>jmp 某一合法寄存器</code> 指令的功能为：用寄存器中的值修改 <code>IP</code>，例如 <code>jmp ax</code> 在含义上好似：<code>mov IP,ax</code></p>
<h3 id="实验任务（3）"><a class="header-anchor" href="#实验任务（3）">¶</a>实验任务（3）</h3>
<p>查看内存中的内容</p>
<p>PC 机主板上的 ROM 中写有一个生产日期，在内存 <code>FFF00H ~ FFFFFH</code> 的某几个单元中，请找到这个生产日期并试图改变它</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/FFFF0H.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/8086PC%E6%9C%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.PNG"/></div><br>
<p>向地址 <code>C0000 ~ FFFFF</code> 的内存单元中写入数据的操作是无效的，只读存储器中的内容不可修改</p>
<h3 id="实验任务（4）"><a class="header-anchor" href="#实验任务（4）">¶</a>实验任务（4）</h3>
<p>向内存从 <code>B8100H</code> 开始的单元中填写数据，如：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">-e B810:<span class="number">0000</span> <span class="number">01</span> <span class="number">01</span> <span class="number">02</span> <span class="number">02</span> <span class="number">03</span> <span class="number">03</span> <span class="number">04</span> <span class="number">04</span></span><br></pre></td></tr></table></figure>
<p>填写不同的数据，观察现象；改变填写的地址，观察现象</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E5%86%99%E6%98%BE%E5%AD%981.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E5%86%99%E6%98%BE%E5%AD%982.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/%E5%86%99%E6%98%BE%E5%AD%983.PNG"/></div><br>
<p>内存地址空间中，<code>B8000H ~ BFFFFH</code> 共 32 KB 的空间为 80 x 25 彩色字符模式的显示缓冲区，向这个地址空间写入数据，写入的内容将立即出现在显示器上</p>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>模电第四次作业</title>
    <url>/2020/05/04/%E6%A8%A1%E7%94%B5%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>使用教材：<br>
清华大学电子学教研组编 . 杨素行主编 . 模拟电子技术基础简明教程 . 3版 . 北京：高等教育出版社，2006.<br>
作业内容：<br>
模电作业是这样的：<br>
第六章可以做1 2 3 6 7 8题以及PPT上一题<br>
5月8号前交</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="6-1-6-3"><a class="header-anchor" href="#6-1-6-3">¶</a>6-1 &amp;&amp; 6-3</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-3-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-3.PNG" alt="avatar"><br>
<br><br>
<strong>反馈的极性可以使用瞬时极性法判断：</strong><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-5.PNG" alt="avatar"><br>
<br><br>
<strong>交流负反馈的组态判断：</strong></p>
<p>（1）从输出端的判别上分为电压、电流负反馈<br>
使用<strong>交流短路法</strong>：将输出电压 $u_o$ 交流短路，分析反馈信号是否还存在<br>
若反馈信号消失，则为电压负反馈，反之，则为电流负反馈</p>
<p>（2）从反馈信号与输入信号在输入回路中的<strong>叠加方式</strong>上分为串联、并联负反馈<br>
若反馈信号与输入信号在输入回路中以电压形式求和，则为串联负反馈<br>
若反馈信号与输入信号在输入回路中以电流形式求和，则为并联负反馈<br>
简单的说，看反馈信号与输入信号在不在同一个端子上，<strong>异串同并</strong></p>
<h3 id="a"><a class="header-anchor" href="#a">¶</a>a</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-a-3.PNG" alt="avatar"></p>
<p>上图中共有四个反馈支路：<br>
由 $R_F$ 和 $C_F$ 引回的级间反馈是<strong>交流正反馈</strong><br>
由 $R_{e1}$ 既引入了交流负反馈也引入了直流负反馈，其中交流负反馈的组态为<strong>电流串联负反馈</strong><br>
可以稳定本级工作电流，提高输入电阻<br>
由 $R_{e2}$ 与 $C_e$ 引入的是<strong>直流负反馈</strong>（由于旁路电容 $C_e$ 的存在）<br>
由 $R_{e3}$ 既引入了交流负反馈也引入了直流负反馈，其中交流负反馈的组态为<strong>电压串联负反馈</strong><br>
可以稳定输出电压，提高本级输入电阻，降低输出电阻</p>
<h3 id="b"><a class="header-anchor" href="#b">¶</a>b</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-b-3.PNG" alt="avatar"></p>
<p>上图中共有四个反馈支路：<br>
由 $R_F$ 引回的级间反馈既有交流负反馈也有直流负反馈，且交流负反馈的组态为<strong>电流串联负反馈</strong><br>
可以稳定输出电流，提高输入电阻<br>
由 $R_{e1}$ 既引入了直流负反馈也引入了交流负反馈，其中交流负反馈的组态为<strong>电流串联负反馈</strong><br>
可以稳定本级工作电流，提高输入电阻<br>
由 $R_{e2}$ 与 $C_e$ 引入的是<strong>直流负反馈</strong>（由于旁路电容 $C_e$ 的存在）<br>
由 $R_{e3}$ 引入了交直流负反馈，其中交流负反馈的组态为<strong>电流串联负反馈</strong><br>
对本级作用与 $R_{e1}$ 相同</p>
<p>以（b）为例，说明一下<strong>瞬时极性法的使用步骤</strong>：</p>
<blockquote>
<p>首先，不妨设输入端的正极性端有一个瞬时的电压正增量<br>
那么就会引起 $VT_1$ 管的基极电压出现一个正增量，从而引起 $VT_1$ 管有一个向下的电流增量<br>
使得发射极电位有一个正增量，可判断 $R_{e1}$ 所在支路引起的是本级的负反馈<br>
集电极电位出现一个负增量，使得 $VT_2$ 管的基极电位有一个负增量<br>
$VT_2$ 管是一个PNP型的管子，分析方法与NPN管类似<br>
由$VT_2$ 管的基极电位负增量引起由发射极向集电极方向的电流增量<br>
使得发射极电位出现一个负增量，可判断 $R_{e2}$ 与 $C_e$ 所在支路引入的是本级的负反馈<br>
集电极电位出现一个正增量<br>
于是 $VT_3$ 管的情况与 $VT_1$ 管的情况一样，发射极电位出现一个正增量<br>
即 $R_{e3}$ 引入了本级的负反馈<br>
$R_F$ 所在支路使得 $VT_3$ 管发射极的正增量影响到 $VT_1$ 管的发射极又有一个正增量<br>
于是 $R_F$ 所在支路引入了级间的负反馈</p>
</blockquote>
<h3 id="c"><a class="header-anchor" href="#c">¶</a>c</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-c-2.PNG" alt="avatar"></p>
<p>上图中共有三个反馈支路：<br>
由 $R_F$ 引回的级间反馈是交直流负反馈，且交流负反馈的组态为<strong>电流并联负反馈</strong><br>
可以稳定输出电流<br>
由 $R_{e1}$ 引入了交直流负反馈，其中交流负反馈的组态为<strong>电流串联负反馈</strong><br>
可以稳定本级工作电流，提高本级输入电阻<br>
由 $R_{e2}$ 与 $C_e$ 引入的是<strong>直流负反馈</strong>（由于旁路电容 $C_e$ 的存在）</p>
<h3 id="d"><a class="header-anchor" href="#d">¶</a>d</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-d-2.PNG" alt="avatar"></p>
<p>上图中共有两个反馈支路：<br>
由 $R_F$ 引回的级间反馈是交流负反馈，其组态为<strong>电压并联负反馈</strong><br>
可以稳定输出电压，降低输出电阻<br>
由 $R_{e1}$ 引入了交直流负反馈，其中交流负反馈的组态为<strong>电流串联负反馈</strong><br>
可以稳定本级工作电流，提高输入电阻</p>
<h3 id="e"><a class="header-anchor" href="#e">¶</a>e</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-e-2.PNG" alt="avatar"></p>
<p>上图中共有两个反馈支路：<br>
由 $R_F$ 引回的级间反馈是交直流负反馈，其中交流负反馈的组态为<strong>电压串联负反馈</strong><br>
可以稳定输出电压，提高输入电阻，降低输出电阻<br>
由 $R_{e3}$ 引入了交直流负反馈，其中交流负反馈的组态为<strong>电流串联负反馈</strong><br>
可以稳定本级工作电流，提高本级输入电阻</p>
<h3 id="f"><a class="header-anchor" href="#f">¶</a>f</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-f-2.PNG" alt="avatar"></p>
<p>上图中共有两个反馈支路：<br>
由 $C_3$ 与 $R_b$ 引回的本级反馈为<strong>交流正反馈</strong>（电压并联）<br>
由 $R_e$ 引入了交直流负反馈，其中交流负反馈为<strong>电压串联负反馈</strong><br>
即射极输出器本身的电压串联负反馈，故有稳定输出电压，提高输入电阻，降低输出电阻的作用</p>
<p><strong>其实 $C_3$ 还有一个作用呢qwq</strong></p>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-f-3.png" alt="avatar"></p>
<p>如果没有接电容 $C_3$ ，如上图所示，可知其输入电阻约为：$R_i=R_b+R_1//R_2$<br>
（即忽略基极电流）<br>
现由$C_3$ 与 $R_b$ 引回一个交流正反馈，由其交流通路：<br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-1-f-5.PNG" alt="avatar"><br>
在中频段时，电容 $C_3$ 可视为短路，则电阻 $R_b$ 两端电压约为 $\dot U_i-\dot U_o$<br>
则流过电阻 $R_b$ 的电流约为 ${\dfrac {\dot U_i-\dot U_o}{R_b}}$<br>
忽略基极电流，则可将流过电阻 $R_b$ 的电流视为输入电流</p>
<p>则可求得输入电阻为：$R_i={\dfrac {\dot U_i}{\dot I_i}}={\dfrac{\dot U_i}{\dfrac {\dot U_i-\dot U_o}{R_b}}}={\dfrac {\dot U_i\cdot R_b}{\dot U_i-\dot U_o}}$</p>
<p>又由于该电路为射极输出器电路，其电压放大倍数近似于 $1$ （$&lt;1$）</p>
<p>即其基极电位与发射极电位近似，有：$\dot U_i\approx \dot U_o$ 那么则有：$R_i\to\infty$</p>
<p>大大地提高了其输入电阻</p>
<p>这种方法又称为“<strong>自举</strong>”：将输出电压通过电容引回到输入回路以提高输入电阻</p>
<p>可通过看书上 <strong>例6.4.3</strong> 加深理解</p>
<hr>
<h2 id="6-2-6-3"><a class="header-anchor" href="#6-2-6-3">¶</a>6-2 &amp;&amp; 6-3</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-2.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-3-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-3.PNG" alt="avatar"></p>
<h3 id="a-v2"><a class="header-anchor" href="#a-v2">¶</a>a</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-a-1.PNG" alt="avatar"><br>
<strong>正反馈</strong><br>
（正反馈也有组态的吗？ 如果有的话，这里应为电压并联吧）</p>
<h3 id="b-v2"><a class="header-anchor" href="#b-v2">¶</a>b</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-b-2.png" alt="avatar"><br>
由 $R_{F1}$ 引入的是<strong>电压并联负反馈</strong><br>
可以稳定输出电压，降低输出电阻<br>
由 $R_{F2}$ 引入的是<strong>正反馈</strong>（电压串联）</p>
<h3 id="c-v2"><a class="header-anchor" href="#c-v2">¶</a>c</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-c-1.PNG" alt="avatar"><br>
<strong>电压并联负反馈</strong><br>
可以稳定输出电压，降低输出电阻</p>
<h3 id="d-v2"><a class="header-anchor" href="#d-v2">¶</a>d</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-d-1.PNG" alt="avatar"><br>
<strong>电流串联负反馈</strong><br>
可以稳定输出电流，提高输入电阻</p>
<h3 id="e-v2"><a class="header-anchor" href="#e-v2">¶</a>e</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-e-1.PNG" alt="avatar"><br>
<strong>电压串联负反馈</strong><br>
可以稳定输出电压，提高输入电阻，降低输出电阻</p>
<h3 id="f-v2"><a class="header-anchor" href="#f-v2">¶</a>f</h3>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-2-f-1.PNG" alt="avatar"><br>
<strong>电流并联负反馈</strong><br>
可以稳定输出电流</p>
<hr>
<h2 id="6-6"><a class="header-anchor" href="#6-6">¶</a>6-6</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-6-1.PNG" alt="avatar"><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-6-2.PNG" alt="avatar"></p>
<p>由题意可知，其临界状态为：</p>
${\dfrac {\mathrm{d}A_f/A_f}{\mathrm{d}A/A}}={\dfrac {1}{25}}$
<p>因为有：${\dfrac {\mathrm{d}A_f}{A_f}}={\dfrac {1}{1+AF}}\cdot {\dfrac {\mathrm{d}A_f}{A_f}}$</p>
<p>则可知：${\dfrac {1}{1+AF}}={\dfrac {1}{25}}，1+AF=25，AF=24$</p>
<p>又有：$A_f={\dfrac {A}{1+AF}}$</p>
<p>故：$A=(1+AF)A_f=25\times 100=2500$</p>
$F={\dfrac {24}{2500}}=9.6\times 10^{-3}$
<hr>
<h2 id="6-7"><a class="header-anchor" href="#6-7">¶</a>6-7</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-7-1.PNG" alt="avatar"></p>
<p>由题意可知：</p>
$\dot A_{um}=-100 \ \ \ \ f_L=30Hz\ \ \ \ f_H=3kHz\ \ \ \ \dot F_{uu}=-10\%$
<p>那么则有：</p>
$\dot A_{uf}={\dfrac {\dot A_{um}}{1+\dot A_{um}\dot F_{uu}}}={\dfrac {-100}{1+(-100)\cdot(-0.1)}}\approx -9.09$
<br>
$f_{Lf}={\dfrac {f_L}{1+\dot A_{um}\dot F_{uu}}}={\dfrac {30}{11}}Hz\approx 2.73Hz$
<br>
$f_{Hf}=(1+\dot A_{um}\dot F_{uu})\cdot f_H=11\times 3kHz=33kHz$
<hr>
<h2 id="6-8"><a class="header-anchor" href="#6-8">¶</a>6-8</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-8-1.PNG" alt="avatar"></p>
<p>啥都不用管，先整上<strong>瞬时极性法</strong><br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-8-3.png" alt="avatar"></p>
<p>（1）<br>
共有两条支路为级间反馈：<br>
由 $R_{F1}$ 引入<strong>电压串联负反馈</strong><br>
由 $R_{F2}$ 引入<strong>电流并联负反馈</strong><br>
又有两条支路为本级反馈：<br>
由 $R_{e1}$ 和 $R_{e2}$ 分别引入<strong>电流串联负反馈</strong></p>
<p>（2）<br>
接一个隔直电容 $C_{F1}$ 与 $R_{F1}$ 串联<br>
再接一个旁路电容 $C_{F2}$ 与 $R_{F2}$ 并联</p>
<p>（3）<br>
$C_{F1}$ 与 $R_{F1}$ 引入的交流电压串联负反馈可以稳定输出电压，提高输入电阻，降低输出电阻<br>
$C_{F2}$ 与 $R_{F2}$ 引入的直流负反馈可以稳定各级Q点</p>
<p>（4）<br>
若满足深度负反馈条件<br>
则电压放大倍数可如此估算：</p>
$\dot F_{uu}={\dfrac {\dot U_f}{\dot U_o}}={\dfrac {R_{e1}}{R_{F1}+R_{e1}}}$
<br>
$\dot A_{uf}={\dfrac {1}{\dot F_{uu}}}=1+{\dfrac {R_{F1}}{R_{e1}}}=21$
<hr>
<h2 id="附加题"><a class="header-anchor" href="#附加题">¶</a>附加题</h2>
<p>PPT上一题<br>
瞬时极性法判断正负反馈与组态<br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/ppt-6.jpg" alt="avatar"><br>
<strong>正反馈</strong><br>
如果有组态的话，我想应该是电压串联<br>
附：如果做完了前边的题就一定感觉到了这是道水题（手动狗头）<br>
<img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/ppt-6-1.jpg" alt="avatar"></p>
<h2 id="附图：分立元件反馈判定"><a class="header-anchor" href="#附图：分立元件反馈判定">¶</a>附图：分立元件反馈判定</h2>
<p><img src="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%A8%A1%E7%94%B5%E4%BD%9C%E4%B8%9A/%EF%BC%88%E5%9B%9B%EF%BC%89/6-addition.jpg" alt="avatar"></p>
<hr>
<p>参考文献：<br>
模拟电子技术基础简明教程第3版及其教学指导书</p>
<hr>
]]></content>
      <tags>
        <tag>ANALOG</tag>
        <tag>作业区</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 9</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-9-根据材料编程"><a class="header-anchor" href="#实验-9-根据材料编程">¶</a>实验 9 根据材料编程</h2>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_7.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_4.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_5.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_6.PNG"/></div>
<br>
<p>编写程序的思路并不难，但是一定要计算清楚</p>
<p>首先根据规则，将属性字节写出来<br>
黑底绿色：<code>0 000 0 010</code> 即 <code>02H</code><br>
绿底红色：<code>0 010 0 100</code> 即 <code>24H</code><br>
白底蓝色：<code>0 111 0 001</code> 即 <code>71H</code></p>
<p>显示器为 25 行乘 80 列的规格，算出显示在屏幕中间的情况<br>
黑底绿色在 12 行<br>
绿底红色在 13 行<br>
白底蓝色在 14 行<br>
整体都应位于第 33 列至第 48 列之间<br>
一行共有 80 个字符，占 160 个字节，即 0AH 个字节<br>
那么第 12 行第 1 个字节的偏移应为 6E0H<br>
第 33 列的偏移为 40H</p>
<p>先将要显示的字符的 ASCII 码与其属性字节合并为一个字，倒序压入栈中，全部压入后再弹出至显示缓冲区，栈的大小为 48 个字即 96 个字节</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'welcome to masm!'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">01110001b</span>,<span class="number">00100100b</span>,<span class="number">00000010b</span></span><br><span class="line">      <span class="comment">;白底蓝字，绿底红字，黑底绿字</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">48</span> dup (<span class="number">0</span>)                 <span class="comment">;将要显示的字符先倒序压入栈中</span></span><br><span class="line">                                    <span class="comment">;16*3=48 个字</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data             <span class="comment">;ds 存放 data 段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,stack            <span class="comment">;设置栈空间</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">60h</span>              <span class="comment">;60h 即 96 个字节 = 48 个字 * 2 字节/字         </span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            </span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>               <span class="comment">;用 dx 暂存外层循环的 cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span>               <span class="comment">;设置内层循环的 cx</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s2:</span>      <span class="keyword">dec</span> <span class="built_in">bx</span>                  <span class="comment">;倒序取字符</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>].<span class="number">10h</span>      <span class="comment">;将每个字符的 ASCII 码和属性合并，压入栈中</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">loop</span> s2</span><br><span class="line"></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>               <span class="comment">;恢复外层循环的 cx</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span>           <span class="comment">;显示缓冲区的段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">6e0h</span>             <span class="comment">;第 12 行第 1 个字节的地址偏移</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s3:</span>      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>               <span class="comment">;用 dx 暂存外层循环的 cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span>               <span class="comment">;设置内层循环的 cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">   s4:</span>      <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>].<span class="number">40h</span>[<span class="built_in">si</span>]     <span class="comment">;偏移 64 个字节，使得显示的字符在显示器中央</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span>                <span class="comment">;每次填 2 个字节</span></span><br><span class="line">            <span class="keyword">loop</span> s4</span><br><span class="line"></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">0a0h</span>             <span class="comment">;一行共 80 个字符，160 个字节</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>               <span class="comment">;恢复外层循环的 cx</span></span><br><span class="line">            <span class="keyword">loop</span> s3</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_8.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C9/9_1_9.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 3</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-3-编程、编译、连接、跟踪"><a class="header-anchor" href="#实验-3-编程、编译、连接、跟踪">¶</a>实验 3 编程、编译、连接、跟踪</h2>
<h3 id="实验任务（1）"><a class="header-anchor" href="#实验任务（1）">¶</a>实验任务（1）</h3>
<p>将书上的程序保存为 t1.asm 文件并生成可执行文件 t1.exe</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/edit.PNG"/></div><br>
<div align=center>编辑程序</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/editfile.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/file_t1.PNG"/></div><br>
<div align=center>编译</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/masm_t1.PNG"/></div><br>
<div align=center>链接</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/link_t1.PNG"/></div>
<h3 id="实验任务（2）"><a class="header-anchor" href="#实验任务（2）">¶</a>实验任务（2）</h3>
<p>用 Debug 跟踪 t1.exe 的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/machine_code.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/T命令1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/T命令2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/T命令3.PNG"/></div>
<h3 id="实验任务（3）"><a class="header-anchor" href="#实验任务（3）">¶</a>实验任务（3）</h3>
<p>在 DOS 系统中.EXE 文件中的程序的加载过程</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/.EXE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.PNG"/></div><br>
<p>从上图中可以得到：<code>DS + 10h = CS</code>，即 PSP 区域的大小为256KB，若要查看 PSP 的内容，只需查看以 <code>DS:0</code> 开始的内存单元即可</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/D命令.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/D命令_075C.PNG"/></div>
<h3 id="实验任务（4）"><a class="header-anchor" href="#实验任务（4）">¶</a>实验任务（4）</h3>
<p>计算 1 到 100 的奇数之和（这个题第四版书上没有）</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/odd_add_file.PNG"/></div><br>
<p>这个程序的思路也很简单，设 <code>AX</code> 的初值为 1，<code>BX</code> 的初值为 1，循环变量 <code>CX</code> 的初值为 49，利用循环，每次将 <code>BX</code> 加 2 再加到 <code>AX</code> 上去</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/odd_add_T1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C3/odd_add_T2.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 2</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-2-用机器指令和汇编指令编程"><a class="header-anchor" href="#实验-2-用机器指令和汇编指令编程">¶</a>实验 2 用机器指令和汇编指令编程</h2>
<h3 id="实验任务（1）"><a class="header-anchor" href="#实验任务（1）">¶</a>实验任务（1）</h3>
<p>使用 DeBug，将书上程序段写入内存，逐条执行</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/%E5%88%9D%E5%A7%8B%E5%8C%96.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/%E5%86%99%E5%91%BD%E4%BB%A41.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A41.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/%E6%94%B9CS_IP%E5%9C%B0%E5%9D%80.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/T%E5%91%BD%E4%BB%A41.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/T%E5%91%BD%E4%BB%A42.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/Push_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/stack_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/Push_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/stack_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/pop_ax_bx.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/Push_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/stack_3.PNG"/></div>
<h3 id="实验任务（2）"><a class="header-anchor" href="#实验任务（2）">¶</a>实验任务（2）</h3>
<p>分析：为什么 <code>2000:0 ~ 2000:f</code> 中的内容会发生改变？</p>
<p>按照实验过程进行</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/%E4%BB%BB%E5%8A%A12_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C2/%E4%BB%BB%E5%8A%A12_2.PNG"/></div><br>
<p>观察 <code>2000:0 ~ 2000:f</code> 这一段内存单元的变化，在变化发生之前，我们通过将 <code>SS:SP</code> 指向 <code>2000:0010</code> 这一操作将这段内存当作栈来使用，于是 <code>2000:0010</code> 为栈的栈顶，在 8086CPU 中，入栈时，栈顶从高地址向低地址方向增长，而我们发现，<code>2000:0010</code> 的低地址内存中出现了原来没有的机器码，如下：</p>
<p><code>00 00 00 00 00 00 00 20 00 00 08 01 40 07 A4 01</code></p>
<p>我们知道，8086CPU 的字节序为小端序，可以看出来，这里的 <code>0x01A4</code> 为之后要用到的标志寄存器的值，一共有 16 位，更为明显的是之后的 <code>0x0740</code> 与 <code>0x0108</code>，这显然是当前 <code>CS:IP</code> 的值，之后还有 <code>0x2000</code> 为 <code>AX</code> 的值，我们可以猜测，8086CPU 会将一些寄存器中的值暂存在栈中</p>
<p><a href="https://blog.csdn.net/OrangeHap/article/details/89790409" target="_blank" rel="noopener">这里有比较好的解释</a>，截取一些放在下面</p>
<p>当把 <code>2000:0 ~ 2000:f</code> 作为栈时。系统会把寄存器的一些数据暂存在栈中，以供后续相关操作使用，如数据 <code>CS:IP</code> 先后得到暂存</p>
<p>通过了解，知道了 dos 下系统只有一个栈，也就是说，外部操作未设置栈时，系统自己已经有一个栈在做暂存等相关工作了，当外部进行设置时，暂存等工作就发生在新栈中，因此没有进行 <code>push</code> 前系统已经先用来暂存相关数据了，这就是我们看到数据的原因</p>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 8</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-8-分析一个奇怪的程序"><a class="header-anchor" href="#实验-8-分析一个奇怪的程序">¶</a>实验 8 分析一个奇怪的程序</h2>
<p>可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令</p>
<p>8086CPU 的转移行为：<br>
段内转移：只修改 IP<br>
段间转移：同时修改 CS 和 IP</p>
<p>由于转移指令对 IP 的修改范围不同，段内转移又分为：短转移和（80 ~ 7F）近转移（8000 ~ 7FFF）</p>
<p>依据位移进行转移的 jmp 指令</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jmp</span> short 标号                  <span class="comment">;段内短转移 (IP)=(IP)+8 位位移</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">near</span> <span class="built_in">ptr</span> 标号               <span class="comment">;段内近转移 (IP)=(IP)+16 位位移</span></span><br></pre></td></tr></table></figure>
<p>转移的目的指令在指令中的 jmp 指令</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">far</span> <span class="built_in">ptr</span> 标号                <span class="comment">;段间转移 / 远转移</span></span><br><span class="line">                                <span class="comment">;用标号的段地址与偏移地址修改 CS 和 IP</span></span><br></pre></td></tr></table></figure>
<p>8086CPU 的转移指令分为：<br>
无条件转移指令<br>
条件转移指令<br>
循环指令<br>
过程<br>
中断</p>
<h3 id="检测点-9-1"><a class="header-anchor" href="#检测点-9-1">¶</a>检测点 9.1</h3>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> 内存单元地址       <span class="comment">;段内转移</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> 内存单元地址      <span class="comment">;段间转移</span></span><br></pre></td></tr></table></figure>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_1_1.PNG"/></div>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>段内转移，<code>CS:IP</code> 要指向程序的第一条指令，则目的偏移地址为 0 即可</p>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_2_1.PNG"/></div>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">dd</span> <span class="number">12345678H</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>	<span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="number">0</span>              <span class="comment">;mov [bx],offset start</span></span><br><span class="line">                                <span class="comment">;操作符 offset 可以取得标号的偏移地址</span></span><br><span class="line">	<span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="number">2</span>],<span class="built_in">cs</span></span><br><span class="line">	<span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>段间转移，内存单元高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</p>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_3_3.PNG"/></div>
<p><strong>CS=0006H, IP=00BEH</strong></p>
<h3 id="检测点-9-2"><a class="header-anchor" href="#检测点-9-2">¶</a>检测点 9.2</h3>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jcxz</span> 标号                       <span class="comment">;if((cx)==0) jmp short 标号;</span></span><br></pre></td></tr></table></figure>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_4_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_4_2.PNG"/></div>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2000H</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok</span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">jmp</span> short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">   ok:</span>      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>这里能否将补全的前两句指令替换成 <code>mov cx,ds:[bx]</code>，它们之间的区别是什么？</p>
<p>题目要求在内存 2000H 段中查找第一个值为 0 的字节，而 cx 中存放的是字，直接传送是字操作，因此不能直接传送到 cx 中去，应该传送字节给 cx 的低 8 位 cl，再给其高 8 位 ch 赋 0</p>
<h3 id="检测点-9-3"><a class="header-anchor" href="#检测点-9-3">¶</a>检测点 9.3</h3>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">loop</span> 标号</span><br><span class="line"></span><br><span class="line"><span class="comment">;(cx)--;</span></span><br><span class="line"><span class="comment">;if((cx)≠0) jmp short 标号</span></span><br></pre></td></tr></table></figure>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_5_1.PNG"/></div>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2000H</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line"><span class="symbol">   ok:</span>      <span class="keyword">dec</span> <span class="built_in">bx</span>            <span class="comment">;dec 指令的功能和 inc 相反，dec bx 进行的操作为：(bx)=(bx)-1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">            </span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>loop 指令先要执行 <code>(cx)=(cx)-1</code> 再判断 cx 是否为 0，所以应该先对 cx 加 1</p>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<p>分析下面的程序，在运行前思考：这个程序可以正确返回吗？</p>
<p>运行后思考：为什么会是这种结果？</p>
<p>通过这个程序加深对相关内容的理解。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">nop</span></span><br><span class="line">            <span class="keyword">nop</span></span><br><span class="line">      </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,offset s</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset s2</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">jmp</span> short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">   </span><br><span class="line"><span class="symbol">   s2:</span>      <span class="keyword">jmp</span> short s1</span><br><span class="line">            <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">      </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p><strong>这个程序可以正确返回</strong></p>
<p>程序读上去的确非常奇怪，但是其中蕴含着一个简单而又深刻的原理，那就是此处 CPU 在执行 jmp 指令时并不需要转移的目标地址</p>
<p>我们来看程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>],<span class="built_in">ax</span></span><br></pre></td></tr></table></figure>
<p>执行完这两句指令后，我们可能会错误地以为，<code>cs:[si]</code> 处的指令 <code>jmp short s1</code> 通过 ax 寄存器传送到了 <code>cs:[di]</code> 处，即标号 s 处，然后接下来程序转移到标号 s 处，再转移到标号 s1 处，似乎程序无法正确返回</p>
<p>而实际上，通过 ax 转移的不是 <code>jmp short s1</code> 这句指令，而是这句指令的编译后的机器码，我们用 Debug 跟踪可知，编译后的机器码为 <code>EBF6</code>，其中 EB 代表 jmp 指令，F6 则不是转移的目标地址，而是要转移的位移</p>
<p>这个位移我们显然是可以计算出来的，回忆一下 CPU 执行指令的过程：<br>
1）从 <code>CS:IP</code> 指向内存单元读取指令，读取的指令进入指令缓冲器<br>
2）(IP)=(IP)+所读取指令的长度，从而指向下一条指令<br>
3）执行指令，转到 1），重复这个过程</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">s1:</span>     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                <span class="comment">;B80000</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">21h</span>                 <span class="comment">;CD21</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                <span class="comment">;B80000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s2:</span>     <span class="keyword">jmp</span> short s1            <span class="comment">;EBF6</span></span><br><span class="line">        <span class="keyword">nop</span>                     <span class="comment">;90</span></span><br></pre></td></tr></table></figure>
<p>所以这个位移不是标号 s2 到标号 s1 的差值，而是 <code>jmp short s1</code> 后一条指令的地址与标号 s1 的差值，这个差值即为中间指令机器码的长度（包括 <code>jmp short s1</code> 的长度），此处为 10 个字节，又因为是向低地址方向转移，所以位移为 -10，它的二进制补码即为 F6</p>
<p>知道这点后，我们就明白，当程序跳转到标号 s 处时，CPU 读取程序复制过来的内容，然后使 (IP)=(IP)+2，然后执行向低地址方向作 10 个字节的位移（短转移），此时 <code>CS:IP</code> 指向 <code>mov ax,4c00h</code>，于是程序得以正确返回</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_6_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_6_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_6_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_6_4.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C8/8_6_5.PNG"/></div>
<br>
<p>补充材料：《深入理解计算机系统》</p>
<p>3.6.4 跳转指令的编码</p>
<p>在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是 <strong>PC 相对的</strong>（<strong>PC-relative</strong>）。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、2 或 4 个字节。第二种编码方法是给出“绝对”地址，用 4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<p>更深入的：7.7.2 重定位符号引用</p>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 5</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-5-编写、调试具有多个段的程序"><a class="header-anchor" href="#实验-5-编写、调试具有多个段的程序">¶</a>实验 5 编写、调试具有多个段的程序</h2>
<p>实现功能：利用栈，将程序中定义的数据逆序存放</p>
<p>在代码段中使用数据和栈</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                              <span class="comment">;用 dw 定义 16 个字型数据，在程序加载后，将取得 16 个字的</span></span><br><span class="line">                              <span class="comment">;内存空间，存放这 16 个数据。在后面的程序中将这段</span></span><br><span class="line">                              <span class="comment">;空间当作栈来使用</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>         </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">30h</span>        <span class="comment">;将设置栈顶 ss:sp 指向 cs:30</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">push</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s            <span class="comment">;以上将代码段 0~15 单元中的 8 个字型数据依次入栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">pop</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s0           <span class="comment">;以上依次出栈 8 个字型数据到代码段 0~15 单元中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start                     <span class="comment">;指明程序的入口在 start 处</span></span><br></pre></td></tr></table></figure>
<br>
<p>我们用 <code>dw</code> 在程序中写入了 16 个字型数据，即开辟了 32 个字节的内存空间（可以通过定义数据来取得一定容量的内存空间），在之后的程序中，我们设置 <code>ss:sp</code> 指向 <code>cs:30</code>，把这段内存空间（<code>cs:10 ~ cs:2F</code>）当作栈空间，注意 <code>ss:sp</code> 指向的是栈底，入栈时，栈顶从高地址向低地址方向增长</p>
<p>我们知道，在单任务系统中，可执行文件中的程序执行过程如下：</p>
<ol>
<li>由其他的程序（Debug、command 或其他程序）将可执行文件中的程序加载入内存</li>
<li>设置 <code>CS:IP</code> 指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行</li>
<li>程序运行结束后，返回到加载者</li>
</ol>
<p>我们在程序中用伪指令 <code>end</code> 指明程序的入口在何处，<code>end start</code> 即说明程序的入口在标号 <code>start</code> 处，通过这种方式使得 <code>CS:IP</code> 能够正确地指向程序的入口</p>
<p>在 8086 模式下，一个段的容量不能大于 64 KB，再者，将所有的数据、栈和代码都放在同一个段中使得程序显得混乱，考虑用多个段来存放数据、代码和栈</p>
<br>
<p>实现功能：利用栈，将程序中定义的数据逆序存放</p>
<p>将数据、代码、栈放入不同的段</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line"></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack      </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">20h</span>        <span class="comment">;设置栈顶 ss:sp 指向 stack:20</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>         <span class="comment">;ds 指向 data 段</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>          <span class="comment">;ds:bx 指向 data 段中的第一个单元</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s            <span class="comment">;以上将 data 段中的 0~15 单元中的 8 个字型数据依次入栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s0           <span class="comment">;以上依次出栈 8 个字型数据到 data 段的 0~15 单元中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>在一个段中，数据的段地址可由段名代表，程序中对段名的引用将被编译器处理为一个表示段地址的数值，因此在编写程序时不能将其直接送入段寄存器，数据的偏移地址取决于它在段中的位置</p>
<p>注意，伪指令 <code>assume</code> 并不能使 CPU 将 <code>cs</code> 指向 <code>code</code>、<code>ds</code> 指向 <code>data</code>、<code>ss</code> 指向 <code>stack</code>，CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是由程序中具体的汇编指令和其对 <code>CS:IP</code>、<code>SS:SP</code>、<code>DS</code> 等寄存器的设置来决定的</p>
<h3 id="实验任务（1）"><a class="header-anchor" href="#实验任务（1）">¶</a>实验任务（1）</h3>
<p>将下面的程序编译、连接，用 Debug 加载、跟踪，然后回答问题</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code, <span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_1_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_1_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_1_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_1_4.PNG"/></div>
<div align=left>程序将 <code>data</code> 段的数据入栈再出栈，在顺序上也对应，因此不会改变 <code>data</code> 段数据的值</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_1_D命令.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_1_U命令.PNG"/></div><br>
<p>CPU 执行程序，程序返回前，data 段中的数据为多少？<br>
CPU 执行程序，程序返回前，cs = ____ ss = ____ ds = ____。<br>
设程序加载后，code 段的段地址为 X, 则 data 段的段地址为 ____ ，stack 段的段地址为 ____。</p>
<p>data 段中的数据未改变<br>
cs = 076EH, ss = 076DH, ds = 076CH<br>
code 段的段地址为 X，则 data 段的段地址为 X-2, stack 段的段地址为 X-1</p>
<h3 id="实验任务（2）"><a class="header-anchor" href="#实验任务（2）">¶</a>实验任务（2）</h3>
<p>将下面的程序编译、连接，用 Debug 加载、跟踪，然后回答问题</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0123H</span>,<span class="number">0456H</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_4.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_D命令1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_D命令2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_D命令3.PNG"/></div><br>
<p>CPU 执行程序，程序返回前，data 段中的数据为多少？<br>
CPU 执行程序，程序返回前，cs = ____ ss = ____ ds = ____。<br>
设程序加载后，code 段的段地址为 X, 则 data 段的段地址为 ____ ，stack 段的段地址为 ____。<br>
对于如下定义的段：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">name <span class="meta">segment</span></span><br><span class="line">...</span><br><span class="line">name ends</span><br></pre></td></tr></table></figure>
<p>如果段中的数据占 N 个字节，则程序加载后，该段实际占有的空间为 ____。</p>
<p>data 段中的数据未改变<br>
cs = 076EH, ss = 076DH, ds = 076CH<br>
code 段的段地址为 X，则 data 段的段地址为 X-2, stack 段的段地址为 X-1</p>
<p>修改程序，改变数据与栈的长度</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_2_space.PNG"/></div><br>
<p>用 Debug 跟踪修改后的程序的运行，观察到 <code>data</code> 段的起始地址为 <code>076C:0</code>，<code>stack</code> 段的起始地址为 <code>076E:0</code>，<code>code</code> 段的起始地址即程序第一条指令的起始地址为 <code>0770:0</code>，发现虽然 <code>data</code> 段中只存放了 24 个字节、<code>stack</code> 段也只开了 20 个字节作为栈空间，但实际上，两个段都占有 32 个字节的空间</p>
<p>可以得出，实际占有空间为 $⌈\dfrac{N}{16}⌉ · 16$ ( ⌈…⌉ 为向上取整 )</p>
<h3 id="实验任务（3）"><a class="header-anchor" href="#实验任务（3）">¶</a>实验任务（3）</h3>
<p>将下面的程序编译、连接，用 Debug 加载、跟踪，然后回答问题</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0123H</span>,<span class="number">0456H</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_3_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_3_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_3_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_3_4.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_3_D命令.PNG"/></div><br>
<p>CPU 执行程序，程序返回前，data 段中的数据为多少？<br>
CPU 执行程序，程序返回前，cs = ____ ss = ____ ds = ____。<br>
设程序加载后，code 段的段地址为 X, 则 data 段的段地址为 ____ ，stack 段的段地址为 ____。</p>
<p>data 段中的数据未改变<br>
cs = 076CH, ss = 0770H, ds = 076FH<br>
code 段的段地址为 X，则 data 段的段地址为 X+3, stack 段的段地址为 X+4</p>
<h3 id="实验任务（4）"><a class="header-anchor" href="#实验任务（4）">¶</a>实验任务（4）</h3>
<p>如果将(1) (2) (3)中的最后一条伪指令 <code>end start</code> 改为 <code>end</code> （也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。</p>
<p>(3) 仍可以正确执行<br>
<code>end start</code> 改为 <code>end</code> 后，<code>cs:ip</code> 指向程序的首地址，只有 (3) 中的程序加载后 <code>cs:ip</code> 指向的是代码段</p>
<h3 id="实验任务（5）"><a class="header-anchor" href="#实验任务（5）">¶</a>实验任务（5）</h3>
<p>程序如下，编写 code 段的代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">a <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      </span><br><span class="line">            ?</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>完整程序如下</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">a <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,a</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>+<span class="number">16</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>+<span class="number">32</span>],<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>在编写程序时，我们通过前面的实验知道了如何推算一个段具体占有多少内存空间，那么当我们知道 <code>a</code> 段的起始地址为 <code>a:0</code> 时，我们就可以推出 <code>b</code> 段的起始地址为 <code>a:0+16</code>，<code>c</code> 段的起始地址为 <code>a:0+32</code>，从而使得在我们的程序中只需要用寄存器取一个段地址即可</p>
<p>注意，<code>dw</code> 的含义是定义字型数据，<code>dw</code> 即 <code>define word</code>，字型数据可以直接放入寄存器中去，因为数据寄存器的大小也是一个字的大小，而 <code>db</code> 的含义是定义字节型数据，<code>db</code> 即 <code>define byte</code>，字节型数据应该使用数据寄存器的高 8 位或是低 8 位进行存放</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_5_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_5_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_5_3.PNG"/></div>
<h3 id="实验任务（6）"><a class="header-anchor" href="#实验任务（6）">¶</a>实验任务（6）</h3>
<p>程序如下，编写 code 段的代码，用 push 指令将 a 段中的前 8 个字型数据，逆序存储到 b 段中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">a <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0ah</span>,<span class="number">0bh</span>,<span class="number">0ch</span>,<span class="number">0dh</span>,<span class="number">0eh</span>,<span class="number">0fh</span>,<span class="number">0ffh</span></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">            ?</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>完整程序如下</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">a <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0ah</span>,<span class="number">0bh</span>,<span class="number">0ch</span>,<span class="number">0dh</span>,<span class="number">0eh</span>,<span class="number">0fh</span>,<span class="number">0ffh</span></span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,a</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,b</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>    <span class="comment">;sub bx,bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">      </span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>将 <code>b</code> 段视为栈空间，将 <code>a</code> 段中的前 8 个字型数据在循环中顺序压入栈中即可</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_6_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C5/5_6_2.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 6</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-6-实践课程中的程序"><a class="header-anchor" href="#实验-6-实践课程中的程序">¶</a>实验 6 实践课程中的程序</h2>
<h3 id="实验任务（1）"><a class="header-anchor" href="#实验任务（1）">¶</a>实验任务（1）</h3>
<p>将课程中所有讲解过的程序上机调试，用 Debug 跟踪其执行过程，并在过程中进一步理解所讲内容。</p>
<h4 id="程序-1"><a class="header-anchor" href="#程序-1">¶</a>程序 1</h4>
<p>在汇编程序中，用 ‘…’ 的方式指名数据是以字符的形式给出的，编译器将把它们转化为相对应的 ASCII 码。</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'unIX'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'foRK'</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="string">'b'</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_1_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_1_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_1_3.PNG"/></div><br>
<p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener"><strong>ASCII</strong></a> ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC 646。ASCII 第一次以规范标准的类型发表是在 1967 年，最后一次更新则是在 1986 年，到目前为止共定义了 128 个字符</p>
<p>ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。标准 ASCII 码也叫基础 ASCII 码，使用 7 位二进制数（剩下的 1 位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符</p>
<p>常用的 ASCII 码</p>
<p>0x30 ~ 0x39 : 字符 1 ~ 9<br>
0x41 ~ 0x5A : 大写字母 A ~ Z<br>
0x61 ~ 0x7A : 小写字母 a ~ z</p>
<h4 id="程序-2"><a class="header-anchor" href="#程序-2">¶</a>程序 2</h4>
<p>在 codesg 中填写代码，将 datasg 中的第一个字符串转化为大写，第二个字符串转化为小写。</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'iNfOrMaTiOn'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">            ?</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>通过查 ASCII 码标准表，我们可以很轻易地看出来，小写字母的 ASCII 码值比大写字母的 ASCII 码值大 20H，那么如果我们能够判断当前字母是大写还是小写，就可以按这个规律进行大小写之间的改变</p>
<p>可惜的是，到这个实验为止，我们还没有接触到能够对字母的大小写进行判断的指令，那么我们必须找到新的规律</p>
<p>从 ASCII 码的二进制形式着手，我们发现，大写字母与其小写字母的二进制表示的唯一区别是第 5 位不相同，例如，小写字母 a 为 <code>0110 0001</code>，大写字母 A 为 <code>0100 0001</code>，那么如果有一个字母，将它的第 5 位置 1 即为小写，置 0 即为大写，这样就避免了判断</p>
<p>注意，将某一位置 0 或置 1 可以使用 <code>and</code> 与 <code>or</code> 指令</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'iNfOrMaTiOn'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg           </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               <span class="comment">;设置 ds 指向 datasg 段</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>                <span class="comment">;ds:bx 指向 'BaSiC' 的第一个字母</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">5</span>                <span class="comment">;设置循环次数 5，为 'BaSiC' 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111B</span>        <span class="comment">;将 al 中的 ASCII 码的第 5 位置为 0，即转化为大写字母</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">5</span>                <span class="comment">;ds:bx 指向 'iNfOrMaTiOn' 的第一个字母</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">11</span>               <span class="comment">;设置循环次数 11，为 'iNfOrMaTiOn' 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00100000B</span>         <span class="comment">;将 al 中的 ASCII 码的第 5 位置为 1，即转化为小写字母</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_2_1.PNG"/></div>
<h4 id="程序-3"><a class="header-anchor" href="#程序-3">¶</a>程序 3</h4>
<p>用 <code>[bx+idata]</code> 来指明内存单元，这种寻址方式被称为寄存器相对寻址，它为高级语言实现数组提供了便利机制</p>
<p>用 Debug 查看内存，结果如下</p>
<p><code>2000:1000</code>   <code>BE 00 06 00 00 00...</code></p>
<p>写出下面的程序执行后，ax、bx、cx 中的内容</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">2000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,[<span class="built_in">bx</span>+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,[<span class="built_in">bx</span>+<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<br>
<p>AX 中为 <code>00BEH</code>，BX 中为 <code>1000H</code>，CX 中为 <code>0606H</code></p>
<p>注意，数据寄存器的大小为一个字，传送进去的数据也应为一个字大小，并且注意是小端序</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_3_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_3_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_3_3.PNG"/></div>
<h4 id="程序-4"><a class="header-anchor" href="#程序-4">¶</a>程序 4</h4>
<p>使用 <code>[bx+idata]</code> 的方式进行数组的处理，在 codesg 中填写代码，将 datasg 中的第一个字符串转化为大写，第二个字符串转化为小写。</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'MinIX'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      </span><br><span class="line">            ?</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>为了简化程序，将两个循环合并成一个循环，可以用 <code>[0+bx]</code> 和 <code>[5+bx]</code> 的方式在同一个循环中定位这两个字符串中的字符，0 和 5 给定两个字符串的起始偏移地址，bx 给定从起始偏移地址开始的相对地址</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'MinIX'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg           </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">5</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]             <span class="comment">;定位第一个字符串中的字符，也可写作 mov al,0[bx]</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">al</span>             </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="number">5</span>+<span class="built_in">bx</span>]           <span class="comment">;定位第二个字符串中的字符，也可写作 mov al,5[bx]</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">al</span>,<span class="number">00100000b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="number">5</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_4_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_4_2.PNG"/></div>
<h4 id="程序-5"><a class="header-anchor" href="#程序-5">¶</a>程序 5</h4>
<p>si 和 di 是 8086CPU 中和 bx 功能相近的寄存器，但 si 和 di 不能够分成两个 8 位寄存器来使用</p>
<p>用 si 和 di 实现将字符串 ‘welcome to masm!’ 复制到它后面的数据区中。</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'welcome to masm!'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'................'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>变址寄存器：SI(source index)、DI(destination index)<br>
用 <code>ds:si</code> 指向要复制的源字符串，用 <code>ds:di</code> 指向复制的目的空间，用循环来完成复制，一次循环复制 2 个字节</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_5_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_5_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_5_3.PNG"/></div>
<h4 id="程序-6"><a class="header-anchor" href="#程序-6">¶</a>程序 6</h4>
<p>用更少的代码，实现问题 7.2 中的程序。</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'welcome to masm!'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'................'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">16</span>[<span class="built_in">si</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>si 与 di 是存在一定的关系的，可以用 si+16 表示 di，这样可以省去一个寄存器</p>
<h4 id="程序-7"><a class="header-anchor" href="#程序-7">¶</a>程序 7</h4>
<p>用 Debug 查看内存，结果如下</p>
<p><code>2000:1000</code>   <code>BE 00 06 00 00 00...</code></p>
<p>写出下面的程序执行后，ax、bx、cx 中的内容</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">si</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">cx</span>,[<span class="built_in">bx</span>+<span class="built_in">di</span>]</span><br></pre></td></tr></table></figure>
<br>
<p>AX 中为 <code>00BEH</code>，BX 中为 <code>1000H</code>，CX 中为 <code>0606H</code></p>
<p>可参考程序 3</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_7_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_7_2.PNG"/></div>
<h4 id="程序-8"><a class="header-anchor" href="#程序-8">¶</a>程序 8</h4>
<p><code>[bx+si+idata]</code> 与 <code>[bx+di+idata]</code> 的含义相似，表示一个偏移地址为 (bx)+(si)+idata 或 (bx)+(di)+idata 的内存单元，这种寻址方式被称为相对基址变址寻址</p>
<p>用 Debug 查看内存，结果如下</p>
<p><code>2000:1000</code>   <code>BE 00 06 00 6A 22...</code></p>
<p>写出下面的程序执行后，ax、bx、cx 中的内容</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bx</span>+<span class="number">2</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,[<span class="built_in">bx</span>+<span class="number">2</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">si</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>,[<span class="built_in">bx</span>+<span class="number">2</span>+<span class="built_in">di</span>]</span><br></pre></td></tr></table></figure>
<br>
<p>AX 中为 <code>0006H</code>，BX 中为 <code>226AH</code>，CX 中为 <code>6A00H</code></p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_8_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_8_2.PNG"/></div><br>
<p>总结比较前面用到的寻址方式</p>
<ol>
<li><code>[idata]</code> 用一个常量来表示地址，可用于直接定位一个内存单元，称为直接寻址</li>
<li><code>[bx]</code> 用一个变量来表示内存地址，可用于间接定位一个内存单元，称为寄存器间接寻址</li>
<li><code>[bx+idata]</code> 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元，称为寄存器相对寻址</li>
<li><code>[bx+si]</code> 用两个变量表示地址，称为基址变址寻址</li>
<li><code>[bx+si+idata]</code> 用两个变量和一个常量表示地址，称为相对基址变址寻址</li>
</ol>
<h4 id="程序-9"><a class="header-anchor" href="#程序-9">¶</a>程序 9</h4>
<p>编程，将 datasg 段中每个单词的头一个字母改为大写字母</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1. file         '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'2. edit         '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'3. search       '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'4. view         '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'5. options      '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'6. help         '</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">6</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="number">3</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>用 bx 定位每行的起始地址，用 3 定位要修改的列，每行的起始地址相差 16，用 <code>[bx+idata]</code> 的方式来对目标单元进行寻址</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_9_1.PNG"/></div>
<h4 id="程序-10"><a class="header-anchor" href="#程序-10">¶</a>程序 10</h4>
<p>编程，将 datasg 段中每个单词改为大写字母。</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'ibm             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dec             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dos             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'vax             '</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      </span><br><span class="line">            ?</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>用 bx 定位每行的起始地址，用 si 定位要修改的列，每行的起始地址相差 16，用 <code>[bx+si]</code> 的方式来对目标单元进行寻址</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'ibm             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dec             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dos             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'vax             '</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]          <span class="comment">;内层循环覆盖了外层循环的循环计数值 CX</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>在上面的程序中，我们进行了二重循环，却只使用了一个循环计数器，造成在进行内层循环的时候，覆盖了外层循环的循环计数值，所以程序是有问题的</p>
<p>我们应该在每次开始内层循环的时候，将外层循环的 cx 中的数值保存起来，在执行外层循环的 loop 指令前，再恢复外层循环的 cx 数值</p>
<p>比如，用寄存器 dx 来临时保存 cx 中的数值</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'ibm             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dec             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dos             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'vax             '</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">cx</span>               <span class="comment">;将外层循环的 cx 值保存在 dx 中</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>                <span class="comment">;cx 设置为内层循环的次数</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>               <span class="comment">;用 dx 中存放的外层循环的计数值恢复 cx</span></span><br><span class="line">            <span class="keyword">loop</span> s0                 <span class="comment">;外层循环的 loop 指令将 cx 中的计数值减 1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>用别的寄存器暂存 cx 中的值只是权宜之计，CPU 中寄存器的数量有限，且大都有各自的任务要做，而程序中经常会出现暂存数据的需求</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'ibm             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dec             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dos             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'vax             '</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>                          <span class="comment">;定义一个字，用来暂存 cx </span></span><br><span class="line">datasg ends</span><br></pre></td></tr></table></figure>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">40H</span>],<span class="built_in">cx</span>                     <span class="comment">;将外层循环的 cx 值保存在 datasg:40H 单元中</span></span><br></pre></td></tr></table></figure>
<br>
<p>可以考虑将暂存的数据放到内存单元中，需要的时候，从内存单元恢复，但如果需要同时保存多个数据的时候，就得记下数据放到了哪个内存单元中，这样会使得程序混乱</p>
<p>一般来说，在需要暂存数据的时候，我们都应该使用栈</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg,<span class="built_in">ss</span>:stacksg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'ibm             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dec             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'dos             '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'vax             '</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg <span class="meta">segment</span>                     <span class="comment">;定义一个段，用来做栈段，容量为 16 个字节</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stacksg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s0:</span>      <span class="keyword">push</span> <span class="built_in">cx</span>                 <span class="comment">;将外层循环的 cx 值压栈</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>                <span class="comment">;cx 设置为内层循环的次数</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span>                  <span class="comment">;从栈顶弹出原 cx 的值，恢复 cx</span></span><br><span class="line">            <span class="keyword">loop</span> s0                 <span class="comment">;外层循环的 loop 指令将 cx 中的计数值减 1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_10_1.PNG"/></div>
<h3 id="实验任务（2）"><a class="header-anchor" href="#实验任务（2）">¶</a>实验任务（2）</h3>
<p>编程，将 datasg 段中每个单词的前 4 个字母改为大写字母。</p>
<br>
<p>用二重循环 + 相对基址变址寻址解决<br>
用 bx 定位每行的起始地址，用 si 定位要修改的列，用 <code>[bx+3+si]</code> 的方式来对目标单元进行寻址</p>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg,<span class="built_in">ss</span>:stacksg</span><br><span class="line"></span><br><span class="line">stacksg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1. display      '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'2. brows        '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'3. replace      '</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'4. modify       '</span></span><br><span class="line">datasg ends </span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stacksg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span>               <span class="comment">;设置栈空间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               </span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span>                <span class="comment">;设置外层循环 cx</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">push</span> <span class="built_in">cx</span>                 <span class="comment">;cx 压栈</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span>                <span class="comment">;设置内层循环 cx</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s2:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>+<span class="number">3</span>+<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="number">3</span>+<span class="built_in">si</span>],<span class="built_in">al</span>        <span class="comment">;将前 4 个字母改为大写字母</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s2</span><br><span class="line"></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">16</span>               <span class="comment">;换行</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span>                  <span class="comment">;退栈，恢复原 cx</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C6/6_11_1.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 17</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-17-编写包含多个功能子程序的中断例程"><a class="header-anchor" href="#实验-17-编写包含多个功能子程序的中断例程">¶</a>实验 17 编写包含多个功能子程序的中断例程</h2>
<h3 id="调用-int-16h-从键盘缓冲区中读取键盘的输入"><a class="header-anchor" href="#调用-int-16h-从键盘缓冲区中读取键盘的输入">¶</a>调用 int 16h 从键盘缓冲区中读取键盘的输入</h3>
<p>BIOS 提供了 int 16h 中断例程供程序员调用。int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为 0</p>
<p>int 16h 中断例程的 0 号功能进行如下的工作<br>
1）检测键盘缓冲区中是否有数据<br>
2）没有则继续做第一步<br>
3）读取缓冲区第一个字单元中的键盘输入<br>
4）将读取的扫描码送入 ah，ASCII 码送入 al<br>
5）将已读取的键盘输入从缓冲区中删除</p>
<p><br><div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_1_1.PNG"/></div><br></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">16h</span>                       <span class="comment">;从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">'r'</span></span><br><span class="line">            <span class="keyword">je</span> red</span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">'g'</span></span><br><span class="line">            <span class="keyword">je</span> green</span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">'b'</span></span><br><span class="line">            <span class="keyword">je</span> blue</span><br><span class="line">            <span class="keyword">jmp</span> short sret</span><br><span class="line"></span><br><span class="line"><span class="symbol">  red:</span>      <span class="keyword">shl</span> <span class="number">ah</span>,<span class="number">1</span>                      <span class="comment">;利用顺序执行的特点，不需要三个全部分开写</span></span><br><span class="line">                                          <span class="comment">;红色左移两位，绿色左移一位，蓝色不移位</span></span><br><span class="line">                                          <span class="comment">;red 0 000 0 100</span></span><br><span class="line"><span class="symbol">green:</span>      <span class="keyword">shl</span> <span class="number">ah</span>,<span class="number">1</span>                      <span class="comment">;green 0 000 0 010</span></span><br><span class="line"></span><br><span class="line"><span class="symbol"> blue:</span>      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span>                 <span class="comment">;blue 0 000 0 001</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">11111000b</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">ah</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="symbol"> sret:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_1_2.PNG"/></div>
<h3 id="接收字符串的输入"><a class="header-anchor" href="#接收字符串的输入">¶</a>接收字符串的输入</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_2_1.PNG"/></div>
<p>程序的处理过程</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_2_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_2_3.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">charstack:</span>  <span class="keyword">jmp</span> short charstart</span><br><span class="line"></span><br><span class="line">      table <span class="built_in">dw</span> charpush,charpop,charshow            <span class="comment">;直接定址表</span></span><br><span class="line">      top   <span class="built_in">dw</span> <span class="number">0</span>                                    <span class="comment">;栈顶（栈中元素的个数）</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">charstart:</span>  <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">2</span>                                <span class="comment">;功能码</span></span><br><span class="line">            <span class="keyword">ja</span> sret                                 <span class="comment">;非法输入处理</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span>                               <span class="comment">;化功能码为地址偏移</span></span><br><span class="line">            <span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> table[<span class="built_in">bx</span>]                  <span class="comment">;调用不同的子程序</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">charpush:</span>   <span class="keyword">mov</span> <span class="built_in">bx</span>,top                              <span class="comment">;top 代表的是一个内存单元</span></span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">si</span>][<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> top                                 <span class="comment">;每压入一个元素就令 top 自增</span></span><br><span class="line">            <span class="keyword">jmp</span> sret</span><br><span class="line"></span><br><span class="line"><span class="symbol">charpop:</span>    <span class="keyword">cmp</span> top,<span class="number">0</span>                               <span class="comment">;退无可退</span></span><br><span class="line">            <span class="keyword">je</span> sret</span><br><span class="line">            <span class="keyword">dec</span> top                                 <span class="comment">;每弹出一个元素就令 top 自减</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,top</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>][<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">jmp</span> sret</span><br><span class="line"></span><br><span class="line"><span class="symbol">charshow:</span>   <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="number">dh</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">dl</span>,<span class="built_in">dl</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">charshows:</span>  <span class="keyword">cmp</span> <span class="built_in">bx</span>,top</span><br><span class="line">            <span class="keyword">jne</span> noempty</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">' '</span></span><br><span class="line">            <span class="keyword">jmp</span> sret</span><br><span class="line"><span class="symbol">noempty:</span>    <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>][<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>+<span class="number">2</span>],<span class="string">' '</span>              <span class="comment">;思考：此两处不加空格会如何</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">jmp</span> charshows</span><br><span class="line"></span><br><span class="line"><span class="symbol">sret:</span>       <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p><br><div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_2_4.PNG"/></div><br></p>
<p>补全接收字符串输入的子程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">getstr:</span>     <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">getstrs:</span>    <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">20h</span></span><br><span class="line">            <span class="keyword">jb</span> nochar                                 <span class="comment">;ASCII 码小于 20h，说明不是字符</span></span><br><span class="line">                                                      <span class="comment">;跳转到 nochar 处理 enter 与 backspace</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> charstack                            <span class="comment">;字符入栈</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">call</span> charstack                            <span class="comment">;显示栈中的字符</span></span><br><span class="line">            <span class="keyword">jmp</span> getstrs                               <span class="comment">;循环等待</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">nochar:</span>     <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">0eh</span>                                <span class="comment">;退格键的扫描码</span></span><br><span class="line">            <span class="keyword">je</span> backspace</span><br><span class="line">            <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">1ch</span>                                <span class="comment">;Enter 键的扫描码</span></span><br><span class="line">            <span class="keyword">je</span> <span class="keyword">enter</span></span><br><span class="line">            <span class="keyword">jmp</span> getstrs</span><br><span class="line"></span><br><span class="line"><span class="symbol">backspace:</span>  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">call</span> charstack                            <span class="comment">;字符出栈</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">call</span> charstack                            <span class="comment">;显示栈中的字符</span></span><br><span class="line">            <span class="keyword">jmp</span> getstrs</span><br><span class="line"></span><br><span class="line"><span class="symbol">enter:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> charstack                            <span class="comment">;0 入栈</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">call</span> charstack                            <span class="comment">;显示栈中的字符</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>测试程序（省略子程序）</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">12</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> getstr</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_2_5.PNG"/></div>
<h3 id="应用-int-13h-中断例程对磁盘进行读写"><a class="header-anchor" href="#应用-int-13h-中断例程对磁盘进行读写">¶</a>应用 int 13h 中断例程对磁盘进行读写</h3>
<p>读取 0 面 0 道 1 扇区的内容到 0:200 的程序如下所示。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">200h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">13h</span></span><br></pre></td></tr></table></figure>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_3_1.PNG"/></div>
<p>将 0:200 中的内容写入 0 面 0 道 1 扇区。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">200h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">13h</span></span><br></pre></td></tr></table></figure>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_3_2.PNG"/></div>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/17_3_3.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">8</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span>      </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/ex17_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/ex17_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C17/ex17_3.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset int7c                       <span class="comment">;设置 ds:si 指向源地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span>                              <span class="comment">;设置 es:di 指向目的地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset int7cend-offset int7c       <span class="comment">;设置 cx 为传输长度</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">cld</span>                                       <span class="comment">;设置传输方向为正</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span>                                 <span class="comment">;串传送操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">cli</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span>               <span class="comment">;设置中断向量表</span></span><br><span class="line">            <span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int7c:</span>      <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">1440</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;面号</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">18</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">;磁道号</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;扇区号</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="number">ah</span>,<span class="number">2</span>                                  <span class="comment">;设置读写功能</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span>                                  <span class="comment">;读写一个扇区</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">in7cret:</span>    <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int7cend:</span>   <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>测试程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">1439</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 11</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-11-编写子程序"><a class="header-anchor" href="#实验-11-编写子程序">¶</a>实验 11 编写子程序</h2>
<h3 id="标志寄存器"><a class="header-anchor" href="#标志寄存器">¶</a>标志寄存器</h3>
<p>8086CPU 中有 16 位标志寄存器（flag），其中存储的信息被称为程序状态字（PSW），其作用有：<br>
1）用来存储相关指令的某些执行结果；<br>
2）用来为 CPU 执行相关指令提供行为依据<br>
3）用来控制 CPU 的相关工作方式</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_0_2.PNG"/></div><br>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%A8-Debug-%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA" target="_blank" rel="noopener">标志寄存器的各个标志位</a></p>
<p>记法：<br>
记它的英文<br>
Carry Flag（CF：进位标志位）<br>
Overflow Flag（OF：溢出标志位）<br>
Direction Flag（DF：方向标志位）<br>
Sign Flag（SF：符号标志位）<br>
Zero Flag（ZF：零标志位）<br>
Parity Flag（PF：奇偶标志位）</p>
<br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_0_3.PNG"/></div>
<br>
<p>pushf 和 popf<br>
pushf：将标志寄存器的值压栈<br>
popf：从栈中弹出数据，送入标志寄存器中</p>
<h3 id="检测点-11-1"><a class="header-anchor" href="#检测点-11-1">¶</a>检测点 11.1</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_1_1.PNG"/></div><br>
<p>mov、push、pop 等传送指令的执行对标志寄存器没有影响<br>
注意 PF 记录的是相关指令执行后其结果的所有 bit 位中的 1 的个数的奇偶，不是结果的奇偶</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sub</span> <span class="built_in">al</span>,<span class="built_in">al</span>         <span class="comment">;ZF = 1, PF = 1, SF = 0 结果为 al=0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span>          <span class="comment">;ZF = 1, PF = 1, SF = 0</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span>           <span class="comment">;ZF = 1, PF = 1, SF = 0</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">bx</span>            <span class="comment">;ZF = 1, PF = 1, SF = 0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="built_in">bl</span>         <span class="comment">;ZF = 0, PF = 0, SF = 0 结果为 al=00000010B</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">10</span>         <span class="comment">;ZF = 0, PF = 1, SF = 0 结果为 al=00001100B</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">al</span>            <span class="comment">;ZF = 0, PF = 1, SF = 0 结果为 ax=0090H</span></span><br></pre></td></tr></table></figure>
<h3 id="检测点-11-2"><a class="header-anchor" href="#检测点-11-2">¶</a>检测点 11.2</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_2_1.PNG"/></div><br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sub</span> <span class="built_in">al</span>,<span class="built_in">al</span>         <span class="comment">;CF = 0, OF = 0, SF = 0, ZF = 1, PF = 1 结果为 al=0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10H</span>        <span class="comment">;CF = 0, OF = 0, SF = 0, ZF = 1, PF = 1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">90H</span>        <span class="comment">;CF = 0, OF = 0, SF = 1, ZF = 0, PF = 1 结果为 al=10100000B</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">80H</span>        <span class="comment">;CF = 0, OF = 0, SF = 1, ZF = 0, PF = 1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">80H</span>        <span class="comment">;CF = 1, OF = 1, SF = 0, ZF = 1, PF = 1 结果为 al=0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0FCH</span>       <span class="comment">;CF = 1, OF = 1, SF = 0, ZF = 1, PF = 1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">05H</span>        <span class="comment">;CF = 1, OF = 0, SF = 0, ZF = 0, PF = 0 结果为 al=1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">7DH</span>        <span class="comment">;CF = 1, OF = 0, SF = 0, ZF = 0, PF = 0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">0BH</span>        <span class="comment">;CF = 0, OF = 1, SF = 1, ZF = 0, PF = 1 结果为 al=10001000B</span></span><br></pre></td></tr></table></figure>
<h3 id="cmp-指令"><a class="header-anchor" href="#cmp-指令">¶</a>cmp 指令</h3>
<p>cmp 是比较指令，它的功能相当于减法指令，但不保存结果，其执行后将对标志寄存器产生影响</p>
<p>cmp 通常与条件转移指令相配合使用，条件转移指令检测标志寄存器的相关标志位，根据检测的结果来决定是否修改 IP</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;指令       ;同义名     ;跳转条件         ;描述</span></span><br><span class="line"><span class="keyword">je</span>          <span class="comment">;jz         ;ZF              ;相等/零</span></span><br><span class="line"><span class="keyword">jne</span>         <span class="comment">;jnz        ;~ZF             ;不相等/非零</span></span><br><span class="line"><span class="keyword">js</span>                      <span class="comment">;SF              ;负数          </span></span><br><span class="line"><span class="keyword">jns</span>                     <span class="comment">;~SF             ;非负数</span></span><br><span class="line"><span class="keyword">jg</span>          <span class="comment">;jnle       ;~(SF^OF)&amp;~ZF    ;有符号大于</span></span><br><span class="line"><span class="keyword">jge</span>         <span class="comment">;jnl        ;~(SF^OF)        ;有符号大于或等于</span></span><br><span class="line"><span class="keyword">jl</span>          <span class="comment">;jnge       ;SF^OF           ;有符号小于</span></span><br><span class="line"><span class="keyword">jle</span>         <span class="comment">;jng        ;(SF^OF)|ZF      ;有符号小于或等于</span></span><br><span class="line"><span class="keyword">ja</span>          <span class="comment">;jnbe       ;~CF&amp;~ZF         ;无符号大于</span></span><br><span class="line"><span class="keyword">jae</span>         <span class="comment">;jnb        ;~CF             ;无符号大于或等于</span></span><br><span class="line"><span class="keyword">jb</span>          <span class="comment">;jnae       ;CF              ;无符号小于</span></span><br><span class="line"><span class="keyword">jbe</span>         <span class="comment">;jna        ;CF|ZF           ;无符号小于或等于</span></span><br></pre></td></tr></table></figure>
<h3 id="检测点-11-3"><a class="header-anchor" href="#检测点-11-3">¶</a>检测点 11.3</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_3_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_3_2.PNG"/></div>
<p>(1)</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">32</span>         <span class="comment">;al &lt; 32</span></span><br><span class="line"><span class="keyword">jb</span> s0</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">128</span>        <span class="comment">;al &gt; 128</span></span><br><span class="line"><span class="keyword">ja</span> s0</span><br></pre></td></tr></table></figure>
<p>(2)</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">32</span>         <span class="comment">;al &lt;= 32</span></span><br><span class="line"><span class="keyword">jna</span> s0</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">128</span>        <span class="comment">;al &gt;= 128</span></span><br><span class="line"><span class="keyword">jnb</span> s0</span><br></pre></td></tr></table></figure>
<p>注意满足逻辑即可</p>
<h3 id="检测点-11-4"><a class="header-anchor" href="#检测点-11-4">¶</a>检测点 11.4</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_4_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_4_2.PNG"/></div>
<p><strong>AX=0045H</strong></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">popf</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0fff0h</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">0010h</span>            <span class="comment">;fff0h + 0010h = 0000h, 注意：of=0</span></span><br><span class="line"><span class="keyword">pushf</span>                   <span class="comment">;此时的标志寄存器：0000 0000 0100 0101</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span>                  <span class="comment">;(ax)=(flag)</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11000101B</span>        <span class="comment">;(al)=01000101B</span></span><br><span class="line"><span class="keyword">and</span> <span class="number">ah</span>,<span class="number">00001000B</span>        <span class="comment">;(ah)=00000000B</span></span><br><span class="line">                        <span class="comment">;(ax) = 0000 0000 0100 0101 B = 0045h = 69</span></span><br></pre></td></tr></table></figure>
<h3 id="一些例程"><a class="header-anchor" href="#一些例程">¶</a>一些例程</h3>
<p>编写子程序，对两个 128 位数据进行相加。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;128 位数据需要 8 个字单元</span></span><br><span class="line"><span class="comment">;ds:si 指向存储第一个数的内存空间</span></span><br><span class="line"><span class="comment">;ds:di 指向存储第二个数的内存空间</span></span><br><span class="line"><span class="comment">;运算结果存储在第一个数的存储空间中</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">add128:</span>     <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">ax</span>         <span class="comment">;将 CF 设置为 0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">     s:</span>     <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">adc</span> <span class="built_in">ax</span>,[<span class="built_in">di</span>]</span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">si</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;inc 指令不能替换成 add 指令</span></span><br><span class="line">            <span class="comment">;inc 指令不影响 cf 位，而 add 指令会影响 cf 位</span></span><br></pre></td></tr></table></figure>
<br>
<p>编程，统计 data 段中数值为 8 的字节个数，用 ax 保存统计结果。</p>
<p>比较下面两个程序的写法，注意使用 cmp 和条件转移指令时的编程思想</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">65</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>                <span class="comment">;ds:bx 指向第一个字节</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                <span class="comment">;初始化累加器</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">8</span>     <span class="comment">;和 8 进行比较</span></span><br><span class="line">            <span class="keyword">jne</span> next                <span class="comment">;如果不相等就转到 next，继续循环</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">ax</span>                  <span class="comment">;如果相等就将计数值加 1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol"> next:</span>      <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s                  <span class="comment">;程序执行后：(ax)=3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">8</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">65</span>,<span class="number">38</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>                <span class="comment">;ds:bx 指向第一个字节</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                <span class="comment">;初始化累加器</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>],<span class="number">8</span>     <span class="comment">;和 8 进行比较</span></span><br><span class="line">            <span class="keyword">je</span> ok                   <span class="comment">;如果相等就转到 ok</span></span><br><span class="line">            <span class="keyword">jmp</span> short next          <span class="comment">;如果不相等就转 next，继续循环</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   ok:</span>      <span class="keyword">inc</span> <span class="built_in">ax</span>                  <span class="comment">;如果相等就将计数值加 1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol"> next:</span>      <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span>                  </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>第一个程序更为精简，它用 jne 指令检测不等于 8 的情况，从而间接地检测了等于 8 的情况</p>
<br>
<p>编程，用串传送指令，将 data 段中的第一个字符串复制到它后面的空间中。</p>
<p>使用串传送指令(<code>rep movsb</code> / <code>rep movsw</code>)进行数据的传送，需要提供<br>
1）传送的原始位置：<code>ds:si</code><br>
2）传送的目的位置：<code>es:di</code><br>
3）传送的长度：<code>cx</code><br>
4）传送的方向：<code>df</code></p>
<p>8086CPU 提供下面两条指令对标志寄存器的 df 位进行设置<br>
cld 指令：将 df 位置 0<br>
std 指令：将 df 位置 1</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'Welcome to masm!'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>          <span class="comment">;ds:di 指向 data:0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span>         <span class="comment">;es:di 指向 data:0010</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span>         <span class="comment">;(cx)=16，rep 循环 16 次</span></span><br><span class="line">            <span class="keyword">cld</span>               <span class="comment">;设置 df=0，正向传送</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<br>
<p>编程，用串传送指令，将 F000H 段中的最后 16 个字符复制到 data 段中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0f000h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0ffffh</span>     <span class="comment">;ds:di 指向 f000:ffff</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">15</span>         <span class="comment">;es:di 指向 data:000f</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span>         <span class="comment">;(cx)=16，rep 循环 16 次</span></span><br><span class="line">            <span class="keyword">std</span>               <span class="comment">;设置 df=1，逆向传送</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/ex11_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/ex11_2.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg</span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">"Beginner's All-purpose Symbolic Instruction Code."</span>,<span class="number">0</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">  begin:</span>    <span class="keyword">mov</span> <span class="built_in">ax</span>,datasg</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> letterc</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">letterc:</span>    <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">     s1:</span>    <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">0</span>        <span class="comment">;检测结束符 0</span></span><br><span class="line">            <span class="keyword">je</span> ok</span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">61h</span>      <span class="comment">;检测是否为 a ~ z 之间的字符</span></span><br><span class="line">            <span class="keyword">jb</span> s2                         <span class="comment">;若不是则直接转移到标号 s2 处</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">7ah</span></span><br><span class="line">            <span class="keyword">ja</span> s2</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]                <span class="comment">;若是则进行大小写转换</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">11011111b</span>              <span class="comment">;也可用 sub al,20h （即 小写字母-20H=大写字母 的关系）</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">     s2:</span>    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">cx</span>                        <span class="comment">;jmp short s1</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line"></span><br><span class="line"><span class="symbol">     ok:</span>    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line">            </span><br><span class="line">codesg ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/ex11_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/ex11_4.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 10</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-10-编写子程序"><a class="header-anchor" href="#实验-10-编写子程序">¶</a>实验 10 编写子程序</h2>
<h3 id="用-call-和-ret-来实现子程序的机制"><a class="header-anchor" href="#用-call-和-ret-来实现子程序的机制">¶</a>用 call 和 ret 来实现子程序的机制</h3>
<p><strong>ret 和 retf 指令</strong></p>
<p>ret 指令用栈中的数据，修改 IP 的内容，从而实现近转移</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ret</span>                           <span class="comment">;pop IP</span></span><br></pre></td></tr></table></figure>
<p>ret 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">retf</span>                          <span class="comment">;pop IP</span></span><br><span class="line">                              <span class="comment">;pop CS</span></span><br></pre></td></tr></table></figure>
<p><strong>call 指令</strong></p>
<p>call 指令进行两步操作，先将当前的 IP 或 CS 和 IP 压入栈中，再进行转移，call 指令不能实现短转移</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;依据位移进行转移的 call 指令</span></span><br><span class="line"><span class="comment">;16 位位移</span></span><br><span class="line"><span class="keyword">call</span> 标号                     <span class="comment">;push IP</span></span><br><span class="line">                              <span class="comment">;jmp near ptr 标号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;转移的目标地址在指令中的 call 指令</span></span><br><span class="line"><span class="comment">;段间转移</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">far</span> <span class="built_in">ptr</span> 标号             <span class="comment">;push CS</span></span><br><span class="line">                              <span class="comment">;push IP</span></span><br><span class="line">                              <span class="comment">;jmp far ptr 标号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;转移地址在寄存器中的 call 指令</span></span><br><span class="line"><span class="keyword">call</span> <span class="number">16</span> 位 reg                <span class="comment">;push IP</span></span><br><span class="line">                              <span class="comment">;jmp 16 位 reg</span></span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;转移地址在内存中的 call 指令</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> 内存单元地址     <span class="comment">;push IP</span></span><br><span class="line">                              <span class="comment">;jmp word ptr 内存单元地址</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> 内存单元地址    <span class="comment">;push CS</span></span><br><span class="line">                              <span class="comment">;push IP</span></span><br><span class="line">                              <span class="comment">;jmp dword ptr 内存单元地址</span></span><br></pre></td></tr></table></figure>
<p><strong>子程序</strong></p>
<p>子程序指一个具有一定功能的程序段，在需要调用子程序时，用 call 指令转去执行，call 指令后面的指令的地址将存储在栈中，在子程序结束时使用 ret 指令，用栈中的数据设置 IP 的值，从而转回 call 指令后面的代码处继续执行</p>
<p>利用 call 和 ret 指令可以用简捷的方法实现多个相互联系、功能独立的子程序来解决一个复杂的问题，这样就实现了程序的模块化设计</p>
<p>子程序的框架如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">标号:</span><br><span class="line">      指令</span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>具有子程序的源程序的框架如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">      :</span><br><span class="line">      :</span><br><span class="line">      <span class="keyword">call</span> sub1               <span class="comment">;调用子程序 sub1</span></span><br><span class="line">      :</span><br><span class="line">      :</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sub1:</span>                         <span class="comment">;子程序 sub1 开始</span></span><br><span class="line">      :</span><br><span class="line">      <span class="keyword">call</span> sub2               <span class="comment">;调用子程序 sub2</span></span><br><span class="line">      :</span><br><span class="line">      :</span><br><span class="line">      <span class="keyword">ret</span>                     <span class="comment">;子程序返回</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sub2:</span>                         <span class="comment">;子程序 sub2 开始</span></span><br><span class="line">      :</span><br><span class="line">      :</span><br><span class="line">      <span class="keyword">ret</span>                     <span class="comment">;子程序返回</span></span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure>
<p>还有两个问题需要考虑：</p>
<p><strong>参数和结果传递的问题</strong><br>
1）使用寄存器传递<br>
2）批量数据放入内存，用寄存器传递内存空间的首地址<br>
3）用栈传递</p>
<p><strong>寄存器冲突的问题</strong><br>
用栈保存寄存器中的内容<br>
编写子程序时使用这样的框架</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">子程序开始: 子程序中使用的寄存器入栈</span><br><span class="line">           子程序内容</span><br><span class="line">           子程序中使用的寄存器出栈</span><br><span class="line">           返回(<span class="keyword">ret</span>, <span class="keyword">retf</span>)</span><br></pre></td></tr></table></figure>
<p>注意理解两个概念：<br>
被调用者保存寄存器：<br>
被调用者保存这些寄存器的值，保证这些寄存器的值在返回（调用结束）后不变<br>
调用者保存寄存器：<br>
调用者在调用之前负责先将这样的寄存器保存好，在调用过程中这些寄存器可以被随意修改，待调用结束后恢复</p>
<h3 id="检测点-10-1"><a class="header-anchor" href="#检测点-10-1">¶</a>检测点 10.1</h3>
<p>补全程序，实现从内存 <code>1000:0000</code> 处开始执行指令</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1000h</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">retf</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>将段地址与偏移地址都压入栈中即可，注意先压段地址再压偏移地址，这样 retf 指令弹出时的顺序才是对的</p>
<h3 id="检测点-10-2"><a class="header-anchor" href="#检测点-10-2">¶</a>检测点 10.2</h3>
<p>下面的程序执行后，ax 中的数值为多少？</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;内存地址         ;机器码           ;汇编指令</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>           b8 <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>           e8 <span class="number">01</span> <span class="number">00</span>          <span class="keyword">call</span> s</span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>           <span class="number">40</span>                <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">7</span>           <span class="number">58</span>              s:<span class="keyword">pop</span> <span class="built_in">ax</span></span><br></pre></td></tr></table></figure>
<p><strong>AX=0006H</strong></p>
<p>call 指令会用栈保存其后的第一个字节的偏移地址，在转入标号 s 后执行 pop 指令，将刚刚的偏移地址从栈中弹入 ax 中</p>
<h3 id="检测点-10-3"><a class="header-anchor" href="#检测点-10-3">¶</a>检测点 10.3</h3>
<p>下面的程序执行后，ax 中的数值为多少？</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;内存地址         ;机器码           ;汇编指令</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>           b8 <span class="number">00</span> <span class="number">00</span>          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>           9A <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">10</span>    <span class="keyword">call</span> <span class="built_in">far</span> <span class="built_in">ptr</span> s</span><br><span class="line"><span class="number">1000</span>:<span class="number">8</span>           <span class="number">40</span>                <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">9</span>           <span class="number">58</span>              s:<span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">                                   <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">                                   <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">                                   <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br></pre></td></tr></table></figure>
<p><strong>AX=1010H</strong></p>
<p>将 <code>call far ptr s</code> 拆解为 <code>push CS</code>、<code>push IP</code>、<code>jmp far ptr s</code> 三步，可知在 s 子程序中的两次弹出后的结果，<code>ax=0008H</code>，<code>bx=1000H</code>，最后结果为 <code>1010H</code></p>
<h3 id="检测点-10-4"><a class="header-anchor" href="#检测点-10-4">¶</a>检测点 10.4</h3>
<p>下面的程序执行后，ax 中的数值为多少？</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;内存地址         ;机器码           ;汇编指令</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">0</span>           b8 <span class="number">06</span> <span class="number">00</span>          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">6</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">3</span>           ff d0             <span class="keyword">call</span> <span class="built_in">ax</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">5</span>           <span class="number">40</span>                <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line"><span class="number">1000</span>:<span class="number">6</span>                             <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">                                   <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ss</span>:[<span class="built_in">bp</span>]</span><br></pre></td></tr></table></figure>
<p><strong>AX=000BH</strong></p>
<p>call 指令会用栈保存其后的第一个字节的偏移地址，所以栈顶为 <code>0005H</code>，因为把 sp 中的值赋给了 bp，那么 <code>ss:[bp]</code> 即为栈顶元素，最后 <code>ax=0006H+0005H=000BH</code></p>
<h3 id="检测点-10-5"><a class="header-anchor" href="#检测点-10-5">¶</a>检测点 10.5</h3>
<h4 id="1"><a class="header-anchor" href="#1">¶</a>(1)</h4>
<p>下面的程序执行后，ax 中的数值为多少？（注意：用 call 指令的原理来分析，不要在 Debug 中单步跟踪来验证你的结论。对于此程序，在 Debug 中单步跟踪的结果，不能代表 CPU 的实际执行结果。）</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span> </span><br><span class="line">      <span class="built_in">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0EH</span>]</span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><strong>AX=0003H</strong></p>
<h4 id="2"><a class="header-anchor" href="#2">¶</a>(2)</h4>
<p>下面的程序执行后，ax 和 bx 中的数值为多少？</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="number">0</span>],offset s</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>:[<span class="number">2</span>],<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,offset s</span><br><span class="line">            <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="built_in">ss</span>:[<span class="number">0ch</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="built_in">ss</span>:[<span class="number">0eh</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><strong>AX=0001H, BX=0000H</strong></p>
<p>这两题都可以通过画栈的示意图来得出答案，非常简单明了</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/stack.PNG"/></div>
<h3 id="问题-10-1"><a class="header-anchor" href="#问题-10-1">¶</a>问题 10.1</h3>
<p>call 和 ret 的配合使用</p>
<p>下面程序返回前，bx 中的值是多少？</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line">      <span class="keyword">call</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>         <span class="comment">;(bx)=? bx=8</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">    s:</span><span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">ret</span>               <span class="comment">;call 与 ret 的配合使用 </span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><strong>BX=0008H</strong></p>
<p>程序返回前，(bx)=8。可以看出，从标号 s 到 ret 的程序段的作用是计算 2 的 N 次方，计算前，N 的值由 cx 提供</p>
<h3 id="参数和结果传递的问题"><a class="header-anchor" href="#参数和结果传递的问题">¶</a>参数和结果传递的问题</h3>
<p>编程，计算 data 段中第一组数据的 3 次方，结果保存在后面一组 dword 单元中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">      <span class="built_in">dd</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>                <span class="comment">;ds:si 指向第一组 word 单元</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">16</span>               <span class="comment">;ds:di 指向第二组 dword 单元</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">bx</span>,[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">call</span> cube</span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">di</span>],<span class="built_in">ax</span>       </span><br><span class="line">            <span class="keyword">mov</span> [<span class="built_in">di</span>].<span class="number">2</span>,<span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span>                <span class="comment">;ds:si 指向下一个 word 单元</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">4</span>                <span class="comment">;ds:di 指向下一个 dword 单元</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;说明：计算 N 的 3 次方</span></span><br><span class="line"><span class="comment">;参数：(bx)=N</span></span><br><span class="line"><span class="comment">;结果：(dx:ax)=N^3</span></span><br><span class="line"><span class="symbol"> cube:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="built_in">bx</span>                  <span class="comment">;另一个乘数默认在 ax 中，进行的是 16 位的乘法</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="built_in">bx</span>                  <span class="comment">;结果高位存放在 dx 中，低位存放在 ax 中</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure> 
<p>对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器中取到返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器</p>
<h3 id="批量数据的传递"><a class="header-anchor" href="#批量数据的传递">¶</a>批量数据的传递</h3>
<p>设计一个子程序，功能：将一个全是字母的字符串转化为大写。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">capital:</span>    <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span>   <span class="comment">;将 ds:si 所指单元中的字母转化为大写</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span>                        <span class="comment">;ds:si 指向下一单元</span></span><br><span class="line">            <span class="keyword">loop</span> capital</span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>编程，将 data 段中的字符串转化为大写。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'conversation'</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>                      <span class="comment">;ds:si 指向字符串（批量数据）所有空间的首地址</span></span><br><span class="line">                                          <span class="comment">;将字符串在内存中的首地址放在寄存器中传递给子程序</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">12</span>                     <span class="comment">;设置 cx 为字符串的长度</span></span><br><span class="line">            <span class="keyword">call</span> capital</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序需要知道字符串的内容和字符串的长度</span></span><br><span class="line"><span class="symbol">capital:</span>    <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> capital</span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h3 id="栈在参数传递中的应用"><a class="header-anchor" href="#栈在参数传递中的应用">¶</a>栈在参数传递中的应用</h3>
<p>通过一个 C 语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用。<br>
要注意的是，在 C 语言中，局部变量也在栈中存储。</p>
<p><strong>C 程序</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">      add(a,b,c);             ;该函数不改变 c(main) 的值</span><br><span class="line">      c++;                    ;c=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">      c = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译后的汇编程序</strong></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">sp</span>,<span class="number">6</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bp</span>-<span class="number">6</span>],<span class="number">0001</span>      <span class="comment">;int a = 1;</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bp</span>-<span class="number">4</span>],<span class="number">0002</span>      <span class="comment">;int b = 2;</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bp</span>-<span class="number">2</span>],<span class="number">0000</span>      <span class="comment">;int c = 0;</span></span><br><span class="line"><span class="keyword">push</span> [<span class="built_in">bp</span>-<span class="number">2</span>]</span><br><span class="line"><span class="keyword">push</span> [<span class="built_in">bp</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">push</span> [<span class="built_in">bp</span>-<span class="number">6</span>]                   <span class="comment">;参数传递</span></span><br><span class="line"><span class="keyword">call</span> ADDR                     <span class="comment">;调用函数</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">sp</span>,<span class="number">6</span>                      <span class="comment">;释放函数中局部变量的空间</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bp</span>-<span class="number">2</span>]           <span class="comment">;c++;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">ADDR:</span> <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">4</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">ax</span>,[<span class="built_in">bp</span>+<span class="number">6</span>]</span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">bp</span>+<span class="number">8</span>],<span class="built_in">ax</span>           <span class="comment">;c=a+b=4;</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>可以用一个栈的示意图来帮助我们更好的理解</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/stack2.PNG"/></div>
<h3 id="寄存器冲突的问题-问题-10-2"><a class="header-anchor" href="#寄存器冲突的问题-问题-10-2">¶</a>寄存器冲突的问题 - 问题 10.2</h3>
<p>设计一个子程序，功能：将一个全是字母，以 0 结尾的字符串，转化为大写。</p>
<p>程序要处理的字符串以 0 作为结尾符，这个字符串可以如下定义：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">db</span> <span class="string">'conversation'</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>设计子程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;说明：将一个全是字母，以 0 结尾的字符串，转化为大写</span></span><br><span class="line"><span class="comment">;参数：ds:si 指向字符串的首地址</span></span><br><span class="line"><span class="comment">;结果：没有返回值</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital:</span>    <span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]                         </span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span>                            </span><br><span class="line">            <span class="keyword">jcxz</span> ok                             <span class="comment">;如果 (cx)=0，结束；如果不是 0，处理</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span>         <span class="comment">;将 ds:si 所指单元中的字母转化为大写</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span>                              <span class="comment">;ds:di 指向下一个单元</span></span><br><span class="line">            <span class="keyword">jmp</span> short capital</span><br><span class="line"></span><br><span class="line"><span class="symbol">     ok:</span>    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>设计程序，将 data 段中的字符串全部转化为大写</p>
<p>利用循环，重复调用子程序 capital，完成对 4 个字符串的处理</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'word'</span>,<span class="number">0</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'unix'</span>,<span class="number">0</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'wind'</span>,<span class="number">0</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'good'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  start:</span>    <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span>                      <span class="comment">;循环要使用 cx  </span></span><br><span class="line"><span class="symbol">      s:</span>    <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">call</span> capital</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">5</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital:</span>    <span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]                   <span class="comment">;判断语句要使用 cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">jmp</span> short capital</span><br><span class="line"></span><br><span class="line"><span class="symbol">     ok:</span>    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>不幸的是，这个程序在 cx 的使用上存在冲突</p>
<p>解决方法：<br>
在子程序的开始将子程序中所有用到的寄存器中的内容都用栈保存起来，在子程序返回前再恢复</p>
<p>将子程序 capital 进行改进：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">capital:</span>    <span class="keyword">push</span> <span class="built_in">cx</span>                       <span class="comment">;将 cx 入栈保存</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line"><span class="symbol"> change:</span>    <span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">jmp</span> short capital</span><br><span class="line"></span><br><span class="line"><span class="symbol">     ok:</span>    <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span>                        <span class="comment">;cx 弹出</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>注意寄存器出栈和入栈的顺序</p>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<p>编写三个子程序，通过它们来认识几个常见的问题和掌握解决这些问题的方法。</p>
<h4 id="1-显示字符串"><a class="header-anchor" href="#1-显示字符串">¶</a>1. 显示字符串</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_1_1.PNG"/></div>
<h5 id="子程序描述"><a class="header-anchor" href="#子程序描述">¶</a>子程序描述</h5>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_1_2.PNG"/></div>
<h5 id="子程序编写"><a class="header-anchor" href="#子程序编写">¶</a>子程序编写</h5>
<p>1）分析屏幕上的行列位置与显存地址的对应关系<br>
2）注意保存子程序中用到的相关寄存器<br>
3）层层抽象的设计思想</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;参数：(dh)=行号，(dl)=列号，(cl)=颜色，ds:si 指向字符串的首地址</span></span><br><span class="line"><span class="symbol">show_str:</span>   <span class="keyword">push</span> <span class="built_in">dx</span>                       <span class="comment">;保存子程序中要使用的寄存器</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">dl</span>                     <span class="comment">;取列号（0~79）</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span>                     <span class="comment">;算列偏移</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">dh</span>                     <span class="comment">;取行号（0~24）</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="number">ah</span>                        </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">ax</span>                     <span class="comment">;算行偏移</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span>                 </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span>                     <span class="comment">;es 中存储显示缓冲区段地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">cl</span>                     <span class="comment">;取属性字节</span></span><br><span class="line"><span class="symbol">       s:</span>   <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]                <span class="comment">;取字符 ASCII 码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">jcxz</span> ok                       <span class="comment">;判断是否为结束符 0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>+<span class="built_in">bx</span>],<span class="built_in">ax</span>             <span class="comment">;送入显示缓冲区相应位置</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="symbol">      ok:</span>   <span class="keyword">pop</span> <span class="built_in">si</span>                        <span class="comment">;恢复寄存器的值</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">ret</span>                           <span class="comment">;子程序结束，返回调用者</span></span><br></pre></td></tr></table></figure>
<h5 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h5>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'welcome to masm!'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">   start:</span>   <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">8</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">3</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> show_str</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show_str:</span>   <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">dl</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">dh</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">cl</span></span><br><span class="line"><span class="symbol">       s:</span>   <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">jcxz</span> ok</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>+<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="symbol">      ok:</span>   <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_1_3_fix.PNG"/></div>
<h4 id="2-解决除法溢出的问题"><a class="header-anchor" href="#2-解决除法溢出的问题">¶</a>2. 解决除法溢出的问题</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_2_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_2_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_2_3.PNG"/></div>
<h5 id="子程序描述-v2"><a class="header-anchor" href="#子程序描述-v2">¶</a>子程序描述</h5>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_2_4.PNG"/></div>
<h5 id="子程序编写-v2"><a class="header-anchor" href="#子程序编写-v2">¶</a>子程序编写</h5>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_2_5.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;参数：(ax)=dword 型数据的低 16 位</span></span><br><span class="line"><span class="comment">;     (dx)=dword 型数据的高 16 位</span></span><br><span class="line"><span class="comment">;     (cx)=除数</span></span><br><span class="line"><span class="comment">;返回：(dx)=结果的高 16 位，(ax)=结果的低 16 位</span></span><br><span class="line"><span class="comment">;     (cx)=余数</span></span><br><span class="line"><span class="symbol">divdw:</span>      <span class="keyword">push</span> <span class="built_in">ax</span>           <span class="comment">;高 16 位计算过程</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>         <span class="comment">;将被除数的高 16 位补零成 32 位放入 dx、ax 中</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>            <span class="comment">;H/N, dx = rem(H/N), ax = int(H/N)</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>         <span class="comment">;将(最终结果的)商的前 16 位保存</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span>            <span class="comment">;低 16 位计算过程</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>            <span class="comment">;[rem(H/N)*65536+L]/N</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>         <span class="comment">;将余数放入 cx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<h5 id="示例-v2"><a class="header-anchor" href="#示例-v2">¶</a>示例</h5>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4240h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">000fh</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0ah</span></span><br><span class="line">            <span class="keyword">call</span> divdw</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">divdw:</span>      <span class="keyword">push</span> <span class="built_in">ax</span>           </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>         </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>         </span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span>            </span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>           </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>         </span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_2_6.PNG"/></div>
<h4 id="3-数值显示"><a class="header-anchor" href="#3-数值显示">¶</a>3. 数值显示</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_3_1.PNG"/></div>
<h5 id="子程序描述-v3"><a class="header-anchor" href="#子程序描述-v3">¶</a>子程序描述</h5>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_3_2_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_3_3.PNG"/></div>
<h5 id="子程序编写-v3"><a class="header-anchor" href="#子程序编写-v3">¶</a>子程序编写</h5>
<p>用循环除 10 的方法，每次取余数得到数据从低位到高位的每一位数字，并检查商是否为 0，若为 0 则跳出循环，注意，数字加 30H 即为其 ASCII 码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;参数：(ax)=word 型数据</span></span><br><span class="line"><span class="symbol">      ds:</span><span class="built_in">si</span> 指向字符串的首地址</span><br><span class="line"><span class="symbol">dtoc:</span>       <span class="keyword">push</span> <span class="built_in">ax</span>                       <span class="comment">;保存子程序中要使用的寄存器</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">10</span>                     <span class="comment">;除数为 10</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">   s:</span>       <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span>                      <span class="comment">;向 dx 补零</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">bx</span>                        <span class="comment">;循环除 10</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ax</span>                     <span class="comment">;取商</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">dx</span>,<span class="number">30h</span>                    <span class="comment">;取余数，加 30H 成为 ASCII 码</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span>                       <span class="comment">;入栈保存</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">di</span>                        <span class="comment">;记录长度</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok                       <span class="comment">;商为 0，结束循环</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">cx</span>                        <span class="comment">;这里可以直接用 jmp short s</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line">      </span><br><span class="line"><span class="symbol">  ok:</span>       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">di</span>                     <span class="comment">;长度为之后的循环次数</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">  s1:</span>       <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>]                   <span class="comment">;弹出，放入内存</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">0</span>        <span class="comment">;放置结束符 0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span>                        <span class="comment">;恢复寄存器的值</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<h5 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a>示例</h5>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">10</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">12666</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> dtoc</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">8</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">3</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">call</span> show_str</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">dtoc:</span>       <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">10</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol"> rem:</span>       <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">dx</span>,<span class="number">30h</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok1</span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">loop</span> rem</span><br><span class="line">      </span><br><span class="line"><span class="symbol"> ok1:</span>       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">di</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">  s1:</span>       <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show_str:</span>   <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">dl</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">dh</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">cl</span></span><br><span class="line"><span class="symbol">       s:</span>   <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">jcxz</span> ok</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>+<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="symbol">      ok:</span>   <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_3_4_fix.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_3_5.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C10/10_3_6.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 12</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-12-编写-0-号中断的处理程序"><a class="header-anchor" href="#实验-12-编写-0-号中断的处理程序">¶</a>实验 12 编写 0 号中断的处理程序</h2>
<h3 id="内中断"><a class="header-anchor" href="#内中断">¶</a>内中断</h3>
<p>搞清楚几个概念<br>
中断 - 中断源 - 中断类型码 - 中断向量表 - 中断过程 - 中断处理程序</p>
<p>对于 8086PC 机，中断向量表指定放在内存地址 0 处，从内存 <code>0000:0000</code> 到 <code>0000:03FF</code> 的 1024 个单元中存放着中断向量表</p>
<p>8086CPU 在收到中断信息后，引发中断过程<br>
1）（从中断信息中）取得中断类型码 N<br>
2）中断过程中需要改变标志寄存器的值，于是先将标志寄存器的值入栈（pushf）<br>
3）设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为 0（TF=0, IF=0）<br>
4）CS 的内容入栈（push CS）<br>
5）IP 的内容入栈（push IP）<br>
6）从内存地址为 N*4 和 N*4+2 的两个字单元中读取中断处理程序的入口地址设置 IP 和 CS（IP=N*4, CS=N*4+2）</p>
<p>中断处理程序的编写方法<br>
1）保存用到的寄存器<br>
2）处理中断<br>
3）恢复用到的寄存器<br>
4）用 iret 指令返回</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">iret</span>                    <span class="comment">;pop IP</span></span><br><span class="line">                        <span class="comment">;pop CS</span></span><br><span class="line">                        <span class="comment">;popf</span></span><br></pre></td></tr></table></figure>
<h3 id="检测点-12-1"><a class="header-anchor" href="#检测点-12-1">¶</a>检测点 12.1</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C12/12_12.1.PNG"/></div>
<p>（1）三号中断源对应的中断处理程序的入口地址为：<code>0070:018B</code><br>
（2）存储 N 号中断源对应的中断处理程序入口的偏移地址的内存单元的地址为：<code>4N</code>（一个表项占两个字，四个字节）<br>
存储 N 号中断源对应的中断处理程序入口的段地址的内存单元的地址为：<code>4N+2</code></p>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C12/ex12_1.PNG"/></div><br>
<p>要做以下几件事情</p>
<p>（1）编写可以显示 “divide error!” 的中断处理程序：do0；<br>
（2）将 do0 送入内存 0000:0200 处；<br>
（3）将 do0 的入口地址 0000:0200 存储在中断向量表 0 号表项中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">   start:</span>   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset do0                   <span class="comment">;设置 ds:si 指向源地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span>                           </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span>                        <span class="comment">;设置 es:di 指向目的地址</span></span><br><span class="line">            <span class="comment">;找一块别的程序不会用到的内存区，将 do0 传送到其中</span></span><br><span class="line">            <span class="comment">;从 0000:0200 至 0000:02FF 的 256 个字节的空间所对应的中断向量表项都是空的</span></span><br><span class="line">            <span class="comment">;操作系统和其他应用程序都不占用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset do0end-offset do0     <span class="comment">;设置 cx 为传输长度</span></span><br><span class="line">                                                <span class="comment">;（利用编译器来计算 do0 的长度）</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">cld</span>                                 <span class="comment">;设置传输方向为正</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span>                           <span class="comment">;串传送操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span>           <span class="comment">;设置中断向量表，给出中断处理程序的入口地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">     do0:</span>   <span class="keyword">jmp</span> short do0start                  <span class="comment">;这条指令占两个字节</span></span><br><span class="line">            <span class="built_in">db</span> <span class="string">"divide error!"</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">do0start:</span>   <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">202h</span>                         <span class="comment">;设置 ds:si 指向字符串</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span>                 </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span>+<span class="number">33</span>*<span class="number">2</span>                  <span class="comment">;设置 es:di 指向显存空间的中间位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">13</span>                           <span class="comment">;设置 cx 为字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">       s:</span>   <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span>                      <span class="comment">;将字符串送入显存空间，默认黑底白字</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  do0end:</span>   <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>测试程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4240h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">000fh</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">0ah</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>            <span class="comment">;1000000/10</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C12/ex12_2.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 13</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-13-编写、应用中断例程"><a class="header-anchor" href="#实验-13-编写、应用中断例程">¶</a>实验 13 编写、应用中断例程</h2>
<h3 id="一些例程与检测点"><a class="header-anchor" href="#一些例程与检测点">¶</a>一些例程与检测点</h3>
<h4 id="使用-int-指令调用中断处理程序"><a class="header-anchor" href="#使用-int-指令调用中断处理程序">¶</a>使用 int 指令调用中断处理程序</h4>
<p>可以在程序中使用 int 指令调用任何一个中断的中断处理程序</p>
<p>在下面的程序中，CPU 执行 <code>int 0</code> 指令时，将引发中断过程，执行 0 号中断处理程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">12</span>*<span class="number">160</span>+<span class="number">40</span>*<span class="number">2</span>],<span class="string">'!'</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_1_1.PNG"/></div>
<h4 id="编写、安装中断-7ch-的中断例程（1）"><a class="header-anchor" href="#编写、安装中断-7ch-的中断例程（1）">¶</a>编写、安装中断 7ch 的中断例程（1）</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_2_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">3456</span>             <span class="comment">;(ax)=3456</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span>                 <span class="comment">;调用中断 7ch 的中断例程，计算 ax 中的数据的平方</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">adc</span> <span class="built_in">dx</span>,<span class="built_in">dx</span>               <span class="comment">;dx:ax 存放结果，将结果乘以 2</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>需要做的工作：</p>
<ol>
<li>编写实现求平方功能的程序；</li>
<li>安装程序，将其安装在 0:200 处；</li>
<li>设置中断向量表，将程序的入口地址保存在 7ch 表项中，使其成为中断 7ch 的中断例程。</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> start:</span>     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset sqr                   <span class="comment">;设置 ds:si 指向源地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span>                        <span class="comment">;设置 es:di 指向目的地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset sqrend-offset sqr     <span class="comment">;设置 cx 为传输长度</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">cld</span>                                 <span class="comment">;设置传输方向为正</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span>                           <span class="comment">;串传送操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span>         <span class="comment">;设置中断向量表</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   sqr:</span>     <span class="keyword">mul</span> <span class="built_in">ax</span>                              <span class="comment">;7ch 中断处理程序</span></span><br><span class="line">            <span class="keyword">iret</span>                                <span class="comment">;iret : pop IP pop CS popf</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sqrend:</span>     <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure>
<p>在执行完中断例程后，应该用 iret 指令恢复 int 7ch 执行前的标志寄存器和 CS、IP 的值</p>
<p>int 指令和 iret 指令的配合使用与 call 指令和 ret 指令的配合使用具有相似的思路</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_2_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_2_3.PNG"/></div>
<h4 id="编写、安装中断-7ch-的中断例程（2）"><a class="header-anchor" href="#编写、安装中断-7ch-的中断例程（2）">¶</a>编写、安装中断 7ch 的中断例程（2）</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_3_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'conversation'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>安装程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="comment">;串传送操作</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset capital</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset capitalend-offset capital</span><br><span class="line"></span><br><span class="line">            <span class="keyword">cld</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;设置中断向量表</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;程序返回</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;中断处理函数</span></span><br><span class="line"><span class="symbol">capital:</span>    <span class="comment">;保存用到的寄存器</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;处理中断</span></span><br><span class="line"><span class="symbol">change:</span>     <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok</span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">jmp</span> short change</span><br><span class="line">            </span><br><span class="line"><span class="symbol">ok:</span>         <span class="comment">;恢复用到的寄存器</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="comment">;用 iret 指令返回</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capitalend:</span> <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_3_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_3_3.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_3_4.PNG"/></div><br>
<p>安装中断例程的程序的基本框架</p>
<p>1）主程序<br>
串传送操作：<br>
      设置 ds:si 指向源地址<br>
      设置 es:di 指向目的地址<br>
      设置 cx 为传输长度<br>
      设置传输方向<br>
      进行串传送<br>
设置中断向量表：<br>
      将中断例程的入口地址写入相应表项<br>
程序返回；</p>
<p>2）子程序<br>
中断处理函数：<br>
      保存用到的寄存器<br>
      处理中断<br>
      恢复用到的寄存器<br>
      用 iret 指令返回</p>
<h4 id="用-7ch-中断例程完成-loop-指令的功能"><a class="header-anchor" href="#用-7ch-中断例程完成-loop-指令的功能">¶</a>用 7ch 中断例程完成 loop 指令的功能</h4>
<p>loop s 的执行需要两个信息，循环次数和到 s 的位移，7ch 中断例程也需要以这两个变量为参数，用 cx 存放循环次数，用 bx 存放位移。</p>
<p>应用举例：在屏幕中间显示 80 个 “!”。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">160</span>*<span class="number">12</span>                 <span class="comment">;屏幕缓冲区中央</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset se     <span class="comment">;设置从标号 se 到标号 s 的转移位移</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span>                     <span class="comment">;设置循环次数</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="string">'!'</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span>                       <span class="comment">;如果 (cx)≠0，转移到标号 s 处</span></span><br><span class="line"><span class="symbol">   se:</span>      <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>为了模拟 loop 指令，7ch 中断例程应具备下面的功能：</p>
<ol>
<li>dec cx;</li>
<li>如果 (cx)≠0，转到标号 s 处执行，否则向下执行。</li>
</ol>
<p>通过 se 的偏移地址加上 bx 中存放的转移位移得到 s 的偏移地址<br>
通过改变栈中被压栈的 IP 的内容，再使用 iret 指令，从而真正改变 IP，使 CS:IP 转移到标号 s 处</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset lp</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset lpend-offset lp</span><br><span class="line">            <span class="keyword">cld</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   lp:</span>      <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">            <span class="keyword">dec</span> <span class="built_in">cx</span>                        <span class="comment">;cx 递减</span></span><br><span class="line">            <span class="keyword">jcxz</span> lpret                    <span class="comment">;(cx)=0 时跳出循环</span></span><br><span class="line">            <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span>                 <span class="comment">;通过修改压入栈中的 IP 数据，实现弹出后转移到标号 s 处</span></span><br><span class="line"><span class="symbol">lpret:</span>      <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"><span class="symbol">lpend:</span>      <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_4_1.PNG"/></div>
<h4 id="检测点-13-1"><a class="header-anchor" href="#检测点-13-1">¶</a>检测点 13.1</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_5_1.PNG"/></div>
<p>（1）<strong>-32768~32767</strong></p>
<p>实际上 loop 指令为短转移，对 IP 的修改范围为 -128 ~ 127</p>
<p>（2）应用程序：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'conversation'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">12</span>*<span class="number">160</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">            <span class="keyword">je</span> ok                               <span class="comment">;如果是 0 跳出循环</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s-offset ok           <span class="comment">;设置从标号 ok 到标号 s 的转移位移</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span>                             <span class="comment">;转移到标号 s 处</span></span><br><span class="line"><span class="symbol">   ok:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>安装程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset print</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset printend-offset print</span><br><span class="line">            <span class="keyword">cld</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">print:</span>      <span class="keyword">push</span> <span class="built_in">bp</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="built_in">sp</span></span><br><span class="line">            <span class="keyword">add</span> [<span class="built_in">bp</span>+<span class="number">2</span>],<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bp</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"><span class="symbol">printend:</span>   <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_5_2.PNG"/></div>
<h4 id="检测点-13-2"><a class="header-anchor" href="#检测点-13-2">¶</a>检测点 13.2</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_6_1.PNG"/></div>
<p>（1）<strong>错误，内存区域只读。</strong></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C1/8086PC%E6%9C%BA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.PNG"/></div>
<p>（2）<strong>int 19h 在 DOS 启用之前调用，由 BIOS 提供。</strong></p>
<h4 id="编程：在屏幕的-5-行-12-列显示-3-个红底高亮闪烁绿色的-“a”"><a class="header-anchor" href="#编程：在屏幕的-5-行-12-列显示-3-个红底高亮闪烁绿色的-“a”">¶</a>编程：在屏幕的 5 行 12 列显示 3 个红底高亮闪烁绿色的 “a”</h4>
<p>BIOS 中断例程应用</p>
<p>BIOS 和 DOS 提供的中断例程，用 ah 来传递内部子程序的编号。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>                <span class="comment">;置光标</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span>                <span class="comment">;第 0 页</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span>                <span class="comment">;dh 中放行号</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span>               <span class="comment">;dl 中放列号</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span>                <span class="comment">;在光标位置显示字符</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="string">'a'</span>              <span class="comment">;字符</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">11001010b</span>        <span class="comment">;颜色属性</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span>                <span class="comment">;第 0 页</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span>                <span class="comment">;字符重复个数</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_7_1.PNG"/></div>
<h4 id="编程：在屏幕的-5-行-12-列显示字符串-“Welcome-to-masm-”"><a class="header-anchor" href="#编程：在屏幕的-5-行-12-列显示字符串-“Welcome-to-masm-”">¶</a>编程：在屏幕的 5 行 12 列显示字符串 “Welcome to masm!”</h4>
<p>DOS 中断例程应用</p>
<p>DOS 为程序员提供了许多可以调用的子程序，都包含在 int 21h 中断例程中<br>
int 21h 中断例程的 4ch 号功能，即程序返回功能</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'Welcome to masm'</span>,<span class="string">'$'</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>                <span class="comment">;置光标</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span>                <span class="comment">;第 0 页</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">5</span>                <span class="comment">;dh 中放行号</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">12</span>               <span class="comment">;dl 中放列号</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span>                <span class="comment">;ds:dx 指向字符串的首地址 data:0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/13_8_1.PNG"/></div>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<p>实验任务（1）（2）在之前的程序中都有所体现，这里只将没有与之前完全重复的实验任务（1）再做一遍</p>
<h4 id="实验任务（1）"><a class="header-anchor" href="#实验任务（1）">¶</a>实验任务（1）</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_1_1.PNG"/></div><br>
<p>应用程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">"welcome to masm! "</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">10</span>                     <span class="comment">;行号</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">10</span>                     <span class="comment">;列号</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">2</span>                      <span class="comment">;颜色</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>                      <span class="comment">;字符串首地址</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>编写程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset print</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset printend-offset print</span><br><span class="line">            <span class="keyword">cld</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">print:</span>      <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">dl</span>                     <span class="comment">;处理列</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span>            </span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span>         </span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">dh</span>                     <span class="comment">;处理行</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mul</span> <span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">            <span class="keyword">je</span> ok</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>+<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">jmp</span> short s</span><br><span class="line"><span class="symbol">   ok:</span>      <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"><span class="symbol">printend:</span>   <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure> 
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_1_2_fix.PNG"/></div><br>
<h4 id="实验任务（2）"><a class="header-anchor" href="#实验任务（2）">¶</a>实验任务（2）</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_2_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_2_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_2_3.PNG"/></div><br>
<p>见上文 <a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/#%E7%94%A8-7ch-%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%AE%8C%E6%88%90-loop-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener"><strong>用 7ch 中断例程完成 loop 指令的功能</strong></a></p>
<h4 id="实验任务（3）"><a class="header-anchor" href="#实验任务（3）">¶</a>实验任务（3）</h4>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_3_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_3_2.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">s1:</span>   <span class="built_in">db</span> <span class="string">'Good,better,best,'</span>,<span class="string">'$'</span></span><br><span class="line"><span class="symbol">s2:</span>   <span class="built_in">db</span> <span class="string">'Never let it rest,'</span>,<span class="string">'$'</span></span><br><span class="line"><span class="symbol">s3:</span>   <span class="built_in">db</span> <span class="string">'Till good is better,'</span>,<span class="string">'$'</span></span><br><span class="line"><span class="symbol">s4:</span>   <span class="built_in">db</span> <span class="string">'And better,best.'</span>,<span class="string">'$'</span></span><br><span class="line">s :   <span class="built_in">dw</span> offset s1,offset s2,offset s3,offset s4</span><br><span class="line"><span class="symbol">row:</span>  <span class="built_in">db</span> <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span></span><br><span class="line"><span class="comment">;在数据前放置标号，方便寻址</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,offset s</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset row</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">ok:</span>         <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span>                      <span class="comment">;第 0 页</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]                <span class="comment">;dh 中放行号</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span>                      <span class="comment">;dl 中放列号</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>                      <span class="comment">;置光标</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">9</span>                      <span class="comment">;第 21h 号中断例程的 9 号子程序</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span>                       <span class="comment">;显示字符串</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> ok</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C13/ex13_3_3.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 15</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-15-安装新的-int9-中断例程"><a class="header-anchor" href="#实验-15-安装新的-int9-中断例程">¶</a>实验 15 安装新的 int9 中断例程</h2>
<h3 id="外中断"><a class="header-anchor" href="#外中断">¶</a>外中断</h3>
<p>外中断源有两类：</p>
<p>1）可屏蔽中断<br>
CPU 可以不响应，是否响应取决于标志寄存器 IF 位的设置，当 CPU 检测到可屏蔽中断信息时，若 IF=1，则 CPU 在执行完当前指令后响应中断，引发中断过程；若 IF=0，则不响应可屏蔽中断</p>
<p>在中断过程中将 IF 置 0 可以禁止其他的可屏蔽中断，若需要处理则可将 IF 置 1</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sti</span>               <span class="comment">;设置 IF=1</span></span><br><span class="line"><span class="keyword">cli</span>               <span class="comment">;设置 IF=0</span></span><br></pre></td></tr></table></figure>
<p>几乎所有由外设引发的外中断都是可屏蔽中断，也是我们主要讨论的对象</p>
<p>可屏蔽中断基本上与内中断的中断过程相同，只是其中断类型码是通过数据总线送入 CPU 的</p>
<p>2）不可屏蔽中断<br>
CPU 必须响应的外中断，检测到不可屏蔽中断信息时，在执行完当前指令后立即响应，引发中断过程，对于 8086CPU，其中断类型码固定为 2</p>
<p>通过对键盘输入的处理来理解 PC 机是如何处理外设输入的</p>
<p>理解以下过程<br>
键盘产生扫描码（通码与断码：断码 = 通码 + 80h）- 扫描码送入处理键盘输入的端口 60h - 引发九号中断 - 执行int 9 中断例程</p>
<h3 id="编写-int-9-中断例程"><a class="header-anchor" href="#编写-int-9-中断例程">¶</a>编写 int 9 中断例程</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_1_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line"><span class="comment">;用 ds:0 ds:2 保存原 int 9 中断例程的入口地址</span></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack                        <span class="comment">;设置栈空间</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">128</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,data                   </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                            <span class="comment">;设置 es 为中断向量表的段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]                          <span class="comment">;将原来的 int 9 中断例程的入口地址保存</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>],offset int9</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="built_in">cs</span>                   <span class="comment">;在中断向量表中设置新的 int 9 中断例程的入口地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span>                       <span class="comment">;显示缓冲区的段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="string">'a'</span></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>],<span class="number">ah</span>             <span class="comment">;显示 'a'~'z'</span></span><br><span class="line">            <span class="keyword">call</span> delay                          <span class="comment">;每显示一个字母后，延时一段时间</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="number">ah</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="string">'z'</span></span><br><span class="line">            <span class="keyword">jna</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]                      <span class="comment">;在程序返回前恢复原来的地址（原 int 9 中断例程的入口地址）</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span>                        <span class="comment">;程序返回</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">delay:</span>      <span class="keyword">push</span> <span class="built_in">ax</span>                             <span class="comment">;延时函数</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">100h</span>                         <span class="comment">;用两个 16 位寄存器来存放 32 位的循环次数</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                            <span class="comment">;循环 100 0000 h 次（dx:ax）</span></span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">sbb</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jne</span> s1</span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jne</span> s1</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;------以下为新的 int 9 中断例程--------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;int 9 中断例程</span></span><br><span class="line"><span class="comment">;1) 从 60h 端口读出键盘的输入</span></span><br><span class="line"><span class="comment">;2) 调用 BIOS 的 int 9 中断例程，处理其他硬件细节</span></span><br><span class="line"><span class="comment">;3) 判断是否为 Esc 的扫描码，如果是，改变显示的颜色后返回；如果不是则直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9:</span>       <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">60h</span>                           <span class="comment">;键盘端口地址</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;模拟 int 指令，调用原 int 9 中断例程                    </span></span><br><span class="line">            <span class="keyword">pushf</span>                               <span class="comment">;标志寄存器入栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pushf</span>                               <span class="comment">;置 IF 和 TF 为 0，分别为标志寄存器的第 9 位与第 8 位</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span>                              <span class="comment">;通过 pushf 与 popf 的配合修改标志寄存器</span></span><br><span class="line">            <span class="keyword">and</span> <span class="number">bh</span>,<span class="number">11111100b</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">popf</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]               <span class="comment">;对 int 指令进行模拟，调用原来的 int 9 中断例程</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span>                            <span class="comment">;ESC 的扫描码</span></span><br><span class="line">            <span class="keyword">jne</span> int9ret</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>+<span class="number">1</span>]     <span class="comment">;将属性值加 1，改变颜色</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9ret:</span>    <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_1_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_1_3.PNG"/></div>
<h3 id="检测点-15-1"><a class="header-anchor" href="#检测点-15-1">¶</a>检测点 15.1</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_2_1.PNG"/></div>
<p>（1）</p>
<p><strong>pushf<br>
call dword ptr ds:[0]</strong></p>
<p>无需再设置标志寄存器的 IF 与 TF 位</p>
<p>（2）</p>
<p>找到修改中断向量表的程序段</p>
<p>先用 cli 指令将 IF 置 0，禁止其他的可屏蔽中断，在程序段执行后再用 sti 将 IF 置 1</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;在中断向量表中设置新的 int 9 中断例程的入口地址</span></span><br><span class="line"><span class="keyword">cli</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>],offset int9</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="built_in">cs</span> </span><br><span class="line"><span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">;在程序返回前恢复原来的地址</span></span><br><span class="line"><span class="comment">;即原 int 9 中断例程的入口地址</span></span><br><span class="line"><span class="keyword">cli</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]                   </span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line"><span class="keyword">sti</span></span><br></pre></td></tr></table></figure>
<h3 id="安装新的-int-9-中断例程"><a class="header-anchor" href="#安装新的-int-9-中断例程">¶</a>安装新的 int 9 中断例程</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_3_1.PNG"/></div>
<p>注意与前面程序的区别，安装程序返回后地址将丢失，新 int 9 中断例程与原 int 9 中断例程的入口地址皆不可保存在安装程序中，于是我们将原 int 9 中断例程的入口地址放在 <code>0000:0200</code> 处，将新 int 9 中断例程放在 <code>0000:0204</code> 处</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">128</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset int9                  <span class="comment">;设置 ds:si 指向源地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">204h</span>                         <span class="comment">;设置 es:di 指向目的地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset int9end-offset int9   <span class="comment">;设置 cx 为传输长度</span></span><br><span class="line">            <span class="keyword">cld</span>                                 <span class="comment">;设置传输方向为正</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]                       <span class="comment">;保存原有 int 9 的中断处理程序的入口地址</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">200h</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">202h</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">cli</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>],<span class="number">204h</span>          <span class="comment">;设置中断向量表</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line">            <span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;此程序无需将中断向量表恢复成原 int 9 中断例程的入口地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9:</span>       <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">60h</span>                           <span class="comment">;键盘端口地址</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">pushf</span>                               <span class="comment">;调用原 int9 中断处理程序</span></span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">cs</span>:[<span class="number">200h</span>]            <span class="comment">;当此中断例程执行时 (CS)=0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">3bh</span>                          <span class="comment">;F1 的扫描码为 3bh</span></span><br><span class="line">            <span class="keyword">jne</span> int9ret</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span>                         <span class="comment">;改变 4000 个字节中所有奇地址单元中的内容</span></span><br><span class="line"><span class="symbol">s:</span>          <span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>]                <span class="comment">;改变颜色</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="symbol">int9ret:</span>    <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9end:</span>    <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_3_2.PNG"/></div>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/ex15_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">128</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;新 int 9 中断例程传送到内存</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset int9                  </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">204h</span>                     </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset int9end-offset int9   </span><br><span class="line">            <span class="keyword">cld</span>                                 </span><br><span class="line"></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">;保存原 int 9 中断例程的入口地址</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]                       </span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">200h</span>]</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">202h</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">;设置中断向量表表项为新 int 9 中断例程存放的内存地址</span></span><br><span class="line">            <span class="keyword">cli</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>],<span class="number">204h</span>          </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line">            <span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9:</span>       <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">60h</span>                           </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">pushf</span>                               </span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">cs</span>:[<span class="number">200h</span>]            </span><br><span class="line"></span><br><span class="line">            <span class="comment">;只需检测松开的情况</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">9eh</span>                          <span class="comment">;松开 A 键的扫描码（断码）    </span></span><br><span class="line">            <span class="keyword">jne</span> int9ret</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span>                         </span><br><span class="line"><span class="symbol">s:</span>          <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="string">'A'</span>            <span class="comment">;满屏的 A 字符  </span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="symbol">int9ret:</span>    <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9end:</span>    <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/ex15_2.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 14</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-14-访问-CMOS-RAM"><a class="header-anchor" href="#实验-14-访问-CMOS-RAM">¶</a>实验 14 访问 CMOS RAM</h2>
<h3 id="端口的读写"><a class="header-anchor" href="#端口的读写">¶</a>端口的读写</h3>
<p>在访问端口时，CPU 通过端口地址来定位端口，在 PC 系统中，CPU 最多可以定位 64 KB 个不同的端口。则端口地址的范围为 0 ~ 65535</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>                      <span class="comment">;从端口读取数据</span></span><br><span class="line"><span class="keyword">out</span>                     <span class="comment">;往端口写入数据</span></span><br></pre></td></tr></table></figure>
<p>在 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口的数据。访问 8 位端口时用 al，访问 16 位端口时用 ax</p>
<h3 id="检测点-14-1"><a class="header-anchor" href="#检测点-14-1">¶</a>检测点 14.1</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/14_1_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">70h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">71h</span></span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">70h</span>,<span class="built_in">al</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">71h</span>,<span class="built_in">al</span></span><br></pre></td></tr></table></figure>
<h3 id="检测点-14-2"><a class="header-anchor" href="#检测点-14-2">¶</a>检测点 14.2</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/14_2_1.PNG"/></div>
<p>shl 和 shr 是逻辑移位指令，其中<br>
shl 是逻辑左移指令，它的功能为：<br>
1）将一个寄存器或内存单元中的数据向左移位<br>
2）将最后移出的一位写入 CF 中<br>
3）最低位用 0 补充<br>
shl 是逻辑右移指令，它的功能为：<br>
1）将一个寄存器或内存单元中的数据向右移位<br>
2）将最后移出的一位写入 CF 中<br>
3）最高位用 0 补充<br>
若移动位数大于 1，则必须将移动位数放在 cl 中</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;计算 (ax)*10</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">      <span class="keyword">shl</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ax</span>                           <span class="comment">;(ax)*2</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">shl</span> <span class="built_in">ax</span>,<span class="built_in">cl</span>                           <span class="comment">;(ax)*8</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">dx</span>,<span class="built_in">ax</span>                           <span class="comment">;(ax)*10</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/14_2_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/14_2_3.PNG"/></div>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/ex14_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/ex14_3.PNG"/></div>
<p>BCD 码是以 4 位二进制数表示十进制数码的编码方法<br>
十进制数码与其对应的 BCD 码：<br>
0:0000, 1:0001, 2:0010, 3:0011, 4:0100,<br>
5:0101, 6:0110, 7:0111, 8:1000, 9:1001</p>
<p>一个字节可表示两个 BCD 码，在 CMOS RAM 存储时间信息的单元中，存储了用两个 BCD 码表示的两位十进制数，高 4 位的 BCD 码表示十位，低 4 位的 BCD 码表示个位</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>                      <span class="comment">;端口地址</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'/'</span>,<span class="string">'/'</span>,<span class="string">' '</span>,<span class="string">':'</span>,<span class="string">':'</span>,<span class="string">' '</span>          <span class="comment">;分隔符</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">6</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">160</span>*<span class="number">12</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">40</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    s:</span>      <span class="keyword">push</span> <span class="built_in">cx</span>                       </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]                <span class="comment">;开始读 BCD 码</span></span><br><span class="line">            <span class="keyword">out</span> <span class="number">70h</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">71h</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span>                     <span class="comment">;将读出的一个字节分为两个表示 BCD 码值的数据</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">4</span></span><br><span class="line">            <span class="keyword">shr</span> <span class="number">ah</span>,<span class="built_in">cl</span>                     <span class="comment">;逻辑右移取高 4 位 BCD 码</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span>              <span class="comment">;做与运算取低 4 位 BCD 码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">add</span> <span class="number">ah</span>,<span class="number">30h</span>                    <span class="comment">;BCD 码值 + 30h = 十进制数对应的 ASCII 码</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">30h</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">2</span>                      <span class="comment">;黑底绿字</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>+<span class="built_in">di</span>],<span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>].<span class="number">2h</span>[<span class="built_in">di</span>],<span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>].<span class="number">6h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>].<span class="number">4h</span>[<span class="built_in">di</span>],<span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">6</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C14/ex14_1.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 4</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-4-bx-和-loop-的使用"><a class="header-anchor" href="#实验-4-bx-和-loop-的使用">¶</a>实验 4 [bx] 和 loop 的使用</h2>
<p>考虑一个问题，将内存 <code>ffff:0 ~ ffff:b</code> 单元中的数据复制到 <code>0:200 ~ 0:20b</code> 单元中</p>
<p>注意到，<code>0:200 ~ 0:20b</code> 单元等同于 <code>0020:0 ~ 0020:b</code> 单元，它们描述的是同一段内存空间，这样的等同可以使目标单元的偏移地址和原始单元的偏移地址从同一数值 0 开始</p>
<p>思路是，将偏移地址作为循环变量，在每一次循环中将段地址为 <code>ffff</code> 的内存单元中的数据先送入寄存器，再转移到段地址为 <code>0020</code> 的内存单元中（这里需要寄存器作为中转）</p>
<p>注意，在汇编源程序中，数据不能以字母开头，<code>mov ax,0ffffh</code> 不能省去 <code>0ffffh</code> 前面的 <code>0</code></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>                <span class="comment">;(bx)=0, 偏移地址从 0 开始</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">12</span>               <span class="comment">;(cx)=12, 循环 12 次</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s:</span>    <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0ffffh</span>     </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               <span class="comment">;(ds)=0ffffh</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">dl</span>,[<span class="built_in">bx</span>]             <span class="comment">;(dl)=((ds)*16+(bx)), 将 ffff:bx 中的数据送入 dl</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0020h</span>      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               <span class="comment">;(ds)=0020h</span></span><br><span class="line">      <span class="keyword">mov</span> [<span class="built_in">bx</span>],<span class="built_in">dl</span>             <span class="comment">;((ds)*16+(bx))=(dl), 将 dl 中的数据送入 0020:bx</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">bx</span>                  <span class="comment">;(bx)=(bx)+1</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可以看到，上面的程序在循环中要设置两次段寄存器 <code>ds</code>，但其实并不需要这样做，我们还有 <code>es</code>，16位的扩展段寄存器，可以用 <code>es</code> 存放目标空间的段地址，用 <code>ds</code> 存放原始空间的段地址</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0ffffH</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span>               <span class="comment">;(ds)=0ffffh</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0020H</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span>               <span class="comment">;(es)=0020h</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>                <span class="comment">;(bx)=0, 此时 ds:bx 指向 ffff:0, es:bx 指向 0020:0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">12</span>               <span class="comment">;(cx)=12, 循环 12 次</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s:</span>    <span class="keyword">mov</span> <span class="built_in">dl</span>,[<span class="built_in">bx</span>]             <span class="comment">;(dl)=((ds)*16+(bx)), 将 ffff 中的数据送入 dl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">dl</span>          <span class="comment">;((es)*16+(bx))=(dl), 将 dl 中的数据送入 0020:bx</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">bx</span>                  <span class="comment">;(bx)=(bx)+1</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00H</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>注意，<code>mov dl,[bx]</code> 是隐式地使用 <code>ds</code> 寄存器中的数据作为段地址，而 <code>mov es:[bx],dl</code> 是显式地用段前缀 <code>es:</code> 给出单元的段地址</p>
<h3 id="实验任务（1）（2）"><a class="header-anchor" href="#实验任务（1）（2）">¶</a>实验任务（1）（2）</h3>
<p>编程，向内存 <code>0:200 ~ 0:23F</code> 依次传送数据 <code>0 ~ 63(3FH)</code>，程序中只能使用 9 条指令，9 条指令中包括 <code>mov ax,4c00h</code> 和 <code>int 21h</code></p>
<p>思路很简单，只需将要传送的数据当作循环变量，在循环中把寄存器的值送入内存，然后自增即可</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/loop_1.PNG"/></div>
<div align=center>编辑程序</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/D命令1.PNG"/></div>
<div align=center>程序运行前内存状态</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/T命令.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/D命令2.PNG"/></div>
<div align=center>程序运行后内存状态</div><br>
<h3 id="实验任务（3）"><a class="header-anchor" href="#实验任务（3）">¶</a>实验任务（3）</h3>
<p>补全程序，其功能为，将 <code>mov ax,4c00h</code> 之前的指令复制到内存 <code>0:200</code> 处</p>
<p>指令在哪儿呢，我们好像不知道，但我们知道，在运行程序时，CPU 将 <code>CS:IP</code> 指向的内容当作指令执行，换一个说法，程序中 <code>code</code> 段（<code>code segment</code>）的段地址其实可以在 <code>cs</code> 中取到（这里未标明程序入口 <code>start:</code>，程序顺序地运行），我们可以猜测，程序第一条指令的地址应该就是 <code>cs:0</code></p>
<p>那么循环的次数如何得知呢，即，<code>mov ax,4c00h</code> 之前的指令的长度是多少，这个当然可以用 Debug 程序测试出来，也可以通过我们编写程序的经验推算出来</p>
<p>补全后的程序如下</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0020h</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">17h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s:</span>    <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>用 Debug 调试工具跟踪程序的运行，使用 R 命令找到 CS:IP 指向的地址，再使用 U 命令查看从该地址开始的机器码转换成的汇编指令，可以看到，<code>CS:IP</code> 指向 <code>code segment</code> 中的第一条指令 <code>mov ax,cs</code>，并且得知从该指令到 <code>mov ax,4c00h</code> 之前的指令占 23(<code>0x17h</code>) 个字节，即 <code>cx</code> 应设为 <code>17h</code></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/U命令1.PNG"/></div><br>
<p>程序运行后的结果，成功地将指令复制到了内存 <code>0:200</code> 处</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/U命令2.PNG"/></div><br>
<p>这里可以补充一点 8086 指令集编码的知识</p>
<p>参考：<br>
<a href="https://blog.csdn.net/qq_35426012/article/details/101698804" target="_blank" rel="noopener">8086指令的机器码编码格式</a><br>
<a href="https://wenku.baidu.com/view/77d6be5cff00bed5b9f31d56.html" target="_blank" rel="noopener">8086 汇编和机器码的对应表</a><br>
<a href="https://max.book118.com/html/2017/0622/117233100.shtm" target="_blank" rel="noopener">8086指令的机器码表示</a><br>
<a href="http://www.360doc.com/content/20/0421/13/59918970_907443778.shtml" target="_blank" rel="noopener">探索机器码(8086)</a></p>
<p>8086 指令编码的特点是为每种基本指令类型给出一个编码格式，对照格式填上不同数字表示不同的寻址方式与数据类型，便可得出每条指令的机器码（也就是说，每一条指令对应唯一的机器码，这唯一的机器码应该指明该指令的所有有效信息）</p>
<p>8086 指令采用变长指令，每条指令可由 1~6 个字节组成</p>
<p>以程序的第一条指令为例，这条指令很简单，是将段寄存器 <code>cs</code> 中的值送入数据寄存器 <code>ax</code> 中去</p>
<p><code>8CC8</code>      <code>mov ax,cs</code></p>
<p>对应机器码：<code>1000 1100 1100 1000</code></p>
<p>因为 MOVsr（sr 代表段寄存器 segment register） 对应的机器码为 <code>100011d0</code>，其中 <code>d</code> 这一位表示的是数据传送的方向，那么 <code>8C</code>(<code>d</code> 为 <code>0</code>) 即代表以一个段寄存器为源操作数，一个数据寄存器为目标操作数，传送一个字的数据</p>
<p>后一个字节 <code>C8</code> 中，前两位代表 <code>mod</code>（寻址方式），<code>11</code> 即说明该指令采用寄存器寻址，没有位移量，后六位分别指 <code>cs</code> 段寄存器（<code>001</code>）与 <code>ax</code> 数据寄存器（<code>000</code>）</p>
<p>这里有一个问题，即 <code>cx</code> 数据寄存器的机器码与 <code>cs</code> 段寄存器的机器码都是 <code>001</code>，难道不会产生歧义吗？答案当然是不会的，因为在解析前面的机器码时，就已经知道这后面几位代表的是数据寄存器还是段寄存器了</p>
<p>如果指令为 <code>mov ax,cx</code><br>
那么对应的机器码应为 <code>89C8：1000 1001 1100 1000</code></p>
<p>附 MOV 指令的 8086CPU 手册指令集图示，仅供参考</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C4/MOV%E6%8C%87%E4%BB%A4CPU%E6%89%8B%E5%86%8C.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 实验 16</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="实验-16-编写包含多个功能子程序的中断例程"><a class="header-anchor" href="#实验-16-编写包含多个功能子程序的中断例程">¶</a>实验 16 编写包含多个功能子程序的中断例程</h2>
<h3 id="一个示例程序-理解数据标号"><a class="header-anchor" href="#一个示例程序-理解数据标号">¶</a>一个示例程序 - 理解数据标号</h3>
<p>将 code 段中的 a 标号处的 8 个数据累加，结果存储到 b 标号处的字中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">      a:</span> <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">      b:</span> <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">si</span>,offset a</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,offset b</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，code、a、b、start、s 都是地址标号，仅仅表示了内存单元的地址，而数据标号（后面不带 : 的）还能够描述单元长度，在指令中可以代表一个段中的内存单元</p>
<p>使用数据标号后，将程序修改如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">      a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">      b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]            <span class="comment">;mov al,cs:0[si]</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">add</span> b,<span class="built_in">ax</span>                <span class="comment">;add cs:[8],ax</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>标号 a 描述了地址 code:0，和从这个地址开始，以后的内存单元都是字节单元，而标号 b 描述了地址 code:8，和从这个地址开始，以后的内存单元都是字单元</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_1_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_1_2.PNG"/></div><br>
<p>对于程序中的 “b dw 0”，下面一些指令等价：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,b</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>:[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> b,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">cs</span>:[<span class="number">8</span>],<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inc</span> b</span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">cs</span>:[<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>对于程序中的 “a db 1,2,3,4,5,6,7,8”，下面一些指令等价：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cs</span>:<span class="number">0</span>[<span class="built_in">si</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cs</span>:<span class="number">0</span>[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">3</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cs</span>:<span class="number">0</span>[<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="检测点-16-1"><a class="header-anchor" href="#检测点-16-1">¶</a>检测点 16.1</h3>
<p>将 code 段中 a 处的 8 个数据累加，结果存储到 b 处的双字中，补全程序。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">      a <span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">      b <span class="built_in">dd</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,a[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> b[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> b[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_2_1.PNG"/></div>
<p>如果考虑进位</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">      a <span class="built_in">dw</span> <span class="number">30000</span>,<span class="number">2768</span>,<span class="number">30000</span>,<span class="number">2768</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">      b <span class="built_in">dd</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,a[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> b[<span class="number">0</span>],<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">adc</span> <span class="built_in">word</span> <span class="built_in">ptr</span> b[<span class="number">2</span>],<span class="number">0</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_2_2.PNG"/></div>
<h3 id="在其他段中使用数据标号"><a class="header-anchor" href="#在其他段中使用数据标号">¶</a>在其他段中使用数据标号</h3>
<p>一般不在代码段中定义数据，而将数据定义到其他段中，在其他段中我们也可以用数据标号来描述存储数据的单元的地址和长度，而地址标号只能在代码段中使用</p>
<p>下面的程序将 data 段中的 a 标号处的 8 个数据累加，结果存储到 b 标号处的字中</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">      b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">    s:</span><span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">add</span> b,<span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_3_1.PNG"/></div><br>
<p>若想在代码段中直接使用数据标号访问数据，则需要用伪指令 assume 将标号所在的段和一个段寄存器联系起来，并且在程序中还要用指令对段寄存器进行设置</p>
<h3 id="检测点-16-2"><a class="header-anchor" href="#检测点-16-2">¶</a>检测点 16.2</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_3_3.PNG"/></div>
<p><strong>mov ax,data</strong><br>
<strong>mov es,ax</strong></p>
<p>对比此程序与上一个程序<br>
在用 assume 指令将段寄存器和某个段相联系后，在程序中还要使用指令对段寄存器进行设置</p>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_3_2.PNG"/></div>
<h3 id="讨论用查表的方法编写相关程序"><a class="header-anchor" href="#讨论用查表的方法编写相关程序">¶</a>讨论用查表的方法编写相关程序</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_4_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_4_2.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;用 al 传送要显示的数据</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">showbyte:</span>   <span class="keyword">jmp</span> short show</span><br><span class="line"></span><br><span class="line">            table <span class="built_in">db</span> <span class="string">'0123456789ABCDEF'</span>         <span class="comment">;字符表</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">    show:</span>   <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>                            <span class="comment">;mov cl,4</span></span><br><span class="line">            <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>                            <span class="comment">;shr ah,cl</span></span><br><span class="line">            <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>                            <span class="comment">;右移 4 位，ah 中得到高 4 位的值</span></span><br><span class="line">            <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span>                    <span class="comment">;al 中为低 4 位的值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,table[<span class="built_in">bx</span>]                    <span class="comment">;用高 4 位的值作为相对于 table 的偏移，取得对应的字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>],<span class="number">ah</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,table[<span class="built_in">bx</span>]                    <span class="comment">;用低 4 位的值作为相对于 table 的偏移，取得对应的字符</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span>+<span class="number">2</span>],<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<h3 id="依据数据直接计算出所要找的元素的位置（直接定址表）"><a class="header-anchor" href="#依据数据直接计算出所要找的元素的位置（直接定址表）">¶</a>依据数据直接计算出所要找的元素的位置（直接定址表）</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_5_1.PNG"/></div>
<p>可以占用一些内存空间来换取运算的速度，将所要计算的 sin(x) 的结果都存储到一张表中，然后用角度值来查表，找到对应的 sin(x) 的值。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;用 ax 向子程序传递角度 </span></span><br><span class="line"><span class="symbol">showsin:</span>    <span class="keyword">jmp</span> short show</span><br><span class="line"></span><br><span class="line">      table <span class="built_in">dw</span> ag0,ag30,ag60,ag90,ag120,ag150,ag180         <span class="comment">;字符串偏移地址表</span></span><br><span class="line">      ag0   <span class="built_in">db</span> <span class="string">'0'</span>,<span class="number">0</span>                                        <span class="comment">;sin(0)</span></span><br><span class="line">      ag30  <span class="built_in">db</span> <span class="string">'0.5'</span>,<span class="number">0</span>                                      <span class="comment">;sin(30)</span></span><br><span class="line">      ag60  <span class="built_in">db</span> <span class="string">'0.866'</span>,<span class="number">0</span>                                    <span class="comment">;sin(60)</span></span><br><span class="line">      ag90  <span class="built_in">db</span> <span class="string">'1'</span>,<span class="number">0</span>                                        <span class="comment">;sin(90)</span></span><br><span class="line">      ag120 <span class="built_in">db</span> <span class="string">'0.866'</span>,<span class="number">0</span>                                    <span class="comment">;sin(120)</span></span><br><span class="line">      ag150 <span class="built_in">db</span> <span class="string">'0.5'</span>,<span class="number">0</span>                                      <span class="comment">;sin(150)</span></span><br><span class="line">      ag180 <span class="built_in">db</span> <span class="string">'0'</span>,<span class="number">0</span>                                        <span class="comment">;sin(180)</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show:</span> <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">      <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;以下用角度值/30*2 作为于 table 的偏移，取得对应的字符串的偏移地址，放在 bx 中</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">30</span></span><br><span class="line">      <span class="keyword">div</span> <span class="built_in">bl</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">bx</span>,table[<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">;以下显示 sin(x) 对应的字符串</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">160</span>*<span class="number">12</span>+<span class="number">40</span>*<span class="number">2</span></span><br><span class="line"><span class="symbol">shows:</span><span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line">      <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">      <span class="keyword">je</span> showret</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">si</span>],<span class="number">ah</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">      <span class="keyword">jmp</span> short shows</span><br><span class="line"><span class="symbol">showret:</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">      <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">      <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<br>
<p>利用表，在两个数据集合之间建立一种映射关系，使我们能用查表的方法根据给出的数据得到其在另一集合中对应数据，这样做的目的一般来说有以下三个<br>
1）为了算法的清晰与简洁<br>
2）为了加快运算速度<br>
3）为了使程序易于扩充</p>
<p>像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表</p>
<h3 id="程序入口地址的直接定址表"><a class="header-anchor" href="#程序入口地址的直接定址表">¶</a>程序入口地址的直接定址表</h3>
<p>在直接定址表中存储子程序的地址可以方便地实现不同子程序的调用</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/16_6_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;清屏</span></span><br><span class="line"><span class="symbol">sub1:</span>       <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">sub1s:</span>      <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="string">' '</span>            <span class="comment">;将字符 ASCII 码全设置为空格，达到清屏的效果</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub1s</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置前景色</span></span><br><span class="line"><span class="symbol">sub2:</span>       <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">sub2s:</span>      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">11111000b</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">al</span>                       <span class="comment">;al 传递颜色值</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub2s</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置背景色</span></span><br><span class="line"><span class="symbol">sub3:</span>       <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">4</span>                            <span class="comment">;设置背景色，移位以方便运算</span></span><br><span class="line">            <span class="keyword">shl</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">sub3s:</span>      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">10001111b</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">al</span>                       <span class="comment">;al 传递颜色值</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub3s</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;向上滚动一行</span></span><br><span class="line"><span class="symbol">sub4:</span>       <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">si</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">si</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">cld</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">24</span></span><br><span class="line"><span class="symbol">sub4s:</span>      <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">160</span>                          <span class="comment">;一行 160 个字节</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span>                           <span class="comment">;下面一行整行向上覆盖掉上面一行</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">loop</span> sub4s                          <span class="comment">;注意 si 与 di 一直递增</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">sub4s1:</span>     <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="number">160</span>*<span class="number">24</span>+<span class="built_in">si</span>],<span class="string">' '</span>        <span class="comment">;处理最后一行</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub4s1</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。<br>
对应关系为：功能号*2=对应的功能子程序在地址表中的偏移</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">setscreen:</span>  <span class="keyword">jmp</span> short set</span><br><span class="line"></span><br><span class="line">      table <span class="built_in">dw</span> sub1,sub2,sub3,sub4</span><br><span class="line"></span><br><span class="line"><span class="symbol">      set:</span>  <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">3</span>                            <span class="comment">;判断功能号是否大于 3</span></span><br><span class="line">            <span class="keyword">ja</span> sret</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span>                           <span class="comment">;根据 ah 中的功能号计算对应子程序在 table 表中的偏移</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> table[<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">      sret:</span> <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>用根据功能号查找地址表的方法，程序的结构清晰，便于扩充。如果加入一个新的功能子程序，那么只需要在地址表中加入它的入口地址就可以了。</p>
<h3 id="实验任务"><a class="header-anchor" href="#实验任务">¶</a>实验任务</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/ex16_1.PNG"/></div>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,offset int7c                       <span class="comment">;设置 ds:si 指向源地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0200h</span>                              <span class="comment">;设置 es:di 指向目的地址</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,offset int7cend-offset int7c       <span class="comment">;设置 cx 为传输长度</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">cld</span>                                       <span class="comment">;设置传输方向为正</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span>                                 <span class="comment">;串传送操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">cli</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span>               <span class="comment">;设置中断向量表</span></span><br><span class="line">            <span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int7c:</span>      <span class="keyword">jmp</span> short set</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dw</span> offset sub1 - offset int7c + <span class="number">200h</span></span><br><span class="line">            <span class="built_in">dw</span> offset sub2 - offset int7c + <span class="number">200h</span></span><br><span class="line">            <span class="built_in">dw</span> offset sub3 - offset int7c + <span class="number">200h</span></span><br><span class="line">            <span class="built_in">dw</span> offset sub4 - offset int7c + <span class="number">200h</span></span><br><span class="line">            <span class="comment">;int7c 在0:200处，通过上式的计算，可以得到子程序sub(i)入口的地址</span></span><br><span class="line">            <span class="comment">;这里不能直接用 sub(i) 的标号找到 sub(i) 的入口地址</span></span><br><span class="line">            <span class="comment">;因为上面的程序会将位于 cs:offset int7c 的新中断处理程序复制到 0:200 处</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  set:</span>      <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line">            <span class="keyword">ja</span> sret</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>+<span class="number">202h</span>]                <span class="comment">;2 是 jmp short set 占的空间</span></span><br><span class="line">                                                      <span class="comment">;这里不能用之前的 table[bx]</span></span><br><span class="line">                                                      <span class="comment">;请深刻理解</span></span><br><span class="line">                                                      <span class="comment">;牢牢记住程序的本质</span></span><br><span class="line"><span class="symbol"> sret:</span>      <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序 1：清屏</span></span><br><span class="line"><span class="symbol">sub1:</span>       <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">sub1s:</span>      <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="string">' '</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub1s</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序 2：设置前景色</span></span><br><span class="line"><span class="symbol">sub2:</span>       <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">sub2s:</span>      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">11111000b</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub2s</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序 3：设置背景色</span></span><br><span class="line"><span class="symbol">sub3:</span>       <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">4</span></span><br><span class="line">            <span class="keyword">shl</span> <span class="built_in">al</span>,<span class="built_in">cl</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"><span class="symbol">sub3s:</span>      <span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">10001111b</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub3s</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序 4：向上滚动一行</span></span><br><span class="line"><span class="symbol">sub4:</span>       <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0b800h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">si</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">si</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">cld</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">24</span></span><br><span class="line"><span class="symbol">sub4s:</span>      <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">160</span></span><br><span class="line">            <span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">loop</span> sub4s</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">sub4s1:</span>     <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="number">160</span>*<span class="number">24</span>+<span class="built_in">si</span>],<span class="string">' '</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> sub4s1</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int7cend:</span>   <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>测试程序</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">1</span>                            <span class="comment">;功能号 1，设置前景色</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span>                            <span class="comment">;前景色设置为蓝色</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line">            <span class="keyword">call</span> delay</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>                            <span class="comment">;功能号 2，设置背景色</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">7</span>                            <span class="comment">;背景色设置为白色</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line">            <span class="keyword">call</span> delay</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span>                            <span class="comment">;功能号 3，向上滚动一行</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line">            <span class="keyword">call</span> delay</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span>                            <span class="comment">;功能号 0，清空屏幕</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line">            <span class="keyword">call</span> delay</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">delay:</span>      <span class="keyword">push</span> <span class="built_in">ax</span>                             <span class="comment">;延时函数</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">100h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span>                            <span class="comment">;循环 100 0000 h 次</span></span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">sub</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">            <span class="keyword">sbb</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jne</span> s1</span><br><span class="line">            <span class="keyword">cmp</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">jne</span> s1</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>测试程序运行</div><br>
<div align=center>前景色设置为蓝色</div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/ex16_2.PNG"/></div>
<p><br><div align=center>背景色设置为白色</div></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/ex16_3.PNG"/></div>
<p><br><div align=center>向上滚动一行</div></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/ex16_4.PNG"/></div>
<p><br><div align=center>清空屏幕</div></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C16/ex16_5.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机编程——状态机</title>
    <url>/2021/01/29/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>以下内容均摘自参考文献</p>
<h2 id="状态机建模"><a class="header-anchor" href="#状态机建模">¶</a>状态机建模</h2>
<p>状态机（State Machine），也叫有限状态机（Finite State Machine），简称状态机，状态机的概念来源于时序逻辑电路，又细分为 Mealy 状态机和 Moore 状态机，两者的区别在于是否只根据状态就能得出输出结果。</p>
<p>单片机中借用了这两种状态机的思想，引申出“状态中判断事件”和“事件中查询状态”两种单片机状态机的编程方法。</p>
<div align=center><img width = '500' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/Verilog/%E7%8A%B6%E6%80%81%E6%9C%BA.PNG"/></div><br>
<a id="more"></a>
<p>上图是一个通用的状态转换图框架，所有状态机都可以基于该框架进行扩展，Event 相当于事件检测函数检测出的事件，Action 相当于事件处理函数，且上图表达了以下信息：</p>
<ol>
<li>状态 State 的个数至少 2 个，多则不限，一般为有限多个，所以称为有限状态机。</li>
<li>并非所有 State 之间都有 Event 转换路径，比如 State0 → State1，State2 → State0 就没有。</li>
<li>同样的 State 转换，可能由不同的 Event 引发。</li>
<li>同样的 Event 未必触发同样的 Action。</li>
<li>Event 可以同时引起 State 变化，并触发 Action。</li>
<li>Event 也可以只触发 Action，而不引起 State 的变化。</li>
<li>Event 还可以只引起 State 的变化，而不触发任何 Action。</li>
</ol>
<h2 id="状态中判断事件"><a class="header-anchor" href="#状态中判断事件">¶</a>状态中判断事件</h2>
<p>对图中的状态机进行编程，可以采用 State 状态中判断 Event 事件的方法。这种方法类似于 Mealy 型状态机（不完全等同），即在 switch 语句中还需判断 Event 才能决定输出的结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------状态中查询事件（Mealy状态机）-----------</span></span><br><span class="line"><span class="keyword">switch</span>(State)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="keyword">if</span>(Event_0)     Action2();                      <span class="comment">//路径1</span></span><br><span class="line">                <span class="keyword">if</span>(Event_1)     &#123; State = <span class="number">2</span>;    Action0(); &#125;    <span class="comment">//路径2</span></span><br><span class="line">                <span class="keyword">if</span>(Event_2)     State = <span class="number">2</span>;                      <span class="comment">//路径3</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:     <span class="keyword">if</span>(Event_0)     State = <span class="number">2</span>;                      <span class="comment">//路径4</span></span><br><span class="line">                <span class="keyword">if</span>(Event_2)     &#123; State = <span class="number">0</span>;    Action2(); &#125;    <span class="comment">//路径5</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:     <span class="keyword">if</span>(Event_1)     &#123; State = <span class="number">1</span>;    Action1(); &#125;    <span class="comment">//路径6</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件中查询状态"><a class="header-anchor" href="#事件中查询状态">¶</a>事件中查询状态</h2>
<p>对图中的状态机进行编程，也可以采用 Event 事件中查询 State 状态的方法。这种方法类似于 Moore 型状态机（不完全等同），在 switch 语句中，即无需再判断 Event， 由当前状态就知道结果。<br>
其中，if(Event) 表达的含义是，无论用什么方法，只要能判断 Event 发生了，并不仅限于字面理解用 if 查询 Event，还包括直接在中断中判断 Event 的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------状态中查询事件（Moore状态机）-----------</span></span><br><span class="line"><span class="keyword">if</span>(Event0)                                                      <span class="comment">//中断或扫描得知Event0事件发生</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:     Action2();              <span class="keyword">break</span>;              <span class="comment">//路径1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     State = <span class="number">2</span>;              <span class="keyword">break</span>;              <span class="comment">//路径5</span></span><br><span class="line">        <span class="keyword">default</span>:                            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Event1)                                                      <span class="comment">//中断或扫描得知Event1事件发生     </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:     State = <span class="number">2</span>; Action0();   <span class="keyword">break</span>;`             <span class="comment">//路径3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     state = <span class="number">1</span>; Action1();   <span class="keyword">break</span>;              <span class="comment">//路径6</span></span><br><span class="line">        <span class="keyword">default</span>:                            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Event2)                                                      <span class="comment">//中断或扫描得知Event2事件发生</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(State)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:     State = <span class="number">2</span>;              <span class="keyword">break</span>;              <span class="comment">//路径4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     State = <span class="number">0</span>; Action2();   <span class="keyword">break</span>;              <span class="comment">//路径2</span></span><br><span class="line">        <span class="keyword">default</span>:                            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两种状态机的区别"><a class="header-anchor" href="#两种状态机的区别">¶</a>两种状态机的区别</h2>
<p>在时序逻辑电路中，Moore 状态机和 Mealy 状态机都可以用来描述任何状态机，并且两种状态机也可以互相转换。在单片机的编程中，刚刚举例，也证明了事件中查询状态和状态中查询事件都可以用来描述状态机。那么这两种方法有什么优缺点呢？</p>
<ol>
<li>如果 Event 直接由中断引发，不需要 if 语句轮询就能判断，则用 Moore 型状态机（事件中查询状态）执行速度快。这是因为只需执行对应 Event 的 switch(State) 语句，而且 switch 中只需对 State 进行判断就可以输出结果了。</li>
<li>如果 Event 本身就需要轮询才能得出，则使用 Mealy 型状态机（状态中查询事件）的代码要简单。因为状态中查询事件只有一个 switch(State) 语句。</li>
</ol>
<hr>
<h2 id="参考文献"><a class="header-anchor" href="#参考文献">¶</a>参考文献</h2>
<p>从零开启大学生电子设计之路：基于 MSP430 LaunchPad 口袋实验平台 / 杨艳，傅强编著. --北京：北京航空航天大学出版社，2014.8</p>
<hr>
]]></content>
      <tags>
        <tag>DIGITAL</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 课程设计 1</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="课程设计-1"><a class="header-anchor" href="#课程设计-1">¶</a>课程设计 1</h2>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/ks_1_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/ks_1_3.PNG"/></div>
<p>注意：</p>
<ol>
<li>选择适当的寻址方式和相关子程序的设计和应用；</li>
<li>程序中要显示的数据有些已经大于 65535，应该编写一个新的数据到字符串转化的子程序，完成 dword 型数据到字符串的转化；</li>
<li>注意子程序中除法溢出的问题，可以借鉴<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/#2-%E8%A7%A3%E5%86%B3%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">实验 10 中的子程序 divdw</a>；</li>
</ol>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/ks_1_2.PNG"/></div>
<figure class="highlight x86asm"><figcaption><span>ks_1.asm</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1975'</span>,<span class="string">'1976'</span>,<span class="string">'1977'</span>,<span class="string">'1978'</span>,<span class="string">'1979'</span>,<span class="string">'1980'</span>,<span class="string">'1981'</span>,<span class="string">'1982'</span>,<span class="string">'1983'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1984'</span>,<span class="string">'1985'</span>,<span class="string">'1986'</span>,<span class="string">'1987'</span>,<span class="string">'1988'</span>,<span class="string">'1989'</span>,<span class="string">'1990'</span>,<span class="string">'1991'</span>,<span class="string">'1992'</span></span><br><span class="line">      <span class="built_in">db</span> <span class="string">'1993'</span>,<span class="string">'1994'</span>,<span class="string">'1995'</span></span><br><span class="line">      <span class="comment">;以上表示 21 年的 21 个字符串</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dd</span> <span class="number">16</span>,<span class="number">22</span>,<span class="number">382</span>,<span class="number">1356</span>,<span class="number">2390</span>,<span class="number">8000</span>,<span class="number">16000</span>,<span class="number">24486</span>,<span class="number">50065</span>,<span class="number">97479</span>,<span class="number">140417</span>,<span class="number">197514</span></span><br><span class="line">      <span class="built_in">dd</span> <span class="number">345980</span>,<span class="number">590827</span>,<span class="number">803530</span>,<span class="number">1183000</span>,<span class="number">1843000</span>,<span class="number">2759000</span>,<span class="number">3753000</span>,<span class="number">4649000</span>,<span class="number">5937000</span></span><br><span class="line">      <span class="comment">;以上是表示 21 年公司总收入的 21 个 dword 型数据</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">28</span>,<span class="number">38</span>,<span class="number">130</span>,<span class="number">220</span>,<span class="number">476</span>,<span class="number">778</span>,<span class="number">1001</span>,<span class="number">1442</span>,<span class="number">2258</span>,<span class="number">2793</span>,<span class="number">4037</span>,<span class="number">5635</span>,<span class="number">8226</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">11542</span>,<span class="number">11430</span>,<span class="number">15257</span>,<span class="number">17800</span></span><br><span class="line">      <span class="comment">;以上是表示 21 年公司雇员的 21 个 word 型数据</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">string <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">8</span> dup (<span class="number">0</span>)</span><br><span class="line">string ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">dw</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span>      <span class="keyword">mov</span> <span class="built_in">ax</span>,data                         <span class="comment">;(ds)=data 段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,stack                        <span class="comment">;(ss)=stack 段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">32</span>                           <span class="comment">;栈顶</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span>                       <span class="comment">;(ex)=显示缓冲区段地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0a0h</span>                         <span class="comment">;从第 1 行开始(0 ~ 24 行)，第 0 行看不着</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bp</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span>                            <span class="comment">;ds:di 代表年份字符串中的单个字符地址</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">21</span>                           <span class="comment">;迭代 21 行</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s1:</span>      <span class="keyword">push</span> <span class="built_in">cx</span>                             <span class="comment">;通过压栈保存外循环的剩余的循环次数</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span>                            <span class="comment">;4 位数的年份</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>                            <span class="comment">;si 代表年份中每个数字在显示时的相对位置</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">   s2:</span>      <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">di</span>]                      </span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">7</span>                            <span class="comment">;00000111b 黑底白字</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>+<span class="built_in">si</span>],<span class="built_in">ax</span>                   <span class="comment">;将字符的 ASCII 码与其属性(颜色)送入显示缓冲区</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">loop</span> s2</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>:[<span class="built_in">di</span>].<span class="number">50h</span>                  <span class="comment">;54h + di - 4h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="built_in">di</span>].<span class="number">52h</span>                  <span class="comment">;54h + di + 2h - 4h</span></span><br><span class="line">            <span class="keyword">call</span> dtoc</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span>                             </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">20</span>                           <span class="comment">;di 为 show_str 的参数 </span></span><br><span class="line">            <span class="keyword">call</span> show_str</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>:[<span class="built_in">bp</span>].<span class="number">0a8h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> dtoc</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">40</span></span><br><span class="line">            <span class="keyword">call</span> show_str</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">ds</span>:[<span class="built_in">di</span>].<span class="number">50h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="built_in">di</span>].<span class="number">52h</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ds</span>:[<span class="built_in">bp</span>].<span class="number">0a8h</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">call</span> dtoc</span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">60</span></span><br><span class="line">            <span class="keyword">call</span> show_str</span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">0a0h</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">bp</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">loop</span> s1</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">            <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;名称：dtoc</span></span><br><span class="line"><span class="comment">;功能：将 dword 型数转变为表示十进制数的字符串，字符串以 0 为结尾符</span></span><br><span class="line"><span class="comment">;参数：(ax)=dword 型数据的低 16 位</span></span><br><span class="line"><span class="comment">;      (dx)=dword 型数据的高 16 位</span></span><br><span class="line"><span class="comment">;      ds:si 指向字符串的首地址</span></span><br><span class="line"><span class="comment">;返回：无</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">dtoc:</span>       <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">  s3:</span>       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">10</span></span><br><span class="line">            <span class="keyword">call</span> divdw</span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">cx</span>,<span class="number">30h</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">di</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">ax</span>                           <span class="comment">;判断商是否为 0，只有当商的高位与低位皆为 0 时商为 0</span></span><br><span class="line">            <span class="keyword">or</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>                            <span class="comment">;将商的高位与低位按位或，若结果为 0 则商为 0</span></span><br><span class="line">            <span class="keyword">jcxz</span> ok1</span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">loop</span> s3</span><br><span class="line">      </span><br><span class="line"><span class="symbol"> ok1:</span>       <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">di</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0e0h</span></span><br><span class="line">      </span><br><span class="line"><span class="symbol">  s4:</span>       <span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s4</span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">ret</span>            </span><br><span class="line"></span><br><span class="line"><span class="comment">;名称：divdw</span></span><br><span class="line"><span class="comment">;功能：进行不会产生溢出的除法运算，被除数为 dword 型，除数为 word 型，结果为 dword 型</span></span><br><span class="line"><span class="comment">;参数：(ax)=dword 型数据的低 16 位</span></span><br><span class="line"><span class="comment">;      (dx)=dword 型数据的高 16 位</span></span><br><span class="line"><span class="comment">;      (cx)=除数</span></span><br><span class="line"><span class="comment">;返回：(dx)=结果的高 16 位，(ax)=结果的低 16 位</span></span><br><span class="line"><span class="comment">;      (cx)=余数</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">divdw:</span>      <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span>                             <span class="comment">;高 16 位计算过程</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">dx</span>                           <span class="comment">;将被除数的高 16 位补零成 32 位放入 dx、ax 中</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>                              <span class="comment">;H/N, dx = rem(H/N), ax = int(H/N)</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>                           <span class="comment">;将(最终结果的)商的前 16 位保存</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span>                              <span class="comment">;低 16 位计算过程</span></span><br><span class="line">            <span class="keyword">div</span> <span class="built_in">cx</span>                              <span class="comment">;[rem(H/N)*65536+L]/N</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="built_in">dx</span>                           <span class="comment">;将余数放入 cx</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;名称：show_str</span></span><br><span class="line"><span class="comment">;功能：在指定的位置，用指定的颜色(黑底白字)，显示一个用 0 结束的字符串</span></span><br><span class="line"><span class="comment">;参数：di 为行偏置，bx 为列偏置</span></span><br><span class="line"><span class="comment">;      ds:si 指向字符串的首地址</span></span><br><span class="line"><span class="comment">;返回：无</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show_str:</span>   <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0e0h</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">7</span></span><br><span class="line"><span class="symbol">      s5:</span>   <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="built_in">al</span></span><br><span class="line">            <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">jcxz</span> ok2</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>+<span class="built_in">di</span>],<span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">            <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">loop</span> s5</span><br><span class="line"></span><br><span class="line"><span class="symbol">     ok2:</span>   <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">            <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">            <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<div align=center>用 Debug 跟踪程序运行</div><br>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A11/ks_1_4.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言》（第四版） 课程设计 2</title>
    <url>/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="课程设计-2"><a class="header-anchor" href="#课程设计-2">¶</a>课程设计 2</h2>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_2.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_3.PNG"/></div><br>
<p>我们自顶向下地梳理一下程序编写的思路，顺便对程序进行解释</p>
<p>首先，我们要搞清楚我们写的程序放在哪里去运行<br>
按照所给的材料理解，我们要把我们编写的这个可以自行启动计算机而不需要在现有操作系统环境中运行的程序放到软盘中去，这样当我们从软盘启动操作系统时，<code>int 19h</code> 将会控制 0 号软驱，读取软盘中我们编写的程序到内存 <code>0:7c00</code> 处，并将 <code>CS:IP</code> 指向 <code>0:7c00</code>，这样计算机就开始执行我们的控制程序</p>
<p>考虑到我们的程序长度会大于 512 个字节，即大于一个扇区的大小，那么它就需要用多个扇区来存放，于是我们不将它放在软盘 0 道 0 面 1 扇区，而将其从 2 号扇区开始存放，在 1 号扇区中，我们放一个 <code>introduce</code> 程序（为了方便，以后把这个要放入 1 号扇区中的程序称作 <code>introduce</code> 程序，把从 2 号扇区开始存放的我们主要要编写的程序称作 <code>boot</code> 程序），<code>introduce</code> 程序负责将软盘中的 <code>boot</code> 程序读入到内存中去，因为 <code>introduce</code> 程序会被 <code>int 19h</code> 读到内存 <code>0:7c00</code>，而一个扇区的大小为 200h，那么 <code>boot</code> 程序可以被读入到内存 <code>0:7e00</code> 处</p>
<p>于是我们在主程序中调用两个子程序<code>cpy_introduce_todiska</code> 和 <code>cpy_boot_todiska</code></p>
<p><code>cpy_introduce_todiska</code> 子程序负责将 <code>introduce</code> 程序写入一号扇区（调用 <code>int 13h</code> 的 3 号功能），而 <code>cpy_boot_todiska</code> 子程序负责将 <code>boot</code> 程序从 2 号扇区开始写入软盘，一共写几个扇区是通过计算 <code>boot</code> 程序的大小 / 一个扇区的大小得到，这里我们调试程序时知道了一共要写 2 个扇区（<code>mov al,2</code> (al)=读取的扇区数，<code>mov dl,0</code> 驱动器号设置为软驱）</p>
<p>调用完这两个子程序后，主程序就可以返回了，我们会在虚拟机上的 xp 系统中运行主程序，使得 <code>introduce</code> 程序与 <code>boot</code> 程序都写入软盘，然后我们关闭 xp 系统，在虚拟机中设置启动顺序为：软驱-&gt;光驱-&gt;硬盘，然后重新启动</p>
<p>重新启动后，计算机将运行我们的 <code>introduce</code> 程序，调用<code>cpy_boot_fromdiska</code> 子程序将在主程序中已经写入 2，3 号扇区的 <code>boot</code> 程序读到内存区 <code>0:7e00</code>，然后跳转至 <code>0:7e00</code>（使用 <code>retf</code> 指令）执行 <code>boot</code> 程序</p>
<p>注意，在 <code>introduce</code> 程序的结尾，需要填充字节</p>
<p>进入 <code>boot</code> 程序后，首先调用 <code>init_reg</code> 子程序进行段寄存器的初始化（(es)=0b800h，(ds)=0），再调用 <code>clear_screen</code> 子程序，将屏幕全初始化为空字符，属性为黑底白字，然后调用 <code>show_option</code> 子程序，将选项界面显示在屏幕上，注意，<code>show_option</code> 需要调用 <code>show_string</code> 子程序才能完成字符串显示功能，这个子程序将经常被别的子程序调用</p>
<p>显示了选项界面后，程序跳转到 <code>choose_option</code> 标号处，在这里一直循环等待键盘缓冲区输入的选项，这里调用 <code>int 16h</code> 的 0 号功能，<code>al</code> 中即为从键盘缓冲区读出的字符的 ASCII 码，因为数字 0 ~ 9 的 ASCII 码减去 30h 即为数字本身，所以我们将 <code>al</code> 减去 30h 并与 1，2，3，4 逐个比较，若相等则进行跳转</p>
<p>为了体现我们做了选择，屏幕中可以进行反馈，将选中的选项在屏幕中显示为黑底绿字，我们用 <code>change_option_color</code> 子程序来完成这项功能，注意，在每次设置相应选项为黑底绿字前，先恢复所有选项为黑底白字</p>
<p>选项 1：<code>ischooseone</code><br>
1）reset pc 重新启动计算机（考虑 <code>ffff:0</code> 单元）<br>
调用 <code>reset</code> 子程序，其功能为跳转至内存 <code>ffff:0</code> 处执行，根据材料可知这样能够重新启动，再次进入主选单</p>
<p>选项 2：<code>ischoosetwo</code><br>
2）start system 引导现有的操作系统（考虑硬盘 C 的 0 道 0 面 1 扇区）<br>
调用 <code>start_syetem</code> 子程序，该子程序模拟 <code>int 19h</code> 的功能，先读取硬盘 C 的 0 道 0 面 1 扇区的内容到 <code>0:7c00</code>，再将 <code>CS:IP</code> 指向 <code>0:7c00</code>，这样我们就引导了现有的操作系统，即计算机开始运行 windows xp 系统</p>
<p>选项 3：<code>ischoosethree</code><br>
3）clock 进入时钟程序<br>
动态显示当前时间即屏幕上时间按秒变化（循环读取 CMOS）<br>
且按 F1 改变其显示颜色，按 Esc 回到主选单<br>
调用 <code>show_clock</code> 子程序，在子程序中循环读取 CMOS 以获取时间，并且用 <code>save_old_int9</code> 保存好原有的 <code>int 9h</code>，用 <code>set_new_int9</code> 设置安装新的 <code>int 9h</code>，通过键盘中断的方式，检测 F1 和 Esc 的通码（3bh 和 01h），若检测到按下 F1，调用 <code>change_time_color</code> 以改变屏幕上显示时间的颜色，若检测到按下 Esc，则返回到主选单，注意 <code>isesc</code> 的写法，应该模拟 <code>int9_ret</code> 并跳转到 <code>show_time_ret</code> 处，这样才能正常返回到主选单，<code>show_time_ret</code> 处会恢复原有的 <code>int 9h</code></p>
<p>选项 4：<code>ischoosefour</code><br>
4）set clock 设置时间（输入字符串）<br>
更改后返回主选单<br>
调用 <code>set_clock</code> 子程序，该子程序由四个子程序组成，其中 <code>clear_string_stack</code> 负责将字符栈中内容全设为字符 ‘0’，<code>show_string_stack</code> 将字符栈中内容显示至屏幕上，<code>get_string</code> 负责处理键盘输入的数字，处理输入的退格键（backspace）与回车键（enter），<code>set_time</code> 负责将字符栈中的内容以 BCD 码的形式写入端口，从而完成设置时间的功能</p>
<p>注意，在调用完成四个功能的子程序后，jmp 转移的标号并不相同</p>
<p>完整程序如下</p>
<figure class="highlight x86asm"><figcaption><span>ks_2.asm</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">;注释掉的指令为边编写边调试过程中所用的指令</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">256</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line">      <span class="built_in">db</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>            <span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">128</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">;计算 boot 程序大小</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,offset boot_end - offset boot      </span><br><span class="line"></span><br><span class="line">                  <span class="comment">;将 introduce 程序写入软盘</span></span><br><span class="line">                  <span class="keyword">call</span> cpy_introduce_todiska</span><br><span class="line">                  <span class="comment">;将 boot 程序写入软盘</span></span><br><span class="line">                  <span class="keyword">call</span> cpy_boot_todiska</span><br><span class="line"></span><br><span class="line">                  <span class="comment">;call cpy_boot</span></span><br><span class="line">                  <span class="comment">;call save_old_int9</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">;mov ax,0</span></span><br><span class="line">                  <span class="comment">;push ax</span></span><br><span class="line">                  <span class="comment">;mov ax,7e00h</span></span><br><span class="line">                  <span class="comment">;push ax</span></span><br><span class="line">                  <span class="comment">;retf</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;程序长度大于 512 个字节，需要用多个扇区存放，</span></span><br><span class="line"><span class="comment">;处于软盘 0 道 0 面 1 扇区中的程序负责将其他扇区中的内容读入内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;introduce 程序</span></span><br><span class="line"><span class="comment">;负责将处于软盘中 2，3 号扇区的 boot 程序读到内存 0:7e00</span></span><br><span class="line"><span class="comment">;并将 CS:IP 指向 0:7e00</span></span><br><span class="line"><span class="symbol">introduce:</span>        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">7c00h</span>                  <span class="comment">;设置栈，用 0:7c00 前的空间当栈</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;                  call save_old_int9</span></span><br><span class="line">                  <span class="comment">;将 boot 程序从软盘中读到内存去</span></span><br><span class="line">                  <span class="keyword">call</span> cpy_boot_fromdiska</span><br><span class="line"></span><br><span class="line">                  <span class="comment">;利用 retf 指令跳转至 0:7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">retf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;save_old_int9:    mov bx,0</span></span><br><span class="line"><span class="comment">;                  mov es,bx</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;                  push es:[9*4]</span></span><br><span class="line"><span class="comment">;                  pop es:[200h]</span></span><br><span class="line"><span class="comment">;                  push es:[9*4+2]</span></span><br><span class="line"><span class="comment">;                  pop es:[202h]</span></span><br><span class="line"><span class="comment">;                  </span></span><br><span class="line"><span class="comment">;                  ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;将 2、3 号扇区的程序读到内存 0:7e00                  </span></span><br><span class="line"><span class="symbol">cpy_boot_fromdiska:</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">7e00h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">2</span>                      <span class="comment">;读取的扇区数</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">2</span>                                  </span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>                      <span class="comment">;读扇区                                  </span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;introduce 程序结束</span></span><br><span class="line"><span class="symbol">introduce_end:</span>    <span class="built_in">db</span> <span class="number">512</span> dup (<span class="number">0</span>)</span><br><span class="line">                  <span class="comment">;填充字节</span></span><br><span class="line">                  <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;将 introduce 程序写入软盘</span></span><br><span class="line"><span class="symbol">cpy_introduce_todiska:</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,offset introduce</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span>                      <span class="comment">;写入一号扇区</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;将 boot 程序写入软盘</span></span><br><span class="line"><span class="symbol">cpy_boot_todiska:</span> </span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,offset boot</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">2</span>                      <span class="comment">;从二号扇区开始写入</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">3</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">13h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;boot 程序</span></span><br><span class="line"><span class="comment">;主要编写的程序，包含我们要实现的各种功能</span></span><br><span class="line"><span class="symbol">boot:</span>             <span class="keyword">jmp</span> boot_start</span><br><span class="line"></span><br><span class="line"><span class="comment">;********************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;选项字符串</span></span><br><span class="line">option_1          <span class="built_in">db</span>    <span class="string">'1) reset pc '</span>,<span class="number">0</span>        <span class="comment">;重新启动计算机                 </span></span><br><span class="line">option_2          <span class="built_in">db</span>    <span class="string">'2) start system '</span>,<span class="number">0</span>    <span class="comment">;引导现有的操作系统</span></span><br><span class="line">option_3          <span class="built_in">db</span>    <span class="string">'3) clock '</span>,<span class="number">0</span>           <span class="comment">;进入时钟程序</span></span><br><span class="line">option_4          <span class="built_in">db</span>    <span class="string">'4) set clock '</span>,<span class="number">0</span>       <span class="comment">;设置时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;选项字符串的实际地址（直接定址表）</span></span><br><span class="line">address_option    <span class="built_in">dw</span>    offset option_1 - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="built_in">dw</span>    offset option_2 - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="built_in">dw</span>    offset option_3 - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="built_in">dw</span>    offset option_4 - offset boot + <span class="number">7e00h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;COMS RAM 单元</span></span><br><span class="line"><span class="comment">;对应年月日时分秒</span></span><br><span class="line">time_cmos         <span class="built_in">db</span>    <span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span></span><br><span class="line"><span class="comment">;时间显示格式</span></span><br><span class="line">time_style        <span class="built_in">db</span>    <span class="string">'YY/MM/DD HH:MM:SS'</span>,<span class="number">0</span></span><br><span class="line"><span class="comment">;字符栈</span></span><br><span class="line">string_stack      <span class="built_in">db</span>    <span class="number">12</span> dup (<span class="string">'0'</span>),<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;********************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">boot_start:</span>       <span class="keyword">call</span> init_reg                 <span class="comment">;段寄存器初始化</span></span><br><span class="line">                  <span class="keyword">call</span> clear_screen             <span class="comment">;屏幕初始化</span></span><br><span class="line">                  <span class="keyword">call</span> show_option              <span class="comment">;显示选项</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">jmp</span> choose_option             <span class="comment">;处理选项</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;choose_option 子程序</span></span><br><span class="line"><span class="comment">;读取键盘缓冲区，得到从键盘传来的对四个选项的选择</span></span><br><span class="line"><span class="comment">;逐个比较并进行跳转</span></span><br><span class="line"><span class="comment">;若读到无效输入则继续等待</span></span><br><span class="line"><span class="symbol">choose_option:</span>    <span class="keyword">call</span> clear_buff               <span class="comment">;清理键盘缓冲区</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">;数字的 ASCII 码减 30h 得到数字本身</span></span><br><span class="line">                  <span class="keyword">sub</span> <span class="built_in">al</span>,<span class="number">30h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">je</span> ischooseone</span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">je</span> ischoosetwo</span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">3</span></span><br><span class="line">                  <span class="keyword">je</span> ischoosethree                  </span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">4</span></span><br><span class="line">                  <span class="keyword">je</span> ischoosefour</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">jmp</span> choose_option</span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;各个选项的处理</span></span><br><span class="line"><span class="comment">;包含功能子程序和完成后的跳转指令</span></span><br><span class="line"><span class="comment">;跳转的地址标号并不相同</span></span><br><span class="line"><span class="symbol">ischooseone:</span>      <span class="keyword">call</span> change_option_color</span><br><span class="line">                  <span class="keyword">call</span> reset</span><br><span class="line">                  <span class="keyword">jmp</span> choose_option</span><br><span class="line"></span><br><span class="line"><span class="symbol">ischoosetwo:</span>      <span class="keyword">call</span> change_option_color</span><br><span class="line">                  <span class="keyword">call</span> start_syetem</span><br><span class="line">                  <span class="keyword">jmp</span> choose_option</span><br><span class="line"></span><br><span class="line"><span class="symbol">ischoosethree:</span>    <span class="keyword">call</span> change_option_color</span><br><span class="line">                  <span class="keyword">call</span> show_clock      </span><br><span class="line">                  <span class="keyword">jmp</span> boot_start</span><br><span class="line"></span><br><span class="line"><span class="symbol">ischoosefour:</span>     <span class="keyword">call</span> change_option_color</span><br><span class="line">                  <span class="keyword">call</span> set_clock</span><br><span class="line">                  <span class="keyword">jmp</span> boot_start</span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;reset 子程序</span></span><br><span class="line"><span class="comment">;将 CS:IP 指向 ffff:0</span></span><br><span class="line"><span class="comment">;ffff:0 处有一条跳转指令</span></span><br><span class="line"><span class="comment">;CPU 执行该指令后，转去执行 BIOS 中的硬件系统检测和初始化程序</span></span><br><span class="line"><span class="comment">;这样就实现了重新启动的功能</span></span><br><span class="line"><span class="symbol">reset:</span>            <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0ffffh</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">retf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;start_syetem 子程序</span></span><br><span class="line"><span class="comment">;模拟 int 19h 的功能</span></span><br><span class="line"><span class="comment">;读取硬盘 C 的 0 道 0 面 1 扇区的内容到 0:7c00</span></span><br><span class="line"><span class="comment">;将 CS:IP 指向 0:7c00</span></span><br><span class="line"><span class="comment">;C 盘中就存放了我们的 windows xp 系统</span></span><br><span class="line"><span class="comment">;这样就实现了引导现有操作系统的功能</span></span><br><span class="line"><span class="symbol">start_syetem:</span>     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span> </span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">7c00h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cl</span>,<span class="number">1</span>                                  </span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="number">80h</span>                    <span class="comment">;C 盘</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">dh</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">2</span>                                                                                               </span><br><span class="line">                  <span class="keyword">int</span> <span class="number">13h</span>                       <span class="comment">;读取硬盘 C 的 0 道 0 面 1 扇区</span></span><br><span class="line">                                                <span class="comment">;的内容到 0:7c00</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">7c00h</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">retf</span>                          <span class="comment">;将 CS:IP 指向 0:7c00</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;set_clock 子程序</span></span><br><span class="line"><span class="comment">;顺序调用了 clear_string_stack、show_string_stack、get_string、set_time 这些子程序</span></span><br><span class="line"><span class="comment">;设置时间，更改后返回</span></span><br><span class="line"><span class="symbol">set_clock:</span>        <span class="keyword">call</span> clear_string_stack</span><br><span class="line">                  <span class="keyword">call</span> show_string_stack</span><br><span class="line">                  <span class="keyword">call</span> get_string</span><br><span class="line">                  <span class="keyword">call</span> set_time</span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;set_time 子程序</span></span><br><span class="line"><span class="comment">;将字符栈中的内容以 BCD 码的形式写入端口（此行为发生在按下 enter 键后）</span></span><br><span class="line"><span class="symbol">set_time:</span>         <span class="keyword">mov</span> <span class="built_in">bx</span>,offset time_cmos - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">si</span>,offset string_stack - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">set_times:</span>        <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]                <span class="comment">;将 ASCII 码转换成 BCD 码</span></span><br><span class="line">                  <span class="keyword">sub</span> <span class="number">dh</span>,<span class="number">30h</span></span><br><span class="line">                  <span class="keyword">sub</span> <span class="built_in">dl</span>,<span class="number">30h</span></span><br><span class="line">                  <span class="keyword">shl</span> <span class="built_in">dl</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">shl</span> <span class="built_in">dl</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">shl</span> <span class="built_in">dl</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">shl</span> <span class="built_in">dl</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">and</span> <span class="number">dh</span>,<span class="number">00001111b</span></span><br><span class="line">                  <span class="keyword">or</span> <span class="built_in">dl</span>,<span class="number">dh</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>]                <span class="comment">;写入端口</span></span><br><span class="line">                  <span class="keyword">out</span> <span class="number">70h</span>,<span class="built_in">al</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">dl</span></span><br><span class="line">                  <span class="keyword">out</span> <span class="number">71h</span>,<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">loop</span> set_times</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;get_string 子程序</span></span><br><span class="line"><span class="comment">;处理键盘输入的数字</span></span><br><span class="line"><span class="comment">;处理输入的退格键（backspace）与回车键（enter）</span></span><br><span class="line"><span class="symbol">get_string:</span>       <span class="keyword">mov</span> <span class="built_in">si</span>,offset string_stack - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>                                        </span><br><span class="line"></span><br><span class="line"><span class="symbol">get_strings:</span>      <span class="keyword">call</span> clear_buff               <span class="comment">;清理键盘缓冲区</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span>                      <span class="comment">;读取键盘输入</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">'0'</span></span><br><span class="line">                  <span class="keyword">jb</span> notnumber</span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="string">'9'</span></span><br><span class="line">                  <span class="keyword">ja</span> notnumber                  <span class="comment">;检测是否为数字 0 ~ 9 </span></span><br><span class="line">                  <span class="keyword">call</span> char_push                <span class="comment">;压入字符栈</span></span><br><span class="line">                  <span class="keyword">call</span> show_string_stack        <span class="comment">;显示压入后字符栈中内容</span></span><br><span class="line">                  <span class="keyword">jmp</span> get_strings               <span class="comment">;循环等待键盘输入</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">get_string_ret:</span>   <span class="keyword">ret</span>                           <span class="comment">;按下 enter 键后跳转到这里，子程序返回</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">notnumber:</span>        <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">0eh</span>                    <span class="comment">;backspace</span></span><br><span class="line">                  <span class="keyword">je</span> isbackspace</span><br><span class="line">                  <span class="keyword">cmp</span> <span class="number">ah</span>,<span class="number">1ch</span>                    <span class="comment">;enter</span></span><br><span class="line">                  <span class="keyword">je</span> get_string_ret</span><br><span class="line">                  <span class="keyword">jmp</span> get_strings</span><br><span class="line"></span><br><span class="line"><span class="symbol">isbackspace:</span>      <span class="keyword">call</span> char_pop                 <span class="comment">;按下 backspace 键后，弹出栈顶元素</span></span><br><span class="line">                  <span class="keyword">call</span> show_string_stack        <span class="comment">;显示弹出后字符栈中内容</span></span><br><span class="line">                  <span class="keyword">jmp</span> get_strings</span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;编写栈操作时注意，(bx) 为栈中元素的个数，第 (bx) 个栈元素的偏移地址为 (bx)-1 </span></span><br><span class="line"><span class="comment">;字符栈弹出操作</span></span><br><span class="line"><span class="symbol">char_pop:</span>         <span class="keyword">cmp</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">je</span> char_pop_ret               <span class="comment">;栈空</span></span><br><span class="line">                  <span class="keyword">dec</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="string">'0'</span>   <span class="comment">;在退栈处补 '0'</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">char_pop_ret:</span>     <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;字符栈压栈操作</span></span><br><span class="line"><span class="symbol">char_push:</span>        <span class="keyword">cmp</span> <span class="built_in">bx</span>,<span class="number">11</span></span><br><span class="line">                  <span class="keyword">ja</span> char_push_ret              <span class="comment">;栈满</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>+<span class="built_in">bx</span>],<span class="built_in">al</span></span><br><span class="line">                  <span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">char_push_ret:</span>    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;show_string_stack 子程序</span></span><br><span class="line"><span class="comment">;将字符栈中内容显示至屏幕上</span></span><br><span class="line"><span class="comment">;需要调用 show_string 子程序</span></span><br><span class="line"><span class="symbol">show_string_stack:</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">si</span>,offset string_stack - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">160</span>*<span class="number">24</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">call</span> show_string</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;clear_string_stack 子程序</span></span><br><span class="line"><span class="comment">;将字符栈中内容全设为字符 '0'</span></span><br><span class="line"><span class="comment">;即初始化字符栈</span></span><br><span class="line"><span class="symbol">clear_string_stack:</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">si</span>,offset string_stack - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">3030h</span></span><br><span class="line">                  <span class="comment">;30h 为字符 0</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">clear_string_stacks:</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>],<span class="built_in">dx</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">loop</span> clear_string_stacks</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;show_clock 子程序</span></span><br><span class="line"><span class="comment">;动态显示当前时间且按 F1 改变其显示颜色，按 Esc 回到主选单</span></span><br><span class="line"><span class="comment">;调用了 show_style、save_old_int9、set_new_int9、set_old_int9 这些子程序</span></span><br><span class="line"><span class="symbol">show_clock:</span>       <span class="keyword">call</span> show_style               <span class="comment">;显示格式</span></span><br><span class="line">                  <span class="keyword">call</span> save_old_int9            <span class="comment">;保存原 int 9h 入口地址</span></span><br><span class="line">                  <span class="keyword">call</span> set_new_int9             <span class="comment">;设置新 int 9h 到中断向量表</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,offset time_cmos - offset boot + <span class="number">7e00h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;每显示完一次又跳转回 show_time</span></span><br><span class="line"><span class="comment">;循环读取 CMOS RAM</span></span><br><span class="line"><span class="symbol">show_time:</span>        <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">160</span>*<span class="number">20</span>+<span class="number">30</span>*<span class="number">2</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">6</span> </span><br><span class="line"></span><br><span class="line"><span class="symbol">show_date:</span>        <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">                  <span class="keyword">out</span> <span class="number">70h</span>,<span class="built_in">al</span></span><br><span class="line">                  <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">71h</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">;解析 BCD 码</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">                  <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">;转换成 ASCII 码</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="number">ah</span>,<span class="number">30h</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">30h</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="number">ah</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>+<span class="number">2</span>],<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">;注意中间有分隔符，所以不是 add di,4</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">6</span></span><br><span class="line">                  <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line">                  <span class="comment">;显示 1 次这里循环 6 次</span></span><br><span class="line">                  <span class="comment">;每次循环显示 2 个数字</span></span><br><span class="line">                  <span class="keyword">loop</span> show_date</span><br><span class="line">                  <span class="keyword">jmp</span> show_time</span><br><span class="line"></span><br><span class="line"><span class="comment">;通过按下 Esc 键引发键盘中断</span></span><br><span class="line"><span class="comment">;经新的 int 9h 中断例程处理，跳转到此处</span></span><br><span class="line"><span class="comment">;恢复原 int 9h 中断例程，并返回</span></span><br><span class="line"><span class="symbol">show_time_ret:</span>    <span class="keyword">call</span> set_old_int9</span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;show_style 子程序</span></span><br><span class="line"><span class="comment">;在屏幕上显示时间显示的格式</span></span><br><span class="line"><span class="comment">;即 'YY/MM/DD HH:MM:SS'</span></span><br><span class="line"><span class="symbol">show_style:</span>       <span class="keyword">mov</span> <span class="built_in">si</span>,offset time_style - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">160</span>*<span class="number">20</span>+<span class="number">30</span>*<span class="number">2</span></span><br><span class="line">                  <span class="keyword">call</span> show_string</span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;clear_buff 子程序</span></span><br><span class="line"><span class="comment">;清理键盘缓冲区</span></span><br><span class="line"><span class="symbol">clear_buff:</span>       <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line">                  <span class="keyword">jz</span> clear_buff_ret</span><br><span class="line">                  <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">int</span> <span class="number">16h</span></span><br><span class="line">                  <span class="keyword">jmp</span> clear_buff</span><br><span class="line"></span><br><span class="line"><span class="symbol">clear_buff_ret:</span>   <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;show_option 子程序</span></span><br><span class="line"><span class="comment">;在屏幕中间显示四个选项（四行）</span></span><br><span class="line"><span class="comment">;需要调用 show_string 子程序</span></span><br><span class="line"><span class="symbol">show_option:</span>      <span class="keyword">mov</span> <span class="built_in">bx</span>,offset address_option - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">160</span>*<span class="number">10</span>+<span class="number">30</span>*<span class="number">2</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show_options:</span>     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line">                  <span class="keyword">call</span> show_string</span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">160</span></span><br><span class="line">                  <span class="keyword">loop</span> show_options</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;show_string 子程序</span></span><br><span class="line"><span class="comment">;在屏幕上显示内存中存放的字符串</span></span><br><span class="line"><span class="comment">;其结束符为 0，若检测到结束符则返回</span></span><br><span class="line"><span class="comment">;(es)=0b800h, 即显示缓冲区的段地址</span></span><br><span class="line"><span class="comment">;(di)=显示缓冲区的偏移地址</span></span><br><span class="line"><span class="comment">;ds:si=要显示的字符串在内存中存放的地址</span></span><br><span class="line"><span class="symbol">show_string:</span>      <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">di</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">showstrings:</span>      <span class="keyword">mov</span> <span class="built_in">dl</span>,<span class="built_in">ds</span>:[<span class="built_in">si</span>]</span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">dl</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">je</span> show_string_ret</span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>],<span class="built_in">dl</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">di</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">                  <span class="keyword">jmp</span> showstrings</span><br><span class="line"></span><br><span class="line"><span class="symbol">show_string_ret:</span>  <span class="keyword">pop</span> <span class="built_in">di</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">ds</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;clear_screen 子程序</span></span><br><span class="line"><span class="comment">;将屏幕初始化为空字符（0x00），属性为黑底白字（0x70）</span></span><br><span class="line"><span class="symbol">clear_screen:</span>     <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">dx</span>,<span class="number">0700h</span>                  <span class="comment">;高位：0000 0111 b</span></span><br><span class="line">                                                <span class="comment">;低位：0x00 </span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">clear_screens:</span>    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">dx</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">loop</span> clear_screens</span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;保存原有的 int 9h 中断例程的入口地址</span></span><br><span class="line"><span class="symbol">save_old_int9:</span>    <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">200h</span>]</span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">202h</span>]</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span> </span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;恢复原有的 int 9h 中断例程</span></span><br><span class="line"><span class="comment">;将原有的 int 9h 中断例程的入口地址重新写入中断向量表</span></span><br><span class="line"><span class="symbol">set_old_int9:</span>     <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">cli</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">200h</span>]</span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>]</span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">202h</span>]</span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line">                  <span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;安装新的 int 9h 中断例程</span></span><br><span class="line"><span class="comment">;将新的 int 9h 中断例程的入口地址写入中断向量表</span></span><br><span class="line"><span class="symbol">set_new_int9:</span>     <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">cli</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>],offset new_int9 - offset boot + <span class="number">7e00h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>*<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line">                  <span class="keyword">sti</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;新的 int 9h 中断例程</span></span><br><span class="line"><span class="comment">;对 Esc 键与 F1 键的按下进行处理</span></span><br><span class="line"><span class="comment">;按下 F1 后，改变显示颜色</span></span><br><span class="line"><span class="comment">;按下 Esc 后，返回到主选单</span></span><br><span class="line"><span class="symbol">new_int9:</span>         <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">call</span> clear_buff               <span class="comment">;清理键盘缓冲区</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">in</span> <span class="built_in">al</span>,<span class="number">60h</span>                     <span class="comment">;从 60h 端口读取扫描码</span></span><br><span class="line">                  <span class="keyword">pushf</span>                         </span><br><span class="line">                  <span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">cs</span>:[<span class="number">200h</span>]      <span class="comment">;对 int 指令进行模拟，调用原来的 int 9h 中断例程</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">01h</span>                    <span class="comment">;ESC 的通码为 01h</span></span><br><span class="line">                  <span class="keyword">je</span> isesc</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">3bh</span>                    <span class="comment">;F1 的通码为 3bh         </span></span><br><span class="line">                  <span class="keyword">jne</span> int9_ret</span><br><span class="line">                  <span class="keyword">call</span> change_time_color        <span class="comment">;改变显示颜色</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9_ret:</span>         <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;模拟 int9_ret 并跳转到 show_time_ret</span></span><br><span class="line"><span class="symbol">isesc:</span>            <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">sp</span>,<span class="number">4</span></span><br><span class="line">                  <span class="keyword">popf</span></span><br><span class="line">                  <span class="keyword">jmp</span> show_time_ret</span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;change_time_color 子程序</span></span><br><span class="line"><span class="comment">;改变显示时间的字符的颜色</span></span><br><span class="line"><span class="comment">;通过 inc byte ptr es:[bx] 即属性字节自增实现</span></span><br><span class="line"><span class="symbol">change_time_color:</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">160</span>*<span class="number">20</span>+<span class="number">30</span>*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">17</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">change_time_colors:</span>  </span><br><span class="line">                  <span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>]</span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">loop</span> change_time_colors</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;changee_option_color 子程序</span></span><br><span class="line"><span class="comment">;先将所有选项恢复显示为黑底白字（四行）</span></span><br><span class="line"><span class="comment">;再将选中选项显示为黑底绿字（一行）</span></span><br><span class="line"><span class="comment">;(al)=选中的选项的数字</span></span><br><span class="line"><span class="symbol">change_option_color:</span>   </span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">160</span>*<span class="number">10</span>+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span>*<span class="number">4</span>                   <span class="comment">;四行</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">change_p1s:</span>       <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">07h</span>      <span class="comment">;黑底白字</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">loop</span> change_p1s</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">9</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">160</span></span><br><span class="line">                  <span class="keyword">mul</span> <span class="built_in">bl</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">inc</span> <span class="built_in">bx</span>                        <span class="comment">;计算选中的选项那一行的偏移</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">80</span>                     <span class="comment">;一行</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">change_p2s:</span>       <span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="number">02h</span>      <span class="comment">;黑底绿字</span></span><br><span class="line">                  <span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span></span><br><span class="line">                  <span class="keyword">loop</span> change_p2s</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">                  <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;段寄存器初始化</span></span><br><span class="line"><span class="comment">;(es)=0b800h, (ds)=0</span></span><br><span class="line"><span class="symbol">init_reg:</span>         <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">                  <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">                  <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;boot 程序结束</span></span><br><span class="line"><span class="symbol">boot_end:</span>         <span class="built_in">db</span> <span class="number">512</span> dup (<span class="number">0</span>)</span><br><span class="line">                  <span class="comment">;填充字节</span></span><br><span class="line">                  <span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"><span class="comment">;cpy_boot:         mov ax,cs</span></span><br><span class="line"><span class="comment">;                  mov ds,ax</span></span><br><span class="line"><span class="comment">;                  mov si,offset boot</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;                  mov ax,0</span></span><br><span class="line"><span class="comment">;                  mov es,ax</span></span><br><span class="line"><span class="comment">;                  mov di,7e00h</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;                  mov cx,offset boot_end-offset boot</span></span><br><span class="line"><span class="comment">;                  cld</span></span><br><span class="line"><span class="comment">;                  rep movsb</span></span><br><span class="line"><span class="comment">;                  ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;================================================================================</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<p>代码学习自 <a href="https://www.bilibili.com/video/BV1mt411R7Xv?p=255" target="_blank" rel="noopener">【bilibili: 紫狐遗梦】汇编语言从0开始 课程设计二</a>，有一些修改</p>
<p>最终结果展示：</p>
<p><br><div align=center>用 Oracle VM VirtualBox 建立的 windows xp 32位 虚拟机</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_4.PNG"/></div>
<p><br><div align=center>从软驱启动</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_5.PNG"/></div>
<p><br><div align=center>显示时钟</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_6.PNG"/></div>
<p><br><div align=center>引导现有的操作系统</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_7.PNG"/></div>
<p><br><div align=center>被写入程序的软盘</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_8.PNG"/></div>
<p><br><div align=center>设置时间</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_9.PNG"/></div>
<p><br><div align=center>设置成功</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_10.PNG"/></div>
<p><br><div align=center>改变显示颜色</div><br></p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A12/ks_11.PNG"/></div>
<hr>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数据结构</title>
    <url>/2022/06/22/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=3" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356434" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-简单数据结构</a> 但是没得密码。。。<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>简单数据结构</h1>
<h2 id="前缀和"><a class="header-anchor" href="#前缀和">¶</a>前缀和</h2>
<h3 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h3>
<p>若 $S[i] = \sum\limits^{i}_{j=1} A[j]$，则称 $S$ 是 $A$ 的前缀和</p>
<p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前 $n$ 项的和”。有以下性质：</p>
<p>$$sum[l, r] = \sum^{r}_{i=1} A[i] = S[r] - S[l - 1]$$</p>
<ul>
<li>给定 $A$ 数列，长度为 $n$，$m$ 次询问，每次询问 $L_i, R_i$ 求 $\sum^{R_i}_{j=L_i} A[j]$（区间和）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用 O(n) 前缀和预处理，O(m) 询问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum[i] = sum[i - <span class="number">1</span>] + a[i]; <span class="comment">//O(n)</span></span><br><span class="line"><span class="keyword">while</span>(m--)  <span class="comment">//O(m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> L, R; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum[R] - sum[L - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>给定 $A$ 数列，长度为 $n$，先 $m$ 次修改，再 $q$ 次询问，每次修改为在 $A$ 数组的区间 $[ L_i, R_i ]$ 内都加上一个数 $x$，即 $A[j] += x, j \in [ L_i, R_i ], j \in R$， 每次询问 $L_i, R_i$ 求 $\sum^{R_i}_{j=L_i} A[j]$（区间和）<br>
在这里实际上引入了差分的思想，由于要进行 $m$ 次的修改，每次修改都是对一个区间长度内的所有元素做加法，这样明显是一个不太聪明的做法，我们可以先将原数组处理为其差分数组，将对原数组在区间上的修改转变成为对其差分数组的头与尾后的修改，修改完成后，对差分数组再求前缀和即可得到原数组（利用前缀和与差分互为逆运算的性质），再利用原数组去求区间和。</li>
</ul>
<div align=center><img width = '560' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/差分与前缀和.PNG"/></div>
<ul>
<li>若 $A$ 数组的差分数组为 $B$ 数组，$A[j] += x, j \in [ L_i, R_i ], j \in R$ 就等价于 $B[L_i] += x, B[R_i+1] -= x$</li>
</ul>
<div align=center><img width = '700' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9.PNG"/></div>
<ul>
<li>如果 $n$ 很大怎么办？<br>
可以对用到的下标做离散化</li>
</ul>
<h3 id="扩展"><a class="header-anchor" href="#扩展">¶</a>扩展</h3>
<h4 id="异或前缀和"><a class="header-anchor" href="#异或前缀和">¶</a>异或前缀和</h4>
<p>若 $S[1] = A[1]$，$S[i] = S[i-1] \text{ xor } A[i]$，则称 $S$ 是 $A$ 的异或前缀和，有以下性质：</p>
<p>$$sum[l, r] = A[l] \text{ xor } A[l + 1] \dots \text{ xor } A[r] = S[r] \text{ xor } S[l - 1]$$</p>
<h4 id="二维-多维前缀和"><a class="header-anchor" href="#二维-多维前缀和">¶</a>二维/多维前缀和</h4>
<p>一维前缀和扩展到二维前缀和</p>
<p>若 $S[i][j] = \sum\limits^{i}_{p=1}\sum\limits^{j}_{q=1} A[p][q]$，则称 $S$ 是 $A$ 的二维前缀和，多维前缀和的普通求解方法几乎都是基于容斥原理，有以下性质：</p>
<p>递推公式：</p>
<p>$$S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j]$$</p>
<p>总矩阵中的任意一个子矩阵求和（容斥原理）：</p>
<p>$$sum[L_1, R_1, L_2, R_2] = S[L_2][R_2] - S[L_2][R_1] - S[L_1][R_2] + S[L_1][R_1]$$</p>
<div align=center><img width = '500' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/matrix_sum.PNG"/></div>
<h2 id="链表"><a class="header-anchor" href="#链表">¶</a>链表</h2>
<h3 id="定义-v2"><a class="header-anchor" href="#定义-v2">¶</a>定义</h3>
<p>每个链表中的节点都包含两个值，该节点的权值和指向下一个节点的指针（或者是下一个节点的地址）</p>
<div align=center><img width = '450' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/linked_list.PNG"/></div>
<h3 id="扩展-v2"><a class="header-anchor" href="#扩展-v2">¶</a>扩展</h3>
<p>邻接链表</p>
<p>如果邻接矩阵来存图，用 $a[i][j]$ 表示 $i$ 与 $j$ 连边的情况，空间的大小是 $N^2$（ $N$ 为图的点数），但是要存的边数可能是很少的，譬如稀疏图，于是可能会浪费很多的空间，那么我们可以用邻接链表来优化存图</p>
<div align=center><img width = '550' height ='330' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/yjw123456_4.png"/></div>
<p>邻接链表存图的核心思想是将读入的每一条边编号，并记录下从每个点出发的第一条边的编号，并且记录下每条边的“下一条边”的编号，这样一来，当我们需要遍历从一个点出发的所有边时，只需要从该点的第一条边开始，遍历完成后找到该边的“下一条边”继续遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;     <span class="comment">//这条边的终点</span></span><br><span class="line">    <span class="keyword">int</span> next;   <span class="comment">//这条边的下一条边</span></span><br><span class="line">    <span class="keyword">int</span> val;    <span class="comment">//这条边的权值</span></span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn]; <span class="comment">//head[i]表示i节点的第一条边的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].val = w;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;  <span class="comment">//链表从头部插入新元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈与队列"><a class="header-anchor" href="#栈与队列">¶</a>栈与队列</h2>
<h3 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h3>
<p>栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈，入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<p>性质：后进先出（last in first out）</p>
<div align=center><img width = '600' height ='600' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/stack.png"/></div>
<p>一个手写的栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ STL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.empty();      <span class="comment">//如果栈为空则返回true，否则返回false；</span></span><br><span class="line">s.size();       <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">s.top();        <span class="comment">//返回栈顶元素，但不删除该元素</span></span><br><span class="line">s.pop();        <span class="comment">//弹出栈顶元素，但不返回其值</span></span><br><span class="line">s.push();       <span class="comment">//将元素压入栈顶</span></span><br></pre></td></tr></table></figure>
<h4 id="括号匹配问题"><a class="header-anchor" href="#括号匹配问题">¶</a>括号匹配问题</h4>
<p>例题：判断一串括号序列是否合法<br>
思路：读取序列，若当前符号和栈顶符号匹配，则弹出栈顶，否则压入当前符号进栈</p>
<p>给定一个由 (、)、[、] 四种符号构成的字符串，判断其中的括号是否匹配。<br>
如果匹配，输出 “yes”，否则输出 “no”。<br>
Sample Input<br>
(()()[(())])<br>
[((]))<br>
Sample Output<br>
yes<br>
no</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(s)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; p;</span><br><span class="line">    p.push(<span class="string">'#'</span>);        <span class="comment">// 设置“哨兵”，防 RE </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];  <span class="comment">// string 的访问方式</span></span><br><span class="line">        <span class="comment">// 注意一次匹配失败即无需进行后面的判断，可以直接给出 false</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.top() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> p.pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.top() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> p.pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> p.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p.size() == <span class="number">1</span>);	<span class="comment">// 是否只剩“哨兵” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排队问题"><a class="header-anchor" href="#排队问题">¶</a>排队问题</h4>
<p>例题：</p>
<p>描述：有 n 个人站队，所有的人全部向右看，个子高的可以看到个子低的人发型（高个子会挡住低个子的视线，这里的身高大于是严格大于），给出每个人的身高，问所有人能看到其他人发型数量的总和是多少。<br>
输入：4 3 7 1<br>
输出：2<br>
解释：个子为 4 的可以看到个子为 3 的发型（因为被 7 挡住所以看不到 1），个子为 7 可以看到个子为 1 的身高，所以 1+1 = 2<br>
输入：3 4<br>
输出：0<br>
解释：3 看不到 4 的</p>
<p>思路：维护一个单调的栈</p>
<p>可以求每个人被看到的次数，即这个人向左单调递增的区间长度。</p>
<p>从左到右依次读取当前人的高度，从栈顶开始把高度小于或等于当前人的高度的那些元素删除，此时栈中剩下的元素的数量就是可以看见当前人的其他人的数量。</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/%E9%AB%98%E4%B8%AA%E5%AD%90%E9%97%AE%E9%A2%98.PNG"/></div>
<h3 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h3>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>性质：先进先出（first in first out）</p>
<div align=center><img width = '476' height ='302' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/ACM/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/queue_1.png"/></div>
<p>一个手写的队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head=<span class="number">0</span>, tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head&lt;tail)</span><br><span class="line">        <span class="keyword">return</span> q[head++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q[tail++]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成循环队列以优化空间复杂度</p>
<p>C++ STL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.empty();      <span class="comment">// 如果队列为空返回 true，否则返回false</span></span><br><span class="line">q.size();       <span class="comment">// 返回队列中元素的个数</span></span><br><span class="line">q.pop();        <span class="comment">// 删除队列首元素但不返回其值</span></span><br><span class="line">q.front();      <span class="comment">// 返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.push();       <span class="comment">// 在队尾压入新元素</span></span><br><span class="line">q.back();       <span class="comment">// 返回队尾元素的值，但不删除该元素</span></span><br></pre></td></tr></table></figure>
<p>队列的 BFS 搜索</p>
<p>Description：定义一个二维数组：</p>
<pre><code>int maze[5][5] = {
    0, 1, 0, 0, 0,
    0, 1, 0, 1, 0,
    0, 0, 0, 0, 0,
    0, 1, 1, 1, 0,
    0, 0, 0, 1, 0,
};
</code></pre>
<p>它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。<br>
Input<br>
一个 5 x 5 的二维数组，表示一个迷宫。数据保证有唯一解。<br>
Output<br>
左上角到右下角的最短路径。</p>
<p>思路：</p>
<p>一道比较简单的 BFS 搜索题目，在 BFS 过程中记得记录该节点的前驱</p>
<ol>
<li>将起点压入队列</li>
<li>取出队首元素 now，若 now 为终点则结束，<br>
否则从 now 向外扩展其他可行的点（若出界或者已经访问过或者是障碍物则不可行），<br>
将新点压入队列，返回第二步开始</li>
</ol>
<h3 id="双端队列"><a class="header-anchor" href="#双端队列">¶</a>双端队列</h3>
<p>即在队首和队尾都支持插入和删除操作的数据结构</p>
<h2 id="优先队列（堆）"><a class="header-anchor" href="#优先队列（堆）">¶</a>优先队列（堆）</h2>
<p>优先队列中，元素被赋予优先级。当访问元素时具有最高优先级的元素最先删除。优先队列具有最高级先出（first in, largest out）的行为特征。</p>
<p>top 访问队头元素<br>
empty 队列是否为空<br>
size 返回队列内元素个数<br>
push 插入元素到队尾（并排序）<br>
emplace 原地构造一个元素并插入队列<br>
pop 弹出队头元素</p>
<p>复杂度分析按堆来分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">// 降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure>
<p>自己写自己的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123; x = a; &#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x;     // 大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x;   // 大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br></pre></td></tr></table></figure>
<p>例题：</p>
<p>两个排好序的序列A、B（长度为 n，n 为 1e5），求前 n 大的 A[i]+B[j]，分别是多少？A、B 都是降序</p>
<p>思路：</p>
<p>使用一个优先队列，一开始先将 A 序列中最大的那个和 B 序列所有元素依次相加存进队列中，每次弹出最大的和组合（$A_i, B_j, A_i + B_j$）再新加入（$A_{i+1}, B_j, A_{i+1} + B_j$）<br>
但好像并不需要优先队列，用双指针遍历 n 次就能解决问题了</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>简单数论</title>
    <url>/2022/06/22/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=8" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/357573" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-简单数论</a> Password: easyshulun<br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>简单数论</h1>
<p>比较难，之后完善</p>
<h2 id="整除"><a class="header-anchor" href="#整除">¶</a>整除</h2>
<p><code>a % b == 0</code> 一般被我们写作 $b \mid a$</p>
<p>有若干性质：</p>
<ol>
<li>若 $a \mid b$，可知 $-a \mid b$，$a \ \mid-b$，$\left\vert a \right\vert \mid \left\vert b \right\vert$</li>
<li>若 $a \mid b$ 且 $b \mid c$，可知 $a \mid c$</li>
<li>若 $a \mid b$ 且 $a \mid c$，可知 $ a \mid (bx + cy) $，其中 $x$，$y$ 为任意整数</li>
<li>若 $a \mid b$，可知 $am \mid bm$，其中 $m$ 为非零整数</li>
<li>若 $a \mid b$，$b \mid a$，可知 $b=\pm a$，即 $\left\vert b \right\vert = \left\vert a \right\vert$</li>
<li>若 $a \mid bc$，且 $a$ 与 $c$ 互质，则 $a \mid b$</li>
<li>若 $a \mid b$，$a \mid c$，且 $b$ 与 $c$ 互质，则 $a \mid bc$</li>
<li>若 $a \mid b$，$c$ 为任意整数，则 $b \mid ac$</li>
<li>对任意整数 $a$，$b &gt; 0$，存在唯一的数对 $q$，$r$，使 $a = bq + r$，其中 $0 \le r &lt; b$，这个事实称为带余除法定理，是整除理论的基础</li>
<li>若 $c \mid a$，$c \mid b$，则称 $c$ 是 $a$，$b$ 的公因数。若 $d$ 是 $a$，$b$ 的公因数，$d \ge 0$，且 $d$ 可被 $a$，$b$ 的任意公因数整除，则 $d$ 是 $a$，$b$ 的最大公因数。若 $a$，$b$ 的最大公因数等于 $1$，则称 $a$，$b$ 互素，也称互质。累次利用带余除法可以求出 $a$，$b$ 的最大公因数，这种方法常称为辗转相除法。又称欧几里得算法。</li>
</ol>
<h2 id="模"><a class="header-anchor" href="#模">¶</a>模</h2>
<p>当 <code>a % b == c % b</code>，可以说 $a \equiv c \pmod{b}$</p>
<p>有很多优秀的性质</p>
<ol>
<li>取模运算：$a % p (a \bmod p)$，表示 $a$ 除以 $p$ 的余数。</li>
<li>模 $p$ 加法：$(a + b) % p = (a % p + b % p) % p$</li>
<li>模 $p$ 减法：$(a - b) % p = (a % p - b % p) % p$</li>
<li>模 $p$ 乘法：$(a * b) % p = ((a % p) * (b % p)) % p$</li>
<li>幂模 $p$：$(a^b) % p = ((a % p)^b) % p$</li>
<li>模运算满足结合律、交换律和分配律。</li>
<li>$a \equiv b \pmod{n}$ 表示 $a$ 和 $b$ 模 $n$ 同余，即 $a$ 和 $b$ 除以 $n$ 的余数相等。</li>
</ol>
<p>同余的性质</p>
<ol>
<li>反身性：$a \equiv a \pmod{m}$；</li>
<li>对称性：若 $a \equiv b \pmod{m}$，$b \equiv a \pmod{m}$；</li>
<li>传递性：若 $a \equiv b \pmod{m}$，$b \equiv c \pmod{m}$，则 $a \equiv c \pmod{m}$；</li>
<li>同余式相加：若 $a \equiv b \pmod{m}$，$c \equiv d \pmod{m}$，则 $a+c \equiv b+d \pmod{m}$；</li>
<li>同余式相乘：若 $a \equiv b \pmod{m}$，$c \equiv d \pmod{m}$，则 $a c \equiv b d \pmod{m}$。</li>
</ol>
<h2 id="一些常见定理"><a class="header-anchor" href="#一些常见定理">¶</a>一些常见定理</h2>
<p>欧拉定理</p>
<p>$\gcd(a,n) = 1$，则 $a^{\phi(n)} \equiv 1 \pmod{n}$</p>
<p>费马小定理</p>
<p>$p$ 为质数，$\gcd(a,p) = 1$，$a^{(p-1)} \equiv 1 \pmod{p}$</p>
<p>卢卡斯定理</p>
<p>威尔逊定理</p>
<h2 id="欧几里得定理"><a class="header-anchor" href="#欧几里得定理">¶</a>欧几里得定理</h2>
<p>$\gcd(a,b) = \gcd(b,a%b)$<br>
辗转相除，写递归<br>
另外<br>
$\operatorname{lcm}(m,n) * \gcd(a,b) == a*b$</p>
<p>Gcd=d, A=cd, B=ed, Lcm=ced, Lcm*Gcd=A*B</p>
<h2 id="扩展欧几里得算法"><a class="header-anchor" href="#扩展欧几里得算法">¶</a>扩展欧几里得算法</h2>
<ul>
<li>欧几里得算法（辗转相除）</li>
<li>反向递推 ax + by = gcd(a,b) = d 的解</li>
</ul>
<h2 id="逆元"><a class="header-anchor" href="#逆元">¶</a>逆元</h2>
<h2 id="中国剩余定理"><a class="header-anchor" href="#中国剩余定理">¶</a>中国剩余定理</h2>
<h2 id="素数"><a class="header-anchor" href="#素数">¶</a>素数</h2>
<h2 id="欧拉函数"><a class="header-anchor" href="#欧拉函数">¶</a>欧拉函数</h2>
<h2 id="唯一分解定理"><a class="header-anchor" href="#唯一分解定理">¶</a>唯一分解定理</h2>
<h2 id="一些算法"><a class="header-anchor" href="#一些算法">¶</a>一些算法</h2>
<ul>
<li>唯一分解定理 $O(\phi(n))$</li>
<li>阶乘质因数分解</li>
<li>Miller_Robin 素数检验 $O(s \log n)$</li>
<li>Pollard-rho 大数因式分解 $O(\text{sqrt} 4(n))$</li>
<li>mobius 反演</li>
<li>原根</li>
</ul>
<h2 id="扩充"><a class="header-anchor" href="#扩充">¶</a>扩充</h2>
<ul>
<li>
<p>哥德巴赫猜想</p>
</li>
<li>
<p>黎曼猜想</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数讲义摘要</title>
    <url>/2021/08/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E8%AE%B2%E4%B9%89%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>这是自学由 MIT 的 W.Gilbert Strang 教授开设的 18.06 Linear Algebra 课程时所作的笔记摘要<a id="more"></a></p>
<h2 id="Lecture-1"><a class="header-anchor" href="#Lecture-1">¶</a>Lecture 1</h2>
<blockquote>
<p>$n$ Linear equations, $n$ unknowns<br>
Row Picture<br>
Column Picture<br>
matrix form</p>
</blockquote>
<p>Row Picture</p>
<p>$2x - y = 0$<br>
$-x + 2y = 0$</p>
$
\begin{bmatrix}
2 & -1 \\
-1 & 2
\end{bmatrix}
\begin{bmatrix}
x \\ y
\end{bmatrix}
=\begin{bmatrix}
0 \\ 3
\end{bmatrix}
\Longrightarrow
\boldsymbol A \boldsymbol x = \boldsymbol b\\
$
<p>Matrix $\boldsymbol A$</p>
<p>Column Picture</p>
<p>linear combination of columns</p>
$
x\begin{bmatrix}
2 \\ -1
\end{bmatrix}
+
y\begin{bmatrix}
-1 \\ 2
\end{bmatrix}
=\begin{bmatrix}
0 \\ 3
\end{bmatrix}\\
$
$
1\begin{bmatrix}
2 \\ -1
\end{bmatrix}
+
2\begin{bmatrix}
-1 \\ 2
\end{bmatrix}
=\begin{bmatrix}
0 \\ 3
\end{bmatrix}\\
$
<p>$\boldsymbol A$ times $\boldsymbol x$ is a combination of the columns of $\boldsymbol A$</p>
$
x\begin{bmatrix}
2 \\ -1 \\ 0
\end{bmatrix}
+
y\begin{bmatrix}
-1 \\ 2 \\ -3
\end{bmatrix}
+
z\begin{bmatrix}
0 \\ -1 \\ 4
\end{bmatrix}
=\begin{bmatrix}
0 \\ -1 \\ 4
\end{bmatrix}\\
$
<p>$x = 0, y = 0, z = 1$</p>
<p>Can I solve $\boldsymbol A \boldsymbol x = \boldsymbol b$ for every right-hand side $\boldsymbol b$?<br>
Do the linear combinations of the columns fill three dimensional space?</p>
<p>singular case: the matrix would be invertible<br>
non-singular case: invertible and beautiful</p>
<h2 id="Lecture-2"><a class="header-anchor" href="#Lecture-2">¶</a>Lecture 2</h2>
<blockquote>
<p>Elimination Success or Failure<br>
Back-Substitution<br>
Elimination matrices<br>
Matrix multiplication</p>
</blockquote>
<h2 id="Lecture-3"><a class="header-anchor" href="#Lecture-3">¶</a>Lecture 3</h2>
<blockquote>
<p>Matrix multiplication<br>
Inverse of $\boldsymbol A$ $\boldsymbol A \boldsymbol B$ $\boldsymbol A^\mathrm{T}$<br>
Gauss-Jordan / find $\boldsymbol A^{-1}$</p>
</blockquote>
<h2 id="Lecture-4"><a class="header-anchor" href="#Lecture-4">¶</a>Lecture 4</h2>
<blockquote>
<p>Inverse of $\boldsymbol A \boldsymbol B$, $\boldsymbol A^\mathrm{T}$ (What’s the inverse of a product?)<br>
Product of elimination matrices<br>
$\boldsymbol A = \boldsymbol L \boldsymbol U$ (no row exchanges)</p>
</blockquote>
<h2 id="Lecture-5"><a class="header-anchor" href="#Lecture-5">¶</a>Lecture 5</h2>
<blockquote>
<p>$\boldsymbol P \boldsymbol A = \boldsymbol L \boldsymbol U$<br>
Permutation / Transposes<br>
Vector spaces<br>
and subspaces</p>
</blockquote>
<h2 id="Lecture-6"><a class="header-anchor" href="#Lecture-6">¶</a>Lecture 6</h2>
<blockquote>
<p>Vector spaces and Subspaces<br>
Column Space of $\boldsymbol A$<br>
Nullspace of $\boldsymbol A$<br>
: Solving $\boldsymbol A \boldsymbol x = \boldsymbol b$</p>
</blockquote>
<h2 id="Lecture-7"><a class="header-anchor" href="#Lecture-7">¶</a>Lecture 7</h2>
<blockquote>
<p>Computing the nullspace ( $\boldsymbol A \boldsymbol x = \boldsymbol 0$ )<br>
Pivot variables - free variables<br>
Special Solutions - $\text{rref }(\boldsymbol A) = \boldsymbol R$</p>
</blockquote>
<h2 id="Lecture-8"><a class="header-anchor" href="#Lecture-8">¶</a>Lecture 8</h2>
<blockquote>
<p>Complete solution of $\boldsymbol A \boldsymbol x = \boldsymbol b$<br>
Rank $r \ \ \ \ x = x_p + x_n$<br>
$r = m : $ solution exists<br>
$r = n : $ solution is unique</p>
</blockquote>
<h2 id="Lecture-9"><a class="header-anchor" href="#Lecture-9">¶</a>Lecture 9</h2>
<blockquote>
<p>Linear independence<br>
Spanning a space<br>
BASIS and dimension</p>
</blockquote>
<h2 id="Lecture-10"><a class="header-anchor" href="#Lecture-10">¶</a>Lecture 10</h2>
<blockquote>
<p>Four Fundamental Subspaces<br>
(for matrix $\boldsymbol A$)<br>
column space : $\text{C}(\boldsymbol A)$ in $\mathbb{R}^{m}$<br>
nullspace : $\text{N}(\boldsymbol A)$ in $\mathbb{R}^{n}$<br>
row space : = all combinations of rows = all combs of columns of $\boldsymbol A^\mathrm{T} = \text{C}(\boldsymbol A^\mathrm{T})$ in $\mathbb{R}^{n}$<br>
nullspace of $\boldsymbol A^\mathrm{T}$ : =  $\text{N}(\boldsymbol A^\mathrm{T})$ in $\mathbb{R}^{m}$</p>
</blockquote>
<h2 id="Lecture-11"><a class="header-anchor" href="#Lecture-11">¶</a>Lecture 11</h2>
<blockquote>
<p>Bases of new vector spaces<br>
Rank one matrices<br>
Small world graphs</p>
</blockquote>
<h2 id="Lecture-12"><a class="header-anchor" href="#Lecture-12">¶</a>Lecture 12</h2>
<blockquote>
<p>Graphs &amp; Networks<br>
Incidence Matrices<br>
Kirchhoff’s Laws</p>
</blockquote>
<h2 id="Lecture-13"><a class="header-anchor" href="#Lecture-13">¶</a>Lecture 13</h2>
<blockquote>
<p>Review for Exam 1<br>
Emphasizes Chapter 3</p>
</blockquote>
<h2 id="Lecture-14"><a class="header-anchor" href="#Lecture-14">¶</a>Lecture 14</h2>
<blockquote>
<p>Orthogonal vector &amp; Subspaces<br>
nullspace $\perp$ row space<br>
$\text{N}(\boldsymbol A^\mathrm{T} \boldsymbol A) = \text{N}(\boldsymbol A)$</p>
</blockquote>
<h2 id="Lecture-15"><a class="header-anchor" href="#Lecture-15">¶</a>Lecture 15</h2>
<blockquote>
<p>Projections!<br>
Least squares<br>
PROJECTION MATRIX</p>
</blockquote>
<h2 id="Lecture-16"><a class="header-anchor" href="#Lecture-16">¶</a>Lecture 16</h2>
<blockquote>
<p>Projections<br>
Least squares and<br>
best straight line</p>
</blockquote>
<h2 id="Lecture-17"><a class="header-anchor" href="#Lecture-17">¶</a>Lecture 17</h2>
<blockquote>
<p>Orthogonal basis $q_1, q_2, \cdots, q_n$<br>
Orthogonal matrix $\boldsymbol Q$ : square<br>
Gram-Schmidt $\boldsymbol A \to \boldsymbol Q$<br>
Orthonormal vectors $q^\mathrm{T}_i q_j = \begin{cases} 0 & \text{if } i \neq j, \\ 1 & \text{if } i = j.\end{cases}$</p>
</blockquote>
<h2 id="Lecture-18"><a class="header-anchor" href="#Lecture-18">¶</a>Lecture 18</h2>
<blockquote>
<p>Determinants $\text{det } \boldsymbol A$<br>
Properties 1,2,3,4-10<br>
$\pm$ signs</p>
</blockquote>
<h2 id="Lecture-19"><a class="header-anchor" href="#Lecture-19">¶</a>Lecture 19</h2>
<blockquote>
<p>Formula for $\text{det } \boldsymbol A$<br>
Cofactor furmula<br>
Tridiagonal matrices</p>
</blockquote>
<h2 id="Lecture-20"><a class="header-anchor" href="#Lecture-20">¶</a>Lecture 20</h2>
<blockquote>
<p>Formula for $\boldsymbol A^{-1}$<br>
Cramers Rule for $\boldsymbol x = \boldsymbol A^{-1} \boldsymbol b$<br>
$| \text{Det } \boldsymbol A|$ = Volume of box</p>
</blockquote>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法入门基础</title>
    <url>/2022/06/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=1" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
算法入门基础依据课程中的分节，一共分为十二篇总结笔记</p>
</blockquote>
<a id="more"></a>
<h2 id="算法入门基础"><a class="header-anchor" href="#算法入门基础">¶</a>算法入门基础</h2>
<p><a href="https://cloudplayer.top/2022/06/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">算法入门基础</a></p>
<p><a href="https://cloudplayer.top/2022/06/22/C++%E4%B8%8ESTL/" target="_blank" rel="noopener">C++ 与 STL</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E6%A8%A1%E6%8B%9F%E4%B8%8E%E6%9A%B4%E5%8A%9B/" target="_blank" rel="noopener">模拟与暴力</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">简单数据结构</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">字符串入门</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E8%B4%AA%E5%BF%83%E5%92%8C%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">贪心和排序</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP/" target="_blank" rel="noopener">动态规划DP</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E4%BA%8C%E5%88%86%E4%B8%89%E5%88%86%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" target="_blank" rel="noopener">二分三分快速幂矩阵快速幂</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA/" target="_blank" rel="noopener">简单数论</a><br>
<a href="https://cloudplayer.top/2022/06/22/DFS&amp;&amp;BFS&amp;&amp;%E5%9B%BE/" target="_blank" rel="noopener">DFS&amp;&amp;BFS&amp;&amp;图</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9C%80%E7%9F%AD%E8%B7%AF/" target="_blank" rel="noopener">拓扑排序与最短路</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" target="_blank" rel="noopener">并查集与最小生成树</a><br>
<a href="https://cloudplayer.top/2022/06/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/" target="_blank" rel="noopener">树状数组与线段树</a></p>
<h2 id="更新日志"><a class="header-anchor" href="#更新日志">¶</a>更新日志</h2>
<p>2022.07.18<br>
将入门的十二个单元基本整理出来了，但还是缺失很多内容，并且没有给出相关的题解<br>
这个系列的更新就先告一段落了，接下来的时间好好考研，二战上岸<br>
明年有机会再将这个系列进一步补全，加油</p>
<h2 id="部分资料与代码来源"><a class="header-anchor" href="#部分资料与代码来源">¶</a>部分资料与代码来源</h2>
<p>[1] 北京理工大学 ACM 冬季培训课程<br>
[2] 杭州电子科技大学 ACM 算法培训课程<br>
[3] 深入浅出程序设计竞赛 . 基础篇 / 汪楚奇编著 . 北京：高等教育出版社，2020.10<br>
[4] 高级数据结构：C++ 版 / 林厚从著 . 3 版 . 南京：东南大学出版社，2019.2<br>
[5] 算法竞赛入门经典 / 刘汝佳编著 . 2 版 . 北京：清华大学出版社，2014<br>
[6] 算法竞赛入门经典——习题与解答 / 陈锋编著 . 北京：清华大学出版社，2018<br>
[7] 算法竞赛入门经典——训练指南 / 刘汝佳，陈锋编著 . 北京：清华大学出版社，2012.10<br>
[8] 数据结构：C 语言版 / 严蔚敏，吴伟民编著 . 北京：清华大学出版社，1997.4<br>
[9] 算法导论</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>线性链表的 C 语言实现</title>
    <url>/2020/11/18/%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>无聊来水一水博客，代码内容如题<a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;                                           <span class="comment">// 数据域</span></span><br><span class="line">    LNode* next;                                        <span class="comment">// 指针域(指向结点的指针）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LNode* head;                                            <span class="comment">// 全局定义链表头指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_ListHead</span><span class="params">()</span>                                    <span class="comment">// 初始化链表头指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_List</span><span class="params">()</span>                                        <span class="comment">// 初始化单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    LNode* last = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please initialize a list\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The length of your list: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;data &lt; length &amp;&amp; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data) == <span class="number">1</span>) &#123;</span><br><span class="line">        LNode* Node = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;data == <span class="number">0</span>) head-&gt;next = Node;          <span class="comment">// 初始化 head 指针</span></span><br><span class="line">        last-&gt;next = Node;                              <span class="comment">// 将 Node 设为 last 的后继</span></span><br><span class="line">        Node-&gt;data = data;                              <span class="comment">// 初始化 Node 结点</span></span><br><span class="line">        Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        last = Node;                                    <span class="comment">// last 指针后移</span></span><br><span class="line">        head-&gt;data++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt_List</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> ( ; p != <span class="literal">NULL</span>; p = p-&gt;next)                     <span class="comment">// 顺序遍历</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t%d"</span>, p-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElem_List</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">    LNode* p = head-&gt;next; <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;                                <span class="comment">// 顺指针向后查找</span></span><br><span class="line">        p = p-&gt;next; ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) &#123;                                  <span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    element = p-&gt;data;                                  <span class="comment">// 取第 i 个元素</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_List</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;                            <span class="comment">// 寻找第 i-1 个结点</span></span><br><span class="line">        p = p-&gt;next; ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) &#123;                              <span class="comment">// i 小于 1 或者大于表长+1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* newNode = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">// 生成新结点</span></span><br><span class="line">    newNode-&gt;data = element;                            <span class="comment">// 插入 L 中</span></span><br><span class="line">    newNode-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = newNode;</span><br><span class="line">    head-&gt;data++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_List</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;                      <span class="comment">// 寻找第 i 个结点，并令 p 指向其前驱</span></span><br><span class="line">        p = p-&gt;next; ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(p-&gt;next) || j &gt; i - <span class="number">1</span>) &#123;                      <span class="comment">// 删除位置不合理</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode* q = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    q = p-&gt;next;                                        <span class="comment">// 删除并释放结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    head-&gt;data--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_List</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putElem_List</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> element)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    LNode* p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next; ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) &#123;                                  <span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ERROR!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data = element;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec_inv_prt_List</span><span class="params">(LNode* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rec_inv_prt_List(p-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t%d"</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv_prt_List</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) rec_inv_prt_List(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 函数声明 *****/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_ListHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init_List</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prt_List</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getElem_List</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_List</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_List</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear_List</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putElem_List</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rec_inv_prt_List</span><span class="params">(LNode * p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inv_prt_List</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 参数初始化 *****/</span></span><br><span class="line">    <span class="keyword">int</span> x, i;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">char</span> mode[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 初始化线性链表头指针 *****/</span></span><br><span class="line">    init_ListHead();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 初始化线性链表 *****/</span></span><br><span class="line">    init_List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please choose a mode:\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;mode);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"get"</span>) == <span class="number">0</span>) index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"len"</span>) == <span class="number">0</span>) index = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"ins"</span>) == <span class="number">0</span>) index = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"rem"</span>) == <span class="number">0</span>) index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"clr"</span>) == <span class="number">0</span>) index = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"put"</span>) == <span class="number">0</span>) index = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"pnt"</span>) == <span class="number">0</span>) index = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"rev"</span>) == <span class="number">0</span>) index = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"help"</span>) == <span class="number">0</span>) index = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(mode, <span class="string">"quit"</span>) == <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Wrong command!\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"You could type in the command \"help\"\n"</span>);</span><br><span class="line">            index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (index)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">/***** 退出 *****/</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">/***** 返回第 i 个数据元素的值 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get element at node i:\n"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">            value = getElem_List(i);</span><br><span class="line">            <span class="keyword">if</span>(value != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">/***** 求线性链表的表长 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"length: %d\n"</span>, head-&gt;data);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">/***** 在第i个节点处插入数据元素x *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"insert element x at node i: (type in i first)\n"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;i, &amp;x);</span><br><span class="line">            insert_List(i, x);</span><br><span class="line">            prt_List();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="comment">/***** 删除第i个节点 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"remove element at node i:\n"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">            remove_List(i);</span><br><span class="line">            prt_List();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="comment">/***** 将单链表重置为一个空表 *****/</span></span><br><span class="line">            clear_List();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Recreate the list? [Y/N](default N): "</span>);</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;flag);</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="string">'Y'</span>) init_List();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="comment">/***** 改变第i个数据元素的值 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"change the value of node i to x: (type in i first)\n"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;i, &amp;x);</span><br><span class="line">            putElem_List(i, x);</span><br><span class="line">            prt_List();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="comment">/***** 显示链表中的数据元素 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Output:"</span>);</span><br><span class="line">            prt_List();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="comment">/***** 逆序显示链表中的数据元素 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Reverse output:"</span>);</span><br><span class="line">            inv_prt_List();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="comment">/***** 帮助 *****/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"You could enter \"get\", \"len\", \"ins\", \"rem\", \"put\", \"clr\", \"pnt\" or \"rev\" to choose a mode or enter \"quit\" to end the program\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>被迫自学汇编语言</title>
    <url>/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>《汇编语言（第四版）》 . 王爽著 . 清华大学出版社 . 2019<a id="more"></a></p>
<h2 id="汇编语言实验合集"><a class="header-anchor" href="#汇编语言实验合集">¶</a>汇编语言实验合集</h2>
<p><a href="https://cloudplayer.top/2021/09/06/%E8%A2%AB%E8%BF%AB%E8%87%AA%E5%AD%A6%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">汇编语言实验合集</a></p>
<p><a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%80/" target="_blank" rel="noopener">实验 1 查看 CPU 和内存，用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%8C/" target="_blank" rel="noopener">实验 2 用机器指令和汇编指令编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%89/" target="_blank" rel="noopener">实验 3 编程、编译、连接、跟踪</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%9B%9B/" target="_blank" rel="noopener">实验 4 [bx] 和 loop 的使用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%BA%94/" target="_blank" rel="noopener">实验 5 编写、调试具有多个段的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AD/" target="_blank" rel="noopener">实验 6 实践课程中的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B8%83/" target="_blank" rel="noopener">实验 7 寻址方式在结构化数据访问中的应用</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%85%AB/" target="_blank" rel="noopener">实验 8 分析一个奇怪的程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E4%B9%9D/" target="_blank" rel="noopener">实验 9 根据材料编程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81/" target="_blank" rel="noopener">实验 10 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%B8%80/" target="_blank" rel="noopener">课程设计 1</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80/" target="_blank" rel="noopener">实验 11 编写子程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C/" target="_blank" rel="noopener">实验 12 编写 0 号中断的处理程序</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89/" target="_blank" rel="noopener">实验 13 编写、应用中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B/" target="_blank" rel="noopener">实验 14 访问 CMOS RAM</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94/" target="_blank" rel="noopener">实验 15 安装新的 int9 中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD/" target="_blank" rel="noopener">实验 16 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83/" target="_blank" rel="noopener">实验 17 编写包含多个功能子程序的中断例程</a><br>
<a href="https://cloudplayer.top/2021/09/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E4%BA%8C/" target="_blank" rel="noopener">课程设计 2</a></p>
<h2 id="Debug-工具"><a class="header-anchor" href="#Debug-工具">¶</a>Debug 工具</h2>
<p>Debug 是 DOS、Windows 都提供的实模式（8086 方式）程序的调试工具。使用它，可以查看 CPU 各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。</p>
<h3 id="Debug-功能"><a class="header-anchor" href="#Debug-功能">¶</a>Debug 功能</h3>
<p><strong>A 命令</strong>：将指令直接汇编成机器码输入到内存中，用于小段程序的汇编及修改目标程序，所有输入的数字均采用十六进制，用户装入内存的汇编语句是连续存放的，若没有指定地址，并且前面没有使用汇编命令，该语句被汇编到 <strong>CS:0100</strong> 区域；</p>
<p><strong>D 命令</strong>：查看内存中的内容，可以带参数也可省略参数，当省略参数时，命令 D 显示内容以 <strong>DS:0100</strong> 为起始，每次显示 128 个字节的内容。以后再执行不带参数的命令 D 时，Debug 将按上次的位置接着显示下去，带参数的方式有 <strong>d [起始位置]、d [起始位置] [结束位置]、d [起始位置] [L长度]</strong>。</p>
<p><strong>R 命令</strong>：查看、改变 CPU 寄存器的内容，当直接输入 r 时，Debug 将会显示出当前所有寄存器和标志位的状态，输入 <strong>r [寄存器]</strong> 可以改变 CPU 寄存器的内容；</p>
<p><strong>E 命令</strong>：改写内存中的内容，使用方式为：<strong>e [起始位置]</strong>，可修改当前字节的值，如果还要修改后续的内容，可以按空格键继续；</p>
<p><strong>U 命令</strong>：将内存中的机器指令翻译成汇编指令，使用方法是：<strong>e [范围]</strong>；</p>
<p><strong>T 命令</strong>：单步执行，每次只执行一条代码语句，遇到子程序后进入子程序逐条执行代码，可以理解为 step into，默认从 <strong>CS:IP</strong> 处开始运行；</p>
<p><strong>P 命令</strong>：类似 T 命令，不过遇到子程序调用的时候直接执行完子程序代码，不会进入子程序逐条执行，可以理解为 step over。另外，在遇到循环指令时，会直接执行到 <strong>CX=0</strong>。</p>
<p><strong>G 命令</strong>：该命令后面可以跟地址和断点，即格式为 <strong>g [=address] [breakpoints]</strong>，运行到内存指定位置的代码后暂停，如果不加参数默认是从当前 <strong>IP</strong> 运行到程序结束。</p>
<h3 id="标志寄存器在-Debug-中的表示"><a class="header-anchor" href="#标志寄存器在-Debug-中的表示">¶</a>标志寄存器在 Debug 中的表示</h3>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_0_1.PNG"/></div><br>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为 1 的标记</th>
<th>值为 0 的标记</th>
</tr>
</thead>
<tbody>
<tr>
<td>of</td>
<td>OV</td>
<td>NV</td>
</tr>
<tr>
<td>sf</td>
<td>NG</td>
<td>PL</td>
</tr>
<tr>
<td>zf</td>
<td>ZR</td>
<td>NZ</td>
</tr>
<tr>
<td>pf</td>
<td>PE</td>
<td>PO</td>
</tr>
<tr>
<td>cf</td>
<td>CY</td>
<td>NC</td>
</tr>
<tr>
<td>df</td>
<td>DN</td>
<td>UP</td>
</tr>
</tbody>
</table>
<p><br><div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C11/11_0_2.PNG"/></div></p>
<p><strong>CF：进位标志位</strong><br>
进行无符号数运算的时候，若存在运算结果的最高有效位向更高位的进位，或是从更高位借位，CF = 1，否则 CF = 0；<br>
<strong>OF：溢出标志位</strong><br>
进行有符号数运算的时候，结果超过了机器所能表示的范围（溢出），则 OF = 1，否则 OF = 0；<br>
<strong>DF：方向标志位</strong><br>
cld 指令将 DF 位置 0，si 与 di 递增，std 指令 将 DF 位置 1，si 与 di 递减；<br>
<strong>SF：符号标志位</strong><br>
相关指令执行后，若结果为负，SF = 1，若为非负，SF = 0；<br>
<strong>ZF：零标志位</strong><br>
相关指令执行后，若结果为 0，ZF = 1，若不为 0，ZF = 0；<br>
<strong>PF：奇偶标志位</strong><br>
相关指令执行后，若其结果的所有 bit 位中 1 的个数是为偶数，PF = 1，若为奇数 PF = 0；</p>
<p>这里的相关指令指 add，sub，mul，div，inc，or，and 等，它们大都是运算指令（进行逻辑或算术运算），不包括 mov，push，pop 等传送指令。</p>
<h2 id="8086-CPU-寄存器总结"><a class="header-anchor" href="#8086-CPU-寄存器总结">¶</a>8086 CPU 寄存器总结</h2>
<h3 id="基本介绍（引自百度）"><a class="header-anchor" href="#基本介绍（引自百度）">¶</a>基本介绍（引自百度）</h3>
<p>Intel 8086 拥有四个 16 位的通用寄存器，也能够当作八个 8 位寄存器来存取，以及四个 16 位索引寄存器（包含了堆栈指标）。资料寄存器通常由指令隐含地使用，针对暂存值需要复杂的寄存器配置。它提供 64K 8 位元的输出输入（或 32K 16 位元），以及固定的向量中断。大部分的指令只能够存取一个内存位址，所以其中一个操作数必须是一个寄存器。运算结果会储存在操作数中的一个寄存器。</p>
<p>Intel 8086 有四个内存区段（segment)寄存器，可以从索引寄存器来设定。区段寄存器可以让 CPU 利用特殊的方式存取 1 MB 内存。8086 把段地址左移 4 位然后把它加上偏移地址。大部分的人都认为这是一个很不好的设计，因为这样的结果是会让各分段有重叠。尽管这样对组合语言而言大部分被接受（也甚至有用），可以完全地控制分段，使在编程中使用指针（如C编程语言） 变得困难。它导致指针的高效率表示变得困难，且有可能产生两个指向同一个地方的指针拥有不同的地址。更坏的是，这种方式产生要让内存扩充到大于 1 MB 的困难。而 8086 的寻址方式改变让内存扩充较有效率。</p>
<p>8086 处理器的时钟频率介于 4.77MHz（在原先的IBM PC频率）和 10 MHz之间。8086 没有包含浮点指令部分（FPU），但是可以通过外接数学辅助处理器来增强浮点计算能力。Intel 8087 是标准版本。</p>
<h3 id="寄存器介绍"><a class="header-anchor" href="#寄存器介绍">¶</a>寄存器介绍</h3>
<p>8086 拥有 4 个段寄存器，分别是：</p>
<ol>
<li>CS(code segment)：16位的代码段寄存器；</li>
<li>DS(data segment)：16位的数据段寄存器；</li>
<li>ES(extra segment)：16位的扩展段寄存器；</li>
<li>SS(stack segment)：16位的堆栈段寄存器；</li>
</ol>
<p>8086 通过 CS 与 16 位的指令指针寄存器 IP 一起来指示 CPU 当前要读取指令的地址(CS:IP)，于是可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。</p>
<p>8086 还拥有 8 个通用寄存器：即 AX、BX、CX、DX、BP、SP、SI、DI，其中：</p>
<ol>
<li>4 个数据寄存器：AX、BX、CX、DX；</li>
<li>2 个地址指针寄存器：BP(base pointer)、SP(stack pointer)；</li>
<li>2 个变址寄存器：SI(source index)、DI(destination index)。</li>
</ol>
<p>4 个数据寄存器也能够当作 8 个 8 位寄存器来存取，即 AL、AH、BL、BH、CL、CH、DL、DH。</p>
<p>AX、DX 在使用 div 指令和 mul 指令时，总是 DX 为高 16 位，AX 为低 16 位，两者可以表示一个 32 位的双字型数据。</p>
<p>CX 默认为 loop 指令的循环计数器。</p>
<p>在以栈的方式访问内存空间时，通常将栈顶的段地址存放在段寄存器 SS 中，偏移地址存放在 SP 中，使得任意时刻，SS:SP 指向栈顶元素。</p>
<p>标志寄存器 FR(flags register)，共 16 位，其中存储的信息通常被称为程序状态字(PSW)，用来存储相关指令的某些执行结果、为 CPU 执行相关指令提供行为依据、控制 CPU 的相关工作方式。</p>
<h3 id="寻址方式"><a class="header-anchor" href="#寻址方式">¶</a>寻址方式</h3>
<p>8086 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址，<br>
即：<strong>物理地址=段地址×16+偏移地址</strong>。</p>
<p>存放段地址的寄存器可以是默认的(DS)，也可以显性给出。</p>
<p>给定内存单元偏移地址定位内存单元的方法被称为寻址方式。</p>
<p><br><div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C7/7_0_1.PNG"/></div></p>
<h2 id="指令系统总结"><a class="header-anchor" href="#指令系统总结">¶</a>指令系统总结</h2>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_0_1.PNG"/></div>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%AE%9E%E9%AA%8C15/15_0_2.PNG"/></div>
<hr>
<h2 id="参考博文"><a class="header-anchor" href="#参考博文">¶</a>参考博文</h2>
<p>以下也包括做实验时参考过的一些文章和视频</p>
<p><a href="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89%E7%AD%94%E6%A1%88.pdf" target="_blank" rel="noopener">汇编语言答案 / HK_Mayfly</a></p>
<p><a href="https://blog.csdn.net/OrangeHap/article/details/89790492" target="_blank" rel="noopener">CSDN: OrangeHap / 汇编语言（第三版）实验</a></p>
<p><a href="https://blog.csdn.net/shaco_?type=blog" target="_blank" rel="noopener">CSDN: shaco_的博客</a></p>
<p><a href="https://blog.csdn.net/qq_39654127/article/details/88698911" target="_blank" rel="noopener">CSDN: 洋葱汪 / 王爽《汇编语言》笔记（详细）</a></p>
<p><a href="https://blog.csdn.net/sxhelijian/article/details/69338661" target="_blank" rel="noopener">CSDN: 迂者-贺利坚 / no stack segment警告为何还在？</a></p>
<p><a href="https://blog.csdn.net/sxhelijian/article/details/109397338" target="_blank" rel="noopener">CSDN: 迂者-贺利坚 / 调整DOSBox的窗口大小：跨过三连坑</a></p>
<p><a href="https://blog.csdn.net/shidan77/article/details/84443358" target="_blank" rel="noopener">CSDN: shidan77 / DEBUG 中T、P、G命令的用法与区别</a></p>
<p><a href="https://www.cnblogs.com/xinyugarden/p/11993388.html" target="_blank" rel="noopener">CSDN: _毛豆豆 / Debug命令详解</a></p>
<p><a href="https://www.bilibili.com/video/BV1mt411R7Xv?p=1" target="_blank" rel="noopener">bilibili: 紫狐遗梦 / 汇编语言从0开始 重制版</a></p>
<p><a href="https://baike.baidu.com/item/8086/7716347?fr=aladdin" target="_blank" rel="noopener">百度百科: 8086</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心和排序</title>
    <url>/2022/06/22/%E8%B4%AA%E5%BF%83%E5%92%8C%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>b站视频链接：<a href="https://www.bilibili.com/video/BV1pE411E7RV?p=5" target="_blank" rel="noopener">北京理工大学ACM冬季培训课程</a><br>
<a href="https://vjudge.net/contest/356986" target="_blank" rel="noopener">课程刷题地址 2020BIT冬训-贪心</a><br>
本篇博文为看视频学习时的记录与自己的一些总结</p>
</blockquote>
<a id="more"></a>
<h1>贪心和排序</h1>
<h2 id="贪心"><a class="header-anchor" href="#贪心">¶</a>贪心</h2>
<h3 id="啥是贪心"><a class="header-anchor" href="#啥是贪心">¶</a>啥是贪心</h3>
<blockquote>
<ul>
<li>不严格的定义：</li>
<li>诶这题咋做啊</li>
<li>诶这xb搞搞好像很对很有道理啊</li>
<li>诶这题过了（蜜汁表情）</li>
</ul>
</blockquote>
<h3 id="贪心是啥"><a class="header-anchor" href="#贪心是啥">¶</a>贪心是啥</h3>
<blockquote>
<ul>
<li>严格（？）的定义：</li>
<li>在对问题求解时，总是做出在当前看来是最好的选择。</li>
<li>也就是说，</li>
<li>不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解</li>
</ul>
</blockquote>
<h3 id="luoguP1181数列分段-Section-I"><a class="header-anchor" href="#luoguP1181数列分段-Section-I">¶</a><a href="https://www.luogu.com.cn/problem/P1181" target="_blank" rel="noopener">luoguP1181数列分段 Section I</a></h3>
<blockquote>
<p><strong>题目描述</strong><br>
对于给定的一个长度为 $N$ 的正整数数列 $A_i$ ，现要将其分成连续的若干段，并且每段和不超过 $M$ （可以等于 $M$ ），问最少能将其分成多少段使得满足要求。<br>
<strong>输入格式</strong><br>
第 $1$ 行包含两个正整数 $N,M$，表示了数列 $A_i$ 的长度与每段和的最大值，第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$ ，如题目所述。<br>
<strong>输出格式</strong><br>
一个正整数，输出最少划分的段数。<br>
<strong>说明：</strong>$N \le 1e5，M \le 1e9$<br>
<strong>分析：</strong><br>
  入门题<br>
  对于每一段，不断的加入数直到和超过M<br>
  时间复杂度 $O(n)$</p>
</blockquote>
<p><strong>题解：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//这个是一开始写的，直接就TLE了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, num, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        a.push_back(num);</span><br><span class="line">        <span class="keyword">if</span> (accumulate(a.begin(), a.end(), <span class="number">0</span>) &gt; m) &#123;</span><br><span class="line">            a.clear();</span><br><span class="line">            a.push_back(num);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//这才是AC代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, num, sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        a.push_back(num);</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; m) &#123;</span><br><span class="line">            a.clear();</span><br><span class="line">            a.push_back(num);</span><br><span class="line">            sum = num;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="贪心的注意事项"><a class="header-anchor" href="#贪心的注意事项">¶</a>贪心的注意事项</h3>
<blockquote>
<ul>
<li>优点</li>
<li>一般非常好想</li>
<li>分支比较少，复杂度低</li>
</ul>
</blockquote>
<br>
<blockquote>
<ul>
<li>缺点</li>
<li>不一定对，要求保证贪心结果无后效性</li>
</ul>
</blockquote>
<h3 id="一般贪心题套路"><a class="header-anchor" href="#一般贪心题套路">¶</a>一般贪心题套路</h3>
<blockquote>
<ul>
<li>贪心 + 排序</li>
<li>贪心 + 二分</li>
</ul>
</blockquote>
<h3 id="luoguP1090合并果子"><a class="header-anchor" href="#luoguP1090合并果子">¶</a><a href="https://www.luogu.com.cn/problem/P1090" target="_blank" rel="noopener">luoguP1090合并果子</a></h3>
<blockquote>
<p><strong>题目描述</strong><br>
在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。<br>
每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。<br>
因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。<br>
例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。<br>
<strong>输入格式</strong><br>
共两行。<br>
第一行是一个整数 $n(1\le n\le 10000)$ ，表示果子的种类数。<br>
第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\le a_i\le 20000)$ 是第 $i$ 种果子的数目。<br>
<strong>输出格式</strong><br>
一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。<br>
<strong>分析：</strong><br>
  普及题<br>
  每次合并最小两堆，用优先队列维护<br>
  Huffman编码</p>
</blockquote>
<p><strong>题解：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//这是讲这一讲的学长现场写的</span></span><br><span class="line"><span class="keyword">int</span> m, n, i, j, ans;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        q.push(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> p2 = q.top(); q.pop();</span><br><span class="line">        ans += p1 + p2; q.push(p1 + p2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附优先队列用法示例（<strong>C++ reference</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        q.push(n);</span><br><span class="line"></span><br><span class="line">    print_queue(q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        q2.push(n);</span><br><span class="line"></span><br><span class="line">    print_queue(q2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using lambda to compare elements.</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123; <span class="keyword">return</span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>); &#125;;</span><br><span class="line">    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q3(cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        q3.push(n);</span><br><span class="line"></span><br><span class="line">    print_queue(q3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment">0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">8 9 6 7 4 5 2 3 0 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="luoguP1182数列分段-Section-II"><a class="header-anchor" href="#luoguP1182数列分段-Section-II">¶</a><a href="https://www.luogu.com.cn/problem/P1182" target="_blank" rel="noopener">luoguP1182数列分段 Section II</a></h3>
<blockquote>
<p><strong>题目描述</strong><br>
对于给定的一个长度为 $N$ 的正整数数列 $A_{1\sim N}$ ，现要将其分成 $M（M\leq N）$ 段，并要求每段连续，且每段和的最大值最小。<br>
关于最大值最小：<br>
例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。<br>
将其如下分段：<br>
$[4\ 2][4\ 5][1]$<br>
第 $1$ 段和为 $6$ ，第 $2$ 段和为 $9$ ，第 $3$ 段和为 $1$ ，和最大值为 $9$ 。<br>
将其如下分段：<br>
$[4][2\ 4][5\ 1]$<br>
第 $1$ 段和为 $4$ ，第 $2$ 段和为 $6$ ，第 $3$ 段和为 $6$ ，和最大值为 $6$ 。<br>
并且无论如何分段，最大值不会小于 $6$。<br>
所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$ 。<br>
<strong>输入格式</strong><br>
第 $1$ 行包含两个正整数 $N,M$ 。<br>
第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$ ，含义如题目所述。<br>
<strong>输出格式</strong><br>
一个正整数，即每段和最大值最小为多少。<br>
<strong>说明：</strong> $1\leq N\leq 10^5 ，M\leq N，A_i &lt; 10^8$ ， 答案不超过 $10^9$<br>
<strong>分析：</strong><br>
  普及题<br>
  二分M，每次贪心验证是否可行<br>
  时间复杂度 $O(n\log n)$</p>
</blockquote>
<p><strong>题解：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> i, j, m, n, l, r = <span class="number">0</span>, sum, k, mid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        r += a[i];                  <span class="comment">//r为上界</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; a[i]) l = a[i];     <span class="comment">//l为下界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)                  <span class="comment">//二分</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        k = <span class="number">1</span>; sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + a[i] &gt; mid) &#123; sum = a[i]; k++; &#125;</span><br><span class="line">            <span class="keyword">else</span> sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= m) &#123; r = mid - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意用二分法的下界为这组数中最大的那个的值<br>
学长 <code>while</code> 语句中写的是 <code>(l &lt; r)</code><br>
个人觉得应改为 <code>while (l &lt;= r)</code><br>
两个都能AC，但使用题目描述中的例子会发现用 <code>(l &lt; r)</code> 的会输出 $7$<br>
还有别忘了变量 $r$ 的初始化</p>
<hr>
<h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2>
<h3 id="sort"><a class="header-anchor" href="#sort">¶</a>sort</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(first_pointer, first_pointer + n, cmp);</span><br></pre></td></tr></table></figure>
<p>在之前的C++STL中已讲到：<a href="https://cloudplayer99.github.io/2020/04/15/C++%E4%B8%8EC++STL/#4-4-1-sort">C++STL：sort</a></p>
<h3 id="结构体sort"><a class="header-anchor" href="#结构体sort">¶</a>结构体sort</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;stu[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(student p, student q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.score &gt; q.score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(stu+<span class="number">1</span>, stu+<span class="number">1</span>+n, cmp);</span><br></pre></td></tr></table></figure>
<h3 id="STL的排序方法"><a class="header-anchor" href="#STL的排序方法">¶</a>STL的排序方法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span></span><br><span class="line">sort(v.begin(), v.end(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span> <span class="built_in">stack</span></span><br><span class="line">不能排序</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line">本来就有序</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span></span><br><span class="line">不需要排序</span><br><span class="line"></span><br><span class="line">priority_queue</span><br><span class="line">push后自然有序</span><br></pre></td></tr></table></figure>
<h3 id="另外"><a class="header-anchor" href="#另外">¶</a>另外</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nth_element(a+l, a+k, a+r);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>使得 a 中 [l, r) 区间的第k小处于第k位，不保证其他位置有序</li>
<li>时间复杂度 $O(n)$</li>
</ul>
</blockquote>
<br>
<blockquote>
<ul>
<li><s>主要用途：过2020蓝桥杯选拔H题</s></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++设计模式速成笔记</title>
    <url>/2023/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>学习资源：<br>
<a href="https://www.subingwen.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式 | 爱编程的大丙</a><br>
<a href="https://refactoringguru.cn/design-patterns/" target="_blank" rel="noopener">Refactoring.Guru 设计模式</a></p>
</blockquote>
<a id="more"></a>
<ul>
<li>C++设计模式速成笔记
<ul>
<li>预备知识</li>
<li>设计模式三原则</li>
<li>设计模式一览</li>
<li>创建型模式
<ul>
<li>工厂方法模式 Factory Method</li>
<li>抽象工厂模式 Abstract Factory</li>
<li>单例模式 Singleton</li>
<li>原型模式 Prototype</li>
</ul>
</li>
<li>结构型模式
<ul>
<li>享元模式 Flyweight</li>
</ul>
</li>
<li>行为模式
<ul>
<li>命令模式 Command</li>
<li>策略模式 Strategy</li>
<li>状态模式 State</li>
<li>观察者模式 Observer</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>C++设计模式速成笔记</h1>
<h2 id="预备知识"><a class="header-anchor" href="#预备知识">¶</a>预备知识</h2>
<p>什么是设计模式：三大类 二十七种</p>
<p>创建型模式：这类模式提供创建对象的机制，能够提升已有代码的灵活性和可复用性<br>
结构型模式：这类模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效<br>
行为模式：这类模式负责对象间的高效沟通和职责委派</p>
<p>面向对象语言：封装 继承 多态<br>
大象装冰箱 面对过程 面向对象 对象即类的实例<br>
封装：把一些属性（成员变量）与行为（成员函数）封装到一个类<br>
继承：子类继承父类（公共或受保护的成员变量和成员属性，即非私有的）<br>
多态：同名函数具有不同的状态：<br>
需要发生继承，父类定义虚函数，子类重写父类的虚函数，父类的指针或引用指向子类对象并通过其调用子类从父类继承来的虚函数（概念：纯虚函数，抽象类）</p>
<p>UML类图 unified modeling meeting<br>
通过UML把对应的类的结构描述出来<br>
把类与类之间的关系清晰的表述出来：继承、关联、聚合、组合、依赖</p>
<p>描述类结构</p>
<p>可见性：+ public # protected - private _ static（用加下划线的方式表示static）<br>
属性：【可见性】【属性名称】:【类型】=【缺省值，可选】<br>
- m_gunName:string = “AK-47”<br>
方法：【可见性】【方法名称】(【参数名:参数类型, …】):【返回值类型】<br>
- shoot():void<br>
注：抽象类，类名用斜体，虚函数跟随类名也使用斜体，纯虚函数最后给函数指定 =0</p>
<p>描述类关系</p>
<ul>
<li>继承（泛化Generalization）：带空心三角形的实线</li>
</ul>
<div align=center><img width = '400' height = '250' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Generalization.PNG"/></div>
<ul>
<li>关联Assocition（例如将一个类的对象作为另一个类的成员变量）：
<ul>
<li>单向关联：带单向箭头的实线</li>
<li>双向关联：带双向箭头的实线</li>
<li>自关联（当前类中包含一个自身类型的对象成员，例如链表）：箭头指向自己的实线</li>
<li>关联平等，聚合不平等</li>
</ul>
</li>
</ul>
<div align=center><img width = '536' height = '214' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Assocition.PNG"/></div>
<ul>
<li>聚合Aggregation（整体与部分，成员对象是整体的一部分，且可以脱离整体对象独立存在）
<ul>
<li>代码实现聚合关系，成员对象通常以构造方法、Setter 方法的方式注入到整体对象之中</li>
<li>带空心菱形的实线</li>
</ul>
</li>
</ul>
<div align=center><img width = '432' height = '255' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Aggregation.PNG"/></div>
<ul>
<li>组合Composition（整体与部分，整体对象控制成员对象的生命周期，同生共死）
<ul>
<li>代码实现组合关系，通常在整体类的构造方法中直接实例化成员类，整体对象析构其子对象一并析构</li>
<li>带实心菱形的实线</li>
</ul>
</li>
</ul>
<div align=center><img width = '416' height = '252' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Composition.PNG"/></div>
<ul>
<li>依赖Dependency（使用）：带箭头的虚线
<ul>
<li>将一个类的对象作为另一个类中方法的参数</li>
<li>在一个类的方法中将另一个类的对象作为其对象的局部变量</li>
<li>在一个类的方法中调用另一个类的静态方法</li>
</ul>
</li>
</ul>
<div align=center><img width = '442' height = '260' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Dependency.PNG"/></div>
<h2 id="设计模式三原则"><a class="header-anchor" href="#设计模式三原则">¶</a>设计模式三原则</h2>
<ul>
<li>单一职责原则
<ul>
<li>对一个类而言，应该仅有一个引起它变化的原因，其实就是将这个类所承担的职责单一化（解耦合）</li>
</ul>
</li>
<li>开放封闭原则
<ul>
<li>软件实体（类、模块、函数等）可以扩展，但是不可以修改，即对于扩展是开放的，对于修改是封闭的，其实就是实现多态，创建新的子类并重写父类虚函数，用以更新处理动作</li>
</ul>
</li>
<li>依赖倒转原则
<ul>
<li>高层模块不应该依赖低层模块，两个都应该依赖抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
</ul>
</li>
</ul>
<p>关于依赖倒转原则</p>
<p>高层模块：可以理解为上层应用，就是业务层的实现<br>
低层模块：可以理解为底层接口，比如封装好的 API、动态库等<br>
抽象：指的就是抽象类或者接口，在 C++ 中没有接口，只有抽象类<br>
如果高层模块依赖低层模块，当依赖的低层模块改变，高层代码也要进行对应的修改，无法实现对高层代码的直接复用</p>
<p>里氏代换原则：子类类型必须能够替换掉它们的父类类型<br>
需满足：1. 继承 2. 子类继承的所有父类的属性和方法对于子类来说都是合理的<br>
条件满足后，在实际应用中就可以使用子类替换掉父类，同时功能也不会受到影响，父类实现了复用，子类也能在父类的基础上增加新的行为，这个就是里氏代换原则</p>
<p>抽象不应该依赖细节，细节应该依赖抽象。也就意味着我们应该对细节进行封装，在 C++ 中就是将其放到一个抽象类中（C++ 中没有接口，不能像 Java 一样封装成接口）</p>
<ul>
<li>
<p>抽象类中提供的接口是固定不变的</p>
</li>
<li>
<p>低层模块是抽象类的子类，继承了抽象类的接口，并且可以重写这些接口的行为</p>
</li>
<li>
<p>高层模块想要实现某些功能，调用的是抽象类中的函数接口，并且是通过抽象类的父类指针引用其子类的实例对象（用子类类型替换父类类型），这样就实现了多态</p>
</li>
</ul>
<div align=center><img width = '600' height = '250' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3or%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8.PNG"/></div>
<h2 id="设计模式一览"><a class="header-anchor" href="#设计模式一览">¶</a>设计模式一览</h2>
<div align=center><img width = '862' height = '495' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E8%A7%88.PNG"/></div>
<h2 id="创建型模式"><a class="header-anchor" href="#创建型模式">¶</a>创建型模式</h2>
<h3 id="工厂方法模式-Factory-Method"><a class="header-anchor" href="#工厂方法模式-Factory-Method">¶</a>工厂方法模式 Factory Method</h3>
<p>工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型</p>
<p>它的别称 <strong>虚拟构造函数</strong>（Virtual Constructor）很好的描述了它的实质，即使用特殊的工厂方法代替对于对象构造函数的直接调用，工厂方法返回的对象即为“产品”</p>
<p>简单工厂模式与工厂模式的不同在于其只使用一个工厂类来生产许多不同的产品对象，这种方式违反了设计模式中的开放—封闭原则，在工厂模式中，用一个基类包含一个虚工厂函数用于实现多态，再用多个子类重写父类的工厂函数</p>
<div align=center><img width = '931' height = '555' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.PNG"/></div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Product() &#123;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    Virtual ~Creator() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorA</span> :</span> <span class="keyword">public</span> Creator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">    ~ConcreteCreatorA() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreatorB</span> :</span> <span class="keyword">public</span> Creator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Product* <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">    ~ConcreteCreatorB() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Creator* factory = <span class="keyword">new</span> ConcreteCreatorA;</span><br><span class="line">    Product* obj = factory-&gt;createProduct();</span><br><span class="line">    obj-&gt;doStuff();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式-Abstract-Factory"><a class="header-anchor" href="#抽象工厂模式-Abstract-Factory">¶</a>抽象工厂模式 Abstract Factory</h3>
<p>抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类</p>
<p>什么是 <strong>系列对象</strong>？ 例如有这样一组的对象： ​ 运输工具外壳 + 运动引擎 + 控制系统，它可能会有几个变体：</p>
<p>汽车钢板外壳 + 内燃机 + 方向盘离合油门刹车（汽车控制系统）<br>
飞机钛合金外壳 + 喷气式发动机 + 操纵杆（飞机控制系统）</p>
<p>另一个例子：使用现代Modern、维多利亚Victorian、装饰风艺术Art­Deco等风格生成不同的椅子、沙发和咖啡桌</p>
<p>抽象工厂模式给一系列功能相同但是属性会发生变化的组件添加一个抽象类，这样就可以非常方便地进行后续的拓展，再搭配工厂类就可以创建出我们需要的对象了</p>
<p>工厂模式创建的对象对应的类不需要提供抽象类，而抽象工厂模式创建的对象对应的类有抽象的基类，其对应的产品类组件中有可变因素</p>
<p>如果抽象工厂模式创建的一系列相关对象需要组装成一个整体，可以定义整体类，然后直接在具体工厂中组装出来</p>
<div align=center><img width = '877' height = '562' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.PNG"/></div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProductA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fuction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractProductA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA1</span> :</span> <span class="keyword">public</span> AbstractProductA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuction</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ProductA1 do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA2</span> :</span> <span class="keyword">public</span> AbstractProductA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fuction</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ProductA2 do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductB</span></span><br><span class="line"><span class="comment">// as same as ProductA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractFactory</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductA* <span class="title">createProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ProductB* <span class="title">createProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~AbstractFactory() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteFactory1</span></span><br><span class="line"><span class="comment">// create ProductA1 and ProductB1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> :</span> <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ProductA* <span class="title">createProductA</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ProductB* <span class="title">createProductB</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteFactory2</span></span><br><span class="line"><span class="comment">// create ProductA2 and ProductB2</span></span><br><span class="line"><span class="comment">// as same as ConcreteFactory1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Client</span>(AbstractFactory f) : factory(f) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">someOption</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractFactory factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单例模式-Singleton"><a class="header-anchor" href="#单例模式-Singleton">¶</a>单例模式 Singleton</h3>
<p>单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并为该实例提供一个全局访问节点，单例模式同时解决了两个问题，所以违反了单一职责原则</p>
<p>要保证一个类的实例有且仅有一个，就必须采取一些防护措施，涉及一个类多对象操作的函数有以下几个：</p>
<ul>
<li>构造函数：创建一个新的对象</li>
<li>拷贝构造函数：根据已有对象拷贝出一个新的对象</li>
<li>拷贝赋值操作符重载函数：两个对象之间的赋值</li>
</ul>
<p>作以下处理：</p>
<ul>
<li>构造函数私有化，防止其他对象使用单例类的 new 运算符，<br>
构造函数在类内部只调用一次
<ul>
<li>由于使用者在类外部不能使用构造函数，所以在类内部创建的这个唯一的对象必须是 <strong>静态的</strong>，这样就可以通过类名来访问了，为了不破坏类的封装，将这个静态对象的访问权限设置为 <strong>私有的</strong></li>
<li>在类中只有它的静态成员函数才能访问其静态成员变量，所以可以给这个单例类提供一个静态函数用于得到这个静态的单例对象，该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在这个静态成员变量中，此后所有对于该函数的调用都将返回这一缓存对象</li>
</ul>
</li>
<li>拷贝构造函数私有化或者禁用</li>
<li>拷贝赋值操作符重载函数私有化或者禁用</li>
</ul>
<div align=center><img width = '630' height = '385' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.PNG"/></div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例模式的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用，也可以将其访问权限设置为私有</span></span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原型模式-Prototype"><a class="header-anchor" href="#原型模式-Prototype">¶</a>原型模式 Prototype</h3>
<p>原型模式是一种创建型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类</p>
<p>原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。通常情况下，这样的接口中仅包含一个克隆方法</p>
<p>注：拷贝构造函数的局限：克隆可能会在父类和子类之间进行，并且可能是动态的，很明显通过父类的拷贝构造函数无法实现对子类对象的拷贝</p>
<div align=center><img width = '795' height = '492' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.PNG"/></div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Prototype() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Prototype() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Prototype* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> :</span> <span class="keyword">public</span> Prototype &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcretePrototype() &#123;&#125;</span><br><span class="line">    <span class="function">Prototype* <span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构型模式"><a class="header-anchor" href="#结构型模式">¶</a>结构型模式</h2>
<h3 id="享元模式-Flyweight"><a class="header-anchor" href="#享元模式-Flyweight">¶</a>享元模式 Flyweight</h3>
<p>享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象</p>
<p>对象的常量数据通常被称为 <strong>内在状态</strong>，其位于对象中，其他对象只能读取但不能修改其数值。而对象的其他状态常常能被其他对象“从外部”改变，因此被称为 <strong>外在状态</strong>。例：射击游戏的粒子Particle类中子弹的颜色和精灵图sprite都一样，为其内在状态（其实也是消耗内存最多的成员变量，所以为了节约内存容量，对其进行复用而不是重复存储），但它的另一些状态（坐标、移动矢量和速度）的数值不断变化，为其外在状态</p>
<p>享元模式建议不在对象中存储外在状态，而是将其传递给依赖于它的一个特殊方法，程序只在对象中保存内在状态，以便复用， 这些对象的区别仅在于其内在状态，与外在状态相比，内在状态的变体要少很多，于是对象数量会大大削减，将仅存储内在状态的对象称为 <strong>享元</strong>，须确保其状态不能被修改（享元类的状态只能由构造函数的参数进行一次性初始化，不能对其他对象公开其设置器或公有成员变量），而外在状态会被移动到容器对象中，也就是我们应用享元模式前的聚合对象中，或者创建独立的情景类来存储外在状态和对享元对象的引用</p>
<p>为了能更方便地访问各种享元，你可以创建一个工厂方法来管理已有享元对象的缓存池。工厂方法从客户端处接收目标享元对象的内在状态作为参数，如果它能在缓存池中找到所需享元，则将其返回给客户端；如果没有找到，它就会新建一个享元，并将其添加到缓存池中</p>
<p>可以选择在程序的不同地方放入该函数。最简单的选择就是将其放置在享元容器中。除此之外，还可以新建一个工厂类，或者创建一个静态的工厂方法并将其放入实际的享元类中</p>
<div align=center><img width = '879' height = '622' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.PNG"/></div>
<h2 id="行为模式"><a class="header-anchor" href="#行为模式">¶</a>行为模式</h2>
<h3 id="命令模式-Command"><a class="header-anchor" href="#命令模式-Command">¶</a>命令模式 Command</h3>
<p>命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作</p>
<p>例：开发文字编辑器中包含多个按钮的工具栏，GUI层将工作委派给业务逻辑底层，命令模式建议GUI对象不直接提交这些请求，而是将请求的所有细节抽取出来组成命令类，命令类是减少 GUI 和业务逻辑层之间耦合的中间层</p>
<div align=center><img width = '885' height = '592' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.PNG"/></div>
<h3 id="策略模式-Strategy"><a class="header-anchor" href="#策略模式-Strategy">¶</a>策略模式 Strategy</h3>
<p>策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换</p>
<p>名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用，上下文并不执行任务，而是将工作委派给已连接的策略对象</p>
<p>上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。实际上，上下文并不十分了解策略，它会通过同样的通用接口与所有策略进行交互，而该接口只需暴露一个方法来触发所选策略中封装的算法即可</p>
<p>因此，上下文可独立于具体策略。这样就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了</p>
<p>应用场景：不同交通工具的路线规划</p>
<div align=center><img width = '870' height = '405' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.PNG"/></div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Strategy() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">doAlgorithm</span><span class="params">(<span class="built_in">std</span>::string_view data)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//c++ 17中，标准库新增了一个特殊的字符串类std::string_view</span></span><br><span class="line">    <span class="comment">//它允许我们像std::string一样处理字符序列，而不需要为这些字符序列分配内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Strategy&gt; strategy_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Context</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Strategy&gt; &amp;&amp;strategy = &#123;&#125;)</span> : <span class="title">strategy_</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(strategy))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_strategy</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Strategy&gt; &amp;&amp;strategy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        strategy_ = <span class="built_in">std</span>::<span class="built_in">move</span>(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomeBusinessLogic</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strategy_) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Context: Sorting data using the strategy (not sure how it'll do it)\n"</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> result = strategy_-&gt;doAlgorithm(<span class="string">"aecbd"</span>);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Context: Strategy isn't set\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> :</span> <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">doAlgorithm</span><span class="params">(<span class="built_in">std</span>::string_view data)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">result</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(<span class="built_in">std</span>::<span class="built_in">begin</span>(result), <span class="built_in">std</span>::<span class="built_in">end</span>(result));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> :</span> <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">doAlgorithm</span><span class="params">(<span class="built_in">std</span>::string_view data)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">result</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(<span class="built_in">std</span>::<span class="built_in">begin</span>(result), <span class="built_in">std</span>::<span class="built_in">end</span>(result), <span class="built_in">std</span>::greater&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">(<span class="built_in">std</span>::make_unique&lt;ConcreteStrategyA&gt;())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Client: Strategy is set to normal sorting.\n"</span>;</span><br><span class="line">    context.doSomeBusinessLogic();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Client: Strategy is set to reverse sorting.\n"</span>;</span><br><span class="line">    context.set_strategy(<span class="built_in">std</span>::make_unique&lt;ConcreteStrategyB&gt;());</span><br><span class="line">    context.doSomeBusinessLogic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clientCode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output.txt:执行结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Strategy is set to normal sorting.</span></span><br><span class="line"><span class="comment">Context: Sorting data using the strategy (not sure how it'll do it)</span></span><br><span class="line"><span class="comment">abcde</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Client: Strategy is set to reverse sorting.</span></span><br><span class="line"><span class="comment">Context: Sorting data using the strategy (not sure how it'll do it)</span></span><br><span class="line"><span class="comment">edcba</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="状态模式-State"><a class="header-anchor" href="#状态模式-State">¶</a>状态模式 State</h3>
<p>状态模式是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样</p>
<p>状态模式与 <strong>有限状态机</strong> 的概念紧密相关，其主要思想是程序在任意时刻仅可处于几种 <strong>有限</strong> 的 <strong>状态</strong> 中。在任何一个特定状态中，程序的行为都不相同，且可瞬间从一个状态切换到另一个状态。不过，根据当前状态，程序可能会切换到另外一种状态，也可能会保持当前状态不变。这些数量有限且预先定义的状态切换规则被称为 <strong>转移</strong></p>
<p>将该方法应用在对象上，假如有一个文档 Document 类，文档可能会处于草稿 Draft、审阅中 Moderation 和已发布 Published 三种状态中的一种。文档的 publish 发布方法在不同状态下的行为略有不同：</p>
<ul>
<li>处于草稿状态时，它会将文档转移到审阅中状态</li>
<li>处于审阅中状态时，如果当前用户是管理员，它会公开发布文档</li>
<li>处于已发布状态时，它不会进行任何操作</li>
</ul>
<div align=center><img width = '370' height = '440' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%A8%E9%83%A8%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E7%A7%BB.PNG"/></div>
<p>基于条件语句的状态机，代码的维护工作非常艰难，随着时间推移，最初仅包含有限条件语句的简洁状态机可能会变成臃肿的一团乱麻，而状态模式建议为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中</p>
<p>原始对象被称为上下文（context），它并不会自行实现所有行为， 而是会保存一个指向表示当前状态的状态对象的引用，且将所有与状态相关的工作委派给该对象。如需将上下文转换为另外一种状态，则需将当前活动的状态对象替换为另外一个代表新状态的对象。采用这种方式是有前提的：所有状态类都必须遵循同样的接口，而且上下文必须仅通过接口与这些对象进行交互</p>
<div align=center><img width = '885' height = '525' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.PNG"/></div>
<p>状态可被视为策略的扩展，两者都基于组合机制，通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。在状态模式中，特定状态知道其他所有状态的存在，且能触发从一个状态到另一个状态的转换；而策略模式中则几乎完全不知道其他策略的存在，相互之间完全独立</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Context *context_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~State() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_context</span><span class="params">(Context *context)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;context_ = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Handle1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Handle2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *state_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Context(State *state) : state_(<span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;TransitionTo(state);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Context() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> state_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TransitionTo</span><span class="params">(State *state)</span> <span class="comment">// changeState</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Context: Transition to "</span> &lt;&lt; <span class="keyword">typeid</span>(*state).name() &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;state_ != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;state_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state_ = state;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state_-&gt;set_context(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state_-&gt;Handle1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;state_-&gt;Handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> :</span> <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle1</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle2</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStateA handles request2.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> :</span> <span class="keyword">public</span> State </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStateB handles request1.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Handle2</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStateB handles request2.\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStateB wants to change the state of the context.\n"</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;context_-&gt;TransitionTo(<span class="keyword">new</span> ConcreteStateA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConcreteStateA::Handle1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStateA handles request1.\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ConcreteStateA wants to change the state of the context.\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;context_-&gt;TransitionTo(<span class="keyword">new</span> ConcreteStateB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Context *context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStateA);</span><br><span class="line">    context-&gt;Request1();</span><br><span class="line">    context-&gt;Request2();</span><br><span class="line">    <span class="keyword">delete</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClientCode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output.txt:执行结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Context: Transition to class ConcreteStateA.</span></span><br><span class="line"><span class="comment">ConcreteStateA handles request1.</span></span><br><span class="line"><span class="comment">ConcreteStateA wants to change the state of the context.</span></span><br><span class="line"><span class="comment">Context: Transition to class ConcreteStateB.</span></span><br><span class="line"><span class="comment">ConcreteStateB handles request2.</span></span><br><span class="line"><span class="comment">ConcreteStateB wants to change the state of the context.</span></span><br><span class="line"><span class="comment">Context: Transition to class ConcreteStateA.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="观察者模式-Observer"><a class="header-anchor" href="#观察者模式-Observer">¶</a>观察者模式 Observer</h3>
<p>观察者模式是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象</p>
<p>拥有一些值得关注的状态的对象通常被称为目标，由于它要将自身的状态改变通知给其他对象，也将其称为发布者（publisher），所有希望关注发布者状态变化的其他对象被称为订阅者（subscribers）</p>
<p>观察者模式建议为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流，该机制包括 1）一个用于存储订阅者对象引用的列表成员变量；2）几个用于添加或删除该列表中订阅者的公有方法；无论何时发生了重要的发布者事件，都要遍历订阅者并调用其对象的特定通知方法</p>
<p>所有订阅者都必须实现同样的接口，发布者仅通过该接口与订阅者交互，接口中必须声明通知方法及其参数；甚至可以进一步让所有发布者遵循同样的接口，这样订阅者就能在不与具体发布者类耦合的情况下通过接口观察发布者的状态</p>
<div align=center><img width = '885' height = '525' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.PNG"/></div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者（订阅者）的抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IObserver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~IObserver() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message_from_subject)</span> </span>= <span class="number">0</span>;   <span class="comment">// 得到消息后更新自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者的抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~ISubject() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attach</span><span class="params">(IObserver* observer)</span> </span>= <span class="number">0</span>;                       <span class="comment">// 添加订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Detach</span><span class="params">(IObserver* observer)</span> </span>= <span class="number">0</span>;                       <span class="comment">// 删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>= <span class="number">0</span>;                                          <span class="comment">// 将通知信息发给所有订阅者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> :</span> <span class="keyword">public</span> ISubject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Subject();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(IObserver* observer)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">(IObserver* observer)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateMessage</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> message)</span></span>;                            <span class="comment">// 传入消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HowManyObserver</span><span class="params">()</span></span>;                                             <span class="comment">// 统计现有的订阅者数量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SomeBusinessLogic</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;IObserver*&gt; list_observer_;                               <span class="comment">// 存储订阅者对象引用的列表成员变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message_;                                               <span class="comment">// 消息字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> :</span> <span class="keyword">public</span> IObserver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Observer(Subject&amp; subject);</span><br><span class="line">    <span class="keyword">virtual</span> ~Observer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message_from_subject)</span> <span class="keyword">override</span></span>;      <span class="comment">// 更新方法，传递发布者消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveMeFromTheList</span><span class="params">()</span></span>;                                         <span class="comment">// 将该订阅者对象从列表中删除（调用 Detach）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span>;                                                   <span class="comment">// 显示信息</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message_from_subject_;                                  <span class="comment">// 发布者消息的缓存</span></span><br><span class="line">    Subject&amp; subject_;                                                  <span class="comment">// 发布者对象的引用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_number_;                                          <span class="comment">// 订阅者数量</span></span><br><span class="line">    <span class="keyword">int</span> number_;                                                        <span class="comment">// 订阅者编号 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>学习笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>转载：AT&amp;T 和 Intel 规范的区别</title>
    <url>/2021/10/14/%E8%BD%AC%E8%BD%BD%EF%BC%9AAT&amp;T%20%E5%92%8C%20Intel%20%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<p><strong>常见的指令集以及汇编语言规范：</strong></p>
<ul>
<li>x86(IA-32)、x86-64指令集(常见于PC端)，对应有2家公司发布的不同汇编语言规范：
<ul>
<li>intel公司发布的汇编语言规范，称<code>intel 汇编</code>：Windows派系(Microsoft)，比较著名的汇编器有微软的masm和开源的nasm。</li>
<li>AT&amp;T公司发布的汇编语言规范，称<code>AT&amp;T 汇编</code>：Unix派系(或者说GNU)，比如g++编译器等。</li>
</ul>
</li>
<li>ARM指令集(常见于嵌入式、移动端设备，粗略统计覆盖95%左右的手段)：ARM公司发布的汇编语言规范，称<code>ARM 汇编(目前常见的是ARM 64汇编)</code>，见<a href="https://developer.arm.com/architectures" target="_blank" rel="noopener">官网文档</a><a id="more"></a></li>
</ul>
<h2 id="AT-T格式-和-Intel格式的区别"><a class="header-anchor" href="#AT-T格式-和-Intel格式的区别">¶</a>AT&amp;T格式 和 Intel格式的区别</h2>
<p>表格如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">AT&amp;T格式</th>
<th style="text-align:center">Intel格式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>pushl %eax</code></td>
<td style="text-align:center"><code>push eax</code></td>
<td style="text-align:center">在AT&amp;T汇编格式中，寄存器名要加上’%'作为前缀；而在Intel汇编格式中，寄存器名不需要加前缀</td>
</tr>
<tr>
<td style="text-align:center"><code>pushl $1</code></td>
<td style="text-align:center"><code>push 1</code></td>
<td style="text-align:center">在AT&amp;T汇编格式中，用’$'前缀表示一个立即操作数；而在Intel汇编格式中，立即数的表示不用带任何前缀</td>
</tr>
<tr>
<td style="text-align:center"><code>addl $1, %eax</code></td>
<td style="text-align:center"><code>add eax, 1</code></td>
<td style="text-align:center">AT&amp;T和Intel格式中的源操作数和目标操作数的位置正好相反。在Intel汇编格式中，目标操作数在源操作数的左边；而在AT&amp;T汇编格式中，目标操作数在源操作数的右边。</td>
</tr>
<tr>
<td style="text-align:center"><code>movb val, %al</code></td>
<td style="text-align:center"><code>mov al, byte ptr val</code></td>
<td style="text-align:center">在AT&amp;T汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、‘w’、'l’分别表示操作数为字节（byte，8比特）、字（word，16比特）和长字（long，32比特）；而在Intel汇编格式中，操作数的字长是用&quot;byte ptr&quot;和&quot;word ptr&quot;等前缀来表示的。</td>
</tr>
<tr>
<td style="text-align:center"><code>ljump $section, $offset</code></td>
<td style="text-align:center"><code>jmp far section:offset</code></td>
<td style="text-align:center">在AT&amp;T汇编格式中，绝对转移和调用指令（jump/call）的操作数前要加上’*'作为前缀，而在Intel格式中则不需要。远程转移指令和远程子调用指令的操作码，在AT&amp;T汇编格式中为&quot;ljump&quot;和&quot;lcall&quot;，而在Intel汇编格式中则为&quot;jmp far&quot;和&quot;call far&quot;</td>
</tr>
<tr>
<td style="text-align:center"><code>lcall $section, $offset</code></td>
<td style="text-align:center"><code>call far section:offset</code></td>
<td style="text-align:center">同上</td>
</tr>
<tr>
<td style="text-align:center"><code>lret $stack_adjust</code></td>
<td style="text-align:center"><code>ret far stack_adjust</code></td>
<td style="text-align:center">与之相应的远程返回指令</td>
</tr>
<tr>
<td style="text-align:center"><code>section:disp(base, index, scale)</code></td>
<td style="text-align:center"><code>section:[base + index*scale + disp]</code></td>
<td style="text-align:center">寻址方式的区别，无论形式如何，都是实现如下的地址计算：（其中base和index必须是寄存器，disp和scale可以是常数）disp + base + index * scale</td>
</tr>
<tr>
<td style="text-align:center">—</td>
<td style="text-align:center">—</td>
<td style="text-align:center">—</td>
</tr>
<tr>
<td style="text-align:center"><code>movl -4(%ebp), %eax</code></td>
<td style="text-align:center"><code>mov eax, [ebp - 4]</code></td>
<td style="text-align:center">内存操作数的例子</td>
</tr>
<tr>
<td style="text-align:center"><code>movl array(, %eax, 4), %eax</code></td>
<td style="text-align:center"><code>mov eax, [eax*4 + array]</code></td>
<td style="text-align:center">内存操作数的例子</td>
</tr>
<tr>
<td style="text-align:center"><code>movw array(%ebx, %eax, 4), %cx</code></td>
<td style="text-align:center"><code>mov cx, [ebx + 4*eax + array]</code></td>
<td style="text-align:center">内存操作数的例子</td>
</tr>
<tr>
<td style="text-align:center"><code>movb $4, %fs:(%eax)</code></td>
<td style="text-align:center"><code>mov fs:eax, 4</code></td>
<td style="text-align:center">内存操作数的例子</td>
</tr>
</tbody>
</table>
<h2 id="搭建Intel的环境"><a class="header-anchor" href="#搭建Intel的环境">¶</a>搭建Intel的环境</h2>
<ul>
<li>ubuntu16.04 或 ubuntu18.04</li>
<li>vscode</li>
<li>dosbox</li>
<li>文件后缀：.asm</li>
</ul>
<p>安装dosbox</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install dosbox</span></span><br></pre></td></tr></table></figure>
<p>下载<code>vscode</code>插件<code>MASM/TASM</code></p>
<h2 id="Intel的hello-asm"><a class="header-anchor" href="#Intel的hello-asm">¶</a>Intel的hello.asm</h2>
<figure class="highlight x86asm"><figcaption><span>hello.asm</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">;description</span></span><br><span class="line">DATA <span class="meta">SEGMENT</span> <span class="meta">USE16</span></span><br><span class="line">    MYWORD <span class="built_in">DB</span> <span class="string">"hello world!!!"</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line"><span class="comment">;description</span></span><br><span class="line">CODE <span class="meta">SEGMENT</span> <span class="meta">USE16</span></span><br><span class="line">    <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE, <span class="built_in">DS</span>:DATA     <span class="comment">;代表谁是代码段，谁是数据段</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">AX</span>, DATA                <span class="comment">;数据首地址赋值给AX， ax是寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">DS</span>, <span class="built_in">AX</span>                  <span class="comment">;使得DS等价于AX，同样指向数据段</span></span><br><span class="line">    <span class="keyword">LEA</span> <span class="built_in">DX</span>, MYWORD              <span class="comment">;使DX寄存器指向数据变量word的首地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">AH</span>, <span class="number">09h</span>                 <span class="comment">;AH输出数据</span></span><br><span class="line">    <span class="keyword">INT</span> <span class="number">21h</span>                     <span class="comment">;执行AH的09h功能， 输出数据</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">AX</span>, <span class="number">4c00h</span>               <span class="comment">;设置寄存器的功能</span></span><br><span class="line">    <span class="keyword">INT</span> <span class="number">21h</span>                     <span class="comment">;调用寄存器功能 程序结束</span></span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END main</span><br></pre></td></tr></table></figure>
<p>在文件中点击鼠标右键<code>运行程序</code></p>
<h2 id="搭建AT-T的环境"><a class="header-anchor" href="#搭建AT-T的环境">¶</a>搭建AT&amp;T的环境</h2>
<ul>
<li>ubuntu16.04 或 ubuntu18.04</li>
<li>vscode</li>
<li>文件后缀： .s</li>
<li>gcc</li>
</ul>
<p>下载<code>vscode</code>插件<code>GNU Assembler Language Support</code></p>
<h2 id="AT-T的hello-s"><a class="header-anchor" href="#AT-T的hello-s">¶</a>AT&amp;T的hello.s</h2>
<figure class="highlight plain"><figcaption><span>hello.s</span></figcaption><table><tr><td class="code"><pre><span class="line">.data#数据段声明</span><br><span class="line"> </span><br><span class="line">msg : .string &quot;Hello, world\n&quot;  #要输出的字符串</span><br><span class="line">len &#x3D; . - msg                   #字串长度</span><br><span class="line"> </span><br><span class="line">.text                           #代码段声明</span><br><span class="line">.global main                    #指定入口函数</span><br><span class="line"> </span><br><span class="line">main:                           #在屏幕上显示一个字符串</span><br><span class="line">    movl $len, %edx             #参数三：字符串长度 </span><br><span class="line">    movl $msg, %ecx             #参数二：要显示的字符串</span><br><span class="line">    movl $1, %ebx               #参数一：文件描述符(stdout)</span><br><span class="line">    movl $4, %eax               #系统调用号(sys_write)</span><br><span class="line">    int  $0x80                  #调用内核功能</span><br><span class="line"></span><br><span class="line">    #退出程序</span><br><span class="line">    movl $0,%ebx                #参数一：退出代码</span><br><span class="line">    </span><br><span class="line">    movl $1,%eax                #系统调用号(sys_exit)</span><br><span class="line">    int  $0x80                  #调用内核功能</span><br></pre></td></tr></table></figure>
<p>编译运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.s -o hello_att</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./hello_att</span></span><br></pre></td></tr></table></figure>
<h2 id="通过objdump查看到的几种cpu架构"><a class="header-anchor" href="#通过objdump查看到的几种cpu架构">¶</a>通过objdump查看到的几种cpu架构</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump --<span class="built_in">help</span></span></span><br><span class="line">objdump：支持的体系结构： i386 i386:x86-64 i386:x64-32 i8086 i386:intel i386:x86-64:intel i386:x64-32:intel i386:nacl i386:x86-64:nacl i386:x64-32:nacl iamcu iamcu:intel l1om l1om:intel k1om k1om:intel plugin</span><br><span class="line"></span><br><span class="line">下列 i386/x86-64 特定的反汇编器选项在使用 -M 开关时可用（使用逗号分隔多个选项）：</span><br><span class="line">  x86-64      Disassemble in 64bit mode</span><br><span class="line">  i386        Disassemble in 32bit mode</span><br><span class="line">  i8086       在 16 位模式下反汇编</span><br><span class="line">  att         用 AT&amp;T 语法显示指令</span><br><span class="line">  intel       用 Intel 语法显示指令</span><br><span class="line">  att-mnemonic</span><br><span class="line">              Display instruction in AT&amp;T mnemonic</span><br><span class="line">  intel-mnemonic</span><br><span class="line">              Display instruction in Intel mnemonic</span><br><span class="line">  addr64      假定 64 位地址大小</span><br><span class="line">  addr32      假定 32 位地址大小</span><br><span class="line">  addr16      假定 16 位地址大小</span><br><span class="line">  data32      假定 32 位数据大小</span><br><span class="line">  data16      假定 16 位数据大小</span><br><span class="line">  suffix      在 AT&amp;T 语法中始终显示指令后缀</span><br><span class="line">  amd64       Display instruction in AMD64 ISA</span><br><span class="line">  intel64     Display instruction in Intel64 ISA</span><br></pre></td></tr></table></figure>
<p>汇编学习地址：<a href="http://c.biancheng.net/view/3463.html" target="_blank" rel="noopener">第一个汇编语言程序</a></p>
<hr>
<p>版权声明：本文为CSDN博主「线条君」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a href="https://blog.csdn.net/qq_39503880/article/details/113462657" target="_blank" rel="noopener">https://blog.csdn.net/qq_39503880/article/details/113462657</a></p>
]]></content>
      <tags>
        <tag>转载</tag>
        <tag>Assembly Language</tag>
      </tags>
  </entry>
  <entry>
    <title>通信原理笔记</title>
    <url>/2021/03/29/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="致谢"><a class="header-anchor" href="#致谢">¶</a>致谢</h2>
<p>感谢 <a href="https://github.com/daycun" target="_blank" rel="noopener">daycun</a> 同学在通信相关课程上对本人不遗余力的教导<a id="more"></a></p>
<h2 id="参考教材"><a class="header-anchor" href="#参考教材">¶</a>参考教材</h2>
<ol>
<li>张会生，通信原理 . 北京：高等教育出版社，2011</li>
<li>樊昌信、曹丽娜，通信原理（第七版）. 北京：国防工业出版社，2017.</li>
</ol>
<h2 id="第一章-绪论"><a class="header-anchor" href="#第一章-绪论">¶</a>第一章 绪论</h2>
<blockquote>
<p>考察重点: 待定<br>
信息量与平均信息量的计算<br>
码元传输速率与信息传输速率的计算与互换</p>
</blockquote>
<h3 id="通信的基本概念"><a class="header-anchor" href="#通信的基本概念">¶</a>通信的基本概念</h3>
<p>广义的 <strong>通信</strong>：是指由一地向另一地进行消息的有效传递。<br>
通信的再定义：利用电子等技术手段，借助电信号（含光信号）实现从一地向另一地进行消息的有效传递称为通信。</p>
<p><strong>通信系统</strong>：实现信息传递所需的一切 <strong>技术设备</strong> 和 <strong>传输媒质</strong> 的总和称为通信系统。</p>
<p>通信系统的一般模型：</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%88%AC%E6%A8%A1%E5%9E%8B.PNG"/></div><br>
<p><strong>信源</strong>（信息源、发终端）：把待传输的消息转换成原始电信号。<br>
<strong>发送设备</strong>：产生适合于在信道中传输的信号，即将信源和信道 <strong>匹配</strong>。如：调制。<br>
<strong>信道</strong>：信号传输的通道。将来自发送设备的信号传送到接收端的物理媒质，分为 <strong>有线信道</strong> 和 <strong>无线信道</strong> 两大类。<br>
<strong>噪声源</strong>：信道中的所有噪声以及分散在通信系统中其它各处噪声的集合。<br>
<strong>接收设备</strong>：从受到减损（干扰）的接收信号中正确恢复出原始电信号。<br>
<strong>信宿</strong>（受信者、收终端 ）：将复原的原始电信号还原成相应的消息。</p>
<p>按照信道中传输的是模拟信号还是数字信号，将通信系统分为 <strong>模拟通信系统</strong> 与 <strong>数字通信系统</strong>。</p>
<p><strong>通信方式</strong>：</p>
<p>按消息传送的方向与时间分可分为单工通信、半双工通信及全双工通信三种。</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.PNG"/></div><br>
<p>按数字信号排序分可分为串序传输和并序传输。串行传输是将数字信号码元序列以串行方式一个码元接一个码元地在一条信道上传输，并行传输是将代表信息的数字信号码元序列以成组的方式在两条或两条以上的并行信道上同时传输。</p>
<h3 id="信息的概念"><a class="header-anchor" href="#信息的概念">¶</a>信息的概念</h3>
<p>经典Shannon信息定义：<strong>信息是不确定性的消除</strong>。</p>
<p>信息可被理解为消息中包含的有意义的内容，消息中所含信息量仅与消息内容的不确定性有关，由概率论可知，事件的不确定程度，可用事件出现的概率来描述——信息量与消息出现概率关系。</p>
<ul>
<li>消息 $x$ 中所含信息量 $I$ 是消息出现概率 $P(x)$ 的函数，即</li>
</ul>
$$I = I[P(x) ]$$
<ul>
<li>消息出现的概率越小，它所含信息量越大，反之信息量越小。特别是</li>
</ul>
$$I = 0~~~~\text{when}~~~~P(x) = 1$$
$$I = 1~~~~\text{when}~~~~P(x) = 0$$
<ul>
<li>若干个互相独立事件构成的消息$（x1,x2,\cdots）$所含信息量等于各独立事件$x1$，$x2$，$\cdots$ 信息量的和，即</li>
</ul>
$$I[P(x_1 ) ⋅ P(x_2 ) ⋅ \cdots] = I[P(x_1 )] + I[P(x_2) ] + \cdots$$
<p>于是定义消息 $x$ 所含的信息量为</p>
$$I = \log_{a}\dfrac{1}{P(x)} = -\log_{a}P(x)$$
<p>信息量 $I$ 的单位取决于对数底数 $a$ 的取值</p>
<div align=center>a = 2 单位为比特（bit，简写为b）；</div>
<div align=center>a = e 单位为奈特（nat，简写为n）；</div>
<div align=center>a = 10 单位为哈特莱（Hartley）。</div><br>
<p>通常广泛使用的单位为比特，即有</p>
$$I = \log_{2}\dfrac{1}{P(x)} = -\log_{2}P(x)$$
<p>二进制离散信源，数字 $0$ 或 $1$ 以相等的概率出现时，每个符号的信息量相等，为 $1\text{bit}$。独立等概情况下 $M$ 进制的每一符号包含的信息量，是二进制每一符号包含信息量的 $K$ 倍。（$K$ 是每一个 $M$ 进制符号用二进制符号表示时所需的符号数目，即 $M=2^K$）。</p>
<p>当各个符号出现的概率不相等时，计算消息的信息量常用到 <strong>平均信息量</strong> 的概念。</p>
<p>多进制时，设各符号出现的概率为</p>
$$
\begin{bmatrix}
x_1, & x_2, & \cdots, & x_n \\
P(x_1), & P(x_2), & \cdots, & P(x_n)
\end{bmatrix}
~~~~\text{and}~~~~
\sum^{n}_{i=1}P(x_i) = 1
$$
<p>则每个符号所含信息的统计平均值（平均信息量）</p>
$$
\begin{array}{lcl}
\bar {I}
& = &P(x_1)[-\log_{2} P(x_1)] + P(x_2)[-\log_{2} P(x_2)] + \cdots + P(x_n)[-\log_{2} P(x_n)] \\
& = & -\sum\limits^{n}_{i=1}P(x_i)\log_{2}P(x_i) ~~~~ (\text{bit}/符号)
\end{array}
$$
<p>又称 $\bar{I}$ 为 <strong>信息源的熵</strong>。</p>
<p>显然，当信源中每个符号独立等概率出现时，有</p>
$$\bar{I} = \log_{2} M = \log_{2} 2^K = K ~~~~ (\text{bit}/符号)$$
<p>可以证明，此时信息源的熵为最大值。</p>
<p>关于连续消息的信息量可以用 <strong>概率密度函数</strong> 来描述。可以证明，<strong>连续消息的平均信息量</strong> 为</p>
$$H(x) = -\int^{\infty}_{-\infty} f(x) \log_{a} f(x) \mathrm{d}x$$
<h3 id="通信系统的性能指标"><a class="header-anchor" href="#通信系统的性能指标">¶</a>通信系统的性能指标</h3>
<p>有效性指标用传输速率来衡量，通常有两种表示方法，分别为码元传输速率 $R_B$ 与信息传输速率 $R_b$，码元传输速率 $R_b$ 是指单位时间（每秒）内传输码元的数目，单位为 $\text{Baud(B)}$，信息传输速率 $R_b$ 是指单位时间（每秒）内传送的信息量，单位为 $\text{bit/s(b/s or bps)}$。</p>
<p>$R_b$ 与 $R_B$ 的互换公式为</p>
$$R_{bM} = R_{BM} \cdot \log_{2}M$$
<p>其中，$M$ 为信号进制数，所以二进制时，有 $R_{b2} = R_{B2} \cdot \log_{2}2 = R_{B2}$</p>
<p>可靠性的指标是利用信号在传输过程中出错的概率即差错率来描述的，即差错占总体的比例，通常也有两种表示方法，分别为码元差错率（误码率）$P_e$ 与信息差错率（误信率）$P_b$，二进制时，有 $P_b=P_e$，在非二进制时，注意两者的不同。</p>
<h2 id="第二章-随机信号与噪声分析"><a class="header-anchor" href="#第二章-随机信号与噪声分析">¶</a>第二章 随机信号与噪声分析</h2>
<blockquote>
<p>考察重点: 待定<br>
求随机过程的数字特征<br>
勿忘积化和差公式<br>
判断随机过程是否平稳 …</p>
</blockquote>
<h3 id="随机过程"><a class="header-anchor" href="#随机过程">¶</a>随机过程</h3>
<p>通信是在噪声背景下信号通过通信系统的过程，分析与研究通信系统，总是离不开对信号和噪声的分析。尽管随机信号和随机噪声是不可预测的、随机的，但它们具有一定的统计规律。从统计学的观点看，均可表示为 <strong>随机过程</strong>。</p>
<h4 id="基本概念"><a class="header-anchor" href="#基本概念">¶</a>基本概念</h4>
<p>随机过程是一类随时间作随机变化的过程，它不能用确切的时间函数描述。随机过程 $X(t)$ 对应不同随机试验结果的 <strong>随机函数</strong>（时间过程）的集合 $\{ x_1(t), x_2(t), \dots, x_n(t) \}$，是 <strong>随机变量</strong> 概念的延伸，即 $X(t)$ 在任一时刻 $t_1$ 上的取值 $X(t_1)$ 不是确定的，是一个随机变量。</p>
<h4 id="分布函数"><a class="header-anchor" href="#分布函数">¶</a>分布函数</h4>
<ul>
<li>一维分布函数</li>
</ul>
$$F_1(x_1, t_1) = P[X(t_1) \le x_1]$$
<ul>
<li>一维概率密度函数(偏导存在)</li>
</ul>
$$f_1(x_1, t_1) = \dfrac{\partial F_1(x_1, t_1)}{\partial x_1}$$
<ul>
<li>$n$ 维分布函数</li>
</ul>
$$F_n(x_1, x_2, \cdots, x_n; t_1, t_2, \cdots, t_n)\\=P\{ X(t_1) \le x_1, X(t_2) \le x_2, \cdots, X(t_n) \le x_n,\}$$
<ul>
<li>$n$ 维概率密度函数(偏导存在)</li>
</ul>
$$f_n(x_1, x_2, \cdots, x_n; t_1, t_2, \cdots, t_n) = \dfrac{\partial^{n} F_1(x_1, x_2, \cdots, x_n; t_1, t_2, \cdots, t_n)}{\partial x_1\partial x_2\cdots\partial x_n}$$
<h4 id="统计独立"><a class="header-anchor" href="#统计独立">¶</a>统计独立</h4>
<p>对于任何 $n$ 个随机变量 $X(t_1)$，$X(t_2)$，$\dots$，$X(t_n)$，如果下式成立</p>
$$f_n(x_1, x_2, \cdots, x_n; t_1, t_2, \cdots, t_n) = f_1(x_1, t_1)f_1(x_2, t_2) \dots f_1(x_n, t_n)$$
<p>则称这些变量是 <strong>统计独立</strong> 的，否则就是不独立的或相关的。</p>
<h4 id="数字特征"><a class="header-anchor" href="#数字特征">¶</a>数字特征</h4>
<h5 id="随机过程的数学期望"><a class="header-anchor" href="#随机过程的数学期望">¶</a>随机过程的数学期望</h5>
<p>随机过程 $X(t)$ 在任意给定时刻 $t_1$ 的取值 $X(t_1)$ 是一个随机变量，其 <strong>数学期望（均值）</strong> 为</p>
$$E[X(t_1)] = \int^{\infty}_{-\infty} x_1 f_1(x_1, t_1) \mathrm{d}x$$
<p>其中 $f_1 (x_1, t_1)$ 为 $X(t_1)$ 的概率密度函数。<br>
由于 $t_1$ 是任取的，所以可以把 $t_1$ 直接写为 $t$，$x_1$改为 $x$，这样便可得到随机过程在任意给定时刻 $t$ 的数学期望</p>
$$E[X(t)] = \int^{\infty}_{-\infty} x f_1(x, t) \mathrm{d}x \longrightarrow a(t)$$
<p>$X (t)$ 的数学期望是时间的确定函数，常记作 $a(t)$，它表示随机过程的 $n$ 个样本函数曲线的摆动中心，故又常被称为统计平均或均值。</p>
<p><br><div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B.PNG"/></div><br></p>
<h5 id="方差"><a class="header-anchor" href="#方差">¶</a>方差</h5>
<p>随机过程的 <strong>方差</strong> 定义为</p>
$$D[X(t)] = E\{ [ X(t) - a(t) ]^2 \} \longrightarrow \sigma^2(t)$$
<p>这里也把任意时刻 $t_1$ 直接写成了 $t$。由方差的定义式可推导得到</p>
$$D[X(t)] = E[X^2(t)] - a^2(t) = \int^{\infty}_{-\infty} x^2 f_1(x, t)\mathrm{d}x - [a(t)]^2$$
<p>可知方差等于均方值与均值平方之差，它表示随机过程在时刻 $t$ 相对于均值 $a ( t )$ 的偏离程度。</p>
<h5 id="相关函数与协方差"><a class="header-anchor" href="#相关函数与协方差">¶</a>相关函数与协方差</h5>
<p>设 $X(t_1)$ 和 $X(t_2)$ 分别是在 $t_1$ 和 $t_2$ 时刻观测得到的随机变量。</p>
<p>随机过程的（自）<strong>相关函数</strong>（同一随机过程的相关程度），定义为</p>
$$R(t_1, t_2) = E[X(t_1)X(t_2)] = \int^{\infty}_{-\infty}\int^{\infty}_{-\infty} x_1x_2f_2(x_1, x_2; t_1, t_2)\mathrm{d}x_1\mathrm{d}x_2 = R(t, \tau)$$
<p>其中 $f_2(x_1, x_2; t_1, t_2)$ 为 $X(t)$ 的二维概率密度函数;<br>
令 $t = t_1$，$\tau = t_2 - t_1$，则 $R(t_1, t_2)$ 可表示为 $R(t, \tau)$;<br>
可以看出 $R(t_1, t_2)$ 是两个变量 $t_1$ 和 $t_2$ 的确定函数。</p>
<p>随机过程的 <strong>协方差函数</strong> 定义为</p>
$$B(t_1, t_2) = E{[X(t_1) - a(t_1)][X(t_2) - a(t_2)]} \\= \int^{\infty}_{-\infty}\int^{\infty}_{-\infty} [x_1 - a(t_1)][x_2 - a(t_2)]f_2(x_1, x_2; t_1, t_2)\mathrm{d}x_1\mathrm{d}x_2$$
<p>显然，相关函数和协方差函数之间有如下关系</p>
$$B(t_1, t_2) = R(t_1, t_2) - a(t_1)a(t_2)$$
<p>引申到两个随机过程，有</p>
<ul>
<li>互相关函数</li>
</ul>
$$R_{XY}(t_1, t_2) = E[X(t_1)Y(t_2)] $$
<ul>
<li>互协方差函数</li>
</ul>
$$B_{XY}(t_1, t_2) = E\{ [X(t_1) - a_X(t_1)][Y(t_2) - a_Y(t_2)]\}$$
<h3 id="平稳随机过程"><a class="header-anchor" href="#平稳随机过程">¶</a>平稳随机过程</h3>
<p>若一个随机过程 $X(t)$，它的任意 $n$ 维分布或概率密度函数与时间起点无关，即对于任意的正整数 $n$ 和所有实数 $\Delta$，有</p>
$$f_n(x_1, x_2, \cdots, x_n; t_1, t_2, \cdots, t_n) \\= f_n(x_1, x_2, \cdots, x_n; t_1 + \Delta, t_2 + \Delta, \cdots, t_n + \Delta)$$
<p>则称X(t)是 <strong>平稳随机过程</strong>。</p>
<h4 id="性质"><a class="header-anchor" href="#性质">¶</a>性质</h4>
<p>平稳随机过程的统计特性不随时间的推移而改变。</p>
<ul>
<li>一维概率密度函数与时间 $t$ 无关</li>
</ul>
$$f_1(x_1, t_1) = f_1(x_1)$$
<ul>
<li>二维概率密度函数只与时间间隔 $\tau = t_2 – t_1$ 有关</li>
</ul>
$$f_2(x_1, x_2; t_1, t_2) = f_2(x_1, x_2; \tau)$$
<h4 id="数字特征-v2"><a class="header-anchor" href="#数字特征-v2">¶</a>数字特征</h4>
<p>（1）均值与 $t$ 无关，为常数 $a$</p>
$$E[X(t)] = \int^{\infty}_{-\infty} x_1 f_1(x_1) \mathrm{d}x = a$$
<p>（2）自相关函数只与时间间隔 $\tau$ 有关</p>
$$R(t_1, t_2) = E[X(t_1)X(t_1 + \tau)] = \int^{\infty}_{-\infty}\int^{\infty}_{-\infty} x_1x_2f_2(x_1, x_2; \tau)\mathrm{d}x_1\mathrm{d}x_2 = R(\tau)$$
<p>把同时满足（1）和（2）的随机过程定义为 <strong>广义平稳随机过程</strong>。</p>
<h4 id="平稳随机过程的各态历经性"><a class="header-anchor" href="#平稳随机过程的各态历经性">¶</a>平稳随机过程的各态历经性</h4>
<p><strong>各态历经性</strong> 的含义：随机过程中的任何一次实现都经历了随机过程的所有可能状态，其任一样本都蕴含着平稳随机过程的全部统计信息。<br>
具有各态历经性的过程，其数字特征（均为统计平均）完全可由随机过程中的任一实现的时间平均值来代替。</p>
<h5 id="各态历经性条件"><a class="header-anchor" href="#各态历经性条件">¶</a>各态历经性条件</h5>
<p>设：$x_i(t)$ 是平稳过程 $X(t)$ 的任意一次实现（样本），则其 <strong>时间均值</strong> 和 <strong>时间相关函数</strong> 分别定义为</p>
$$\overline{a} = \overline {x(t)} = \lim_{T \to \infty}\dfrac{1}{T}\int^{T/2}_{-T/2}x(t)\mathrm{d}t$$
$$\overline{R(\tau)} = \overline{x(t)x(t + \tau)} = \lim_{T \to \infty}\dfrac{1}{T}\int^{T/2}_{-T/2}x(t)x(t+\tau)\mathrm{d}t$$
<p>如果平稳过程使下式成立</p>
$$
\begin{cases}
& a = \overline{a} \\
& R(\tau) = \overline{R(\tau)}
\end{cases}
$$
<p>则称该平稳过程具有各态历经性。</p>
<h4 id="平稳过程的自相关函数"><a class="header-anchor" href="#平稳过程的自相关函数">¶</a>平稳过程的自相关函数</h4>
<p>平稳过程自相关函数的定义</p>
$$R(\tau) = R(t_1, t_2) = E[X(t_1)X(t_2)]$$
<p>平稳过程自相关函数的性质</p>
<ul>
<li>$R(\tau) = R(-\tau) ~~~~~~~~~~~~~~~~~~~~$ —— $\tau$ 的偶函数</li>
<li>$|R(\tau)| \le R(0) ~~~~~~~~~~~~~~~~~~~~$ —— $R(\tau)$ 的上界，$R(\tau)$ 在 $\tau = 0$ 有最大值</li>
<li>$R(0) = E[X^2(t)] ~~~~~~~~~~~~~~~~$ —— $X(t)$ 的平均功率</li>
<li>$R(\infty) = E^2[X(t)] = a^2 ~~~~$ —— $X(t)$ 的直流功率</li>
<li>$R(0) - R(\infty) = \sigma^2 ~~~~~~~~~~~~$ —— $X(t)$ 的交流功率</li>
</ul>
<p>通常，通信信道中噪声的均值 $a=0$，由此得到噪声的平均功率 $R(0) = \sigma^2$。</p>
<h4 id="平稳随机过程的功率谱密度"><a class="header-anchor" href="#平稳随机过程的功率谱密度">¶</a>平稳随机过程的功率谱密度</h4>
<p>设：$X(t)$ 平稳，$R(\tau)$ 绝对可积 $\int^{\infty}_{-\infty}|R(\tau)|\mathrm{d}\tau < \infty$</p>
<p>则</p>
$$P_X(\omega) = \int^{\infty}_{-\infty} R(\tau)e^{-j\omega\tau}\mathrm{d}\tau$$
$$R(\tau) = \dfrac{1}{2\pi}\int^{\infty}_{-\infty} P_X(\omega)e^{j\omega\tau} \mathrm{d}\omega$$
<p>简记为</p>
$$R(\tau) \Leftrightarrow P_X(\omega) \tag{维纳-辛钦关系}$$
<p>即平稳随机过程的自相关函数与其功率谱密度之间互为傅里叶关系。<strong>维纳-辛钦关系</strong> 在平稳随机过程的理论和应用中是一个非常重要的工具，它是联系频域和时域两种分析方法的基本关系式。</p>
<p>推论</p>
<ul>
<li>对功率谱密度进行积分，可得平稳过程的平均功率，从频域的角度给出了过程平均功率的计算方法</li>
</ul>
$$R(0) = \int^{\infty}_{-\infty} P_X(f) \mathrm{d}f$$
<ul>
<li>各态历经过程的任一实现的功率谱密度等于过程的功率谱密度，即任一实现的谱特性都能很好地表现整个过程的谱特性</li>
</ul>
$$P_X(\omega) = P_x(\omega)$$
<h3 id="高斯随机过程"><a class="header-anchor" href="#高斯随机过程">¶</a>高斯随机过程</h3>
<p>若随机过程 $X(t)$  的任意 $n$ 维分布（$n=1,2,…$）均服从正态分布，则称它为正态过程或高斯过程。</p>
<p>$n = 1$ 时，其一维正态概率密度函数为</p>
$$f_1(x_1, t_1) = \dfrac{1}{\sqrt{2\pi} \sigma_1} \exp\Big[ -\dfrac{(x_1 - a_1)^2}{2\sigma_1^2} \Big]$$
<p>此即为高斯过程 $X(t)$ 在时刻 $t_1$ 取值所得随机变量 $X(t_1)$ 的一维概率密度函数，$a_1$，$\sigma_1^2$ 分别为 $X(t_1)$ 的均值和方差</p>
<h4 id="性质-v2"><a class="header-anchor" href="#性质-v2">¶</a>性质</h4>
<ul>
<li>高斯过程若广义平稳，则必狭义平稳。</li>
<li>高斯过程中的随机变量 $X(t_1), X(t_2), X(t_3), \dots$ 之间若不相关，则它们也必是统计独立的。这种情况下，随机过程极其复杂的 $n$ 维正态概率密度函数表示可转化为 $n$ 个简单的一维分布的乘积。</li>
</ul>
$$
\begin{array}{lcl}
f_n(x_1, x_2, \cdots, x_n; t_1, t_2, \cdots, t_n)
& = & f_1(x_1, t_1)f_2(x_2, t_2) \cdots f_n(x_n, t_n) \\
& = & \prod\limits^{n}_{j = 1}\dfrac{1}{\sqrt{2\pi} \sigma_j} \exp\Big[ -\dfrac{(x_j - a_j)^2}{2\sigma_j^2} \Big]
\end{array}
$$
<ul>
<li>若干个高斯过程之和仍是高斯过程。</li>
<li>高斯过程经线性变换后，仍是高斯过程。</li>
</ul>
<h4 id="高斯随机变量"><a class="header-anchor" href="#高斯随机变量">¶</a>高斯随机变量</h4>
<p>若随机变量 $x$ 的概率密度函数可表示成</p>
$$f(x) = \dfrac{1}{\sqrt{2\pi} \sigma} \exp\Big[ -\dfrac{(x - a)^2}{2\sigma^2} \Big]$$
<p>则称 $x$ 为服从正态分布的随机变量，也称高斯随机变量。</p>
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E9%AB%98%E6%96%AF%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F.PNG"/></div><br>
<p>性质</p>
<ul>
<li>对称于直线 $x=a$；</li>
<li>在 $(-\infty, a)$ 内单调上升，在 $(a, +\infty)$ 内单调下降，且在 a 点处达到极大值；</li>
<li>
$\int^{\infty}_{-\infty}f(x)\mathrm{d}x = 1$，$\int^{\infty}_{a}f(x)\mathrm{d}x = \int^{a}_{-\infty}f(x)\mathrm{d}x = \dfrac{1}{2}$
</li>
<li>$a$ 表示分布中心，$\sigma$ 表示集中的程度，$\sigma$ 减小使得 $f(x)$ 变得高窄。</li>
</ul>
<h4 id="正态分布函数与误差函数"><a class="header-anchor" href="#正态分布函数与误差函数">¶</a>正态分布函数与误差函数</h4>
<p>正态分布函数的一般表示式为</p>
$$F(x) = \int^{x}_{-\infty}f(z)\mathrm{d}z = \int^{x}_{-\infty}\dfrac{1}{\sqrt{2\pi} \sigma} \exp\Big[ -\dfrac{(x - a)^2}{2\sigma^2} \Big]\mathrm{d}z$$
<p>误差函数（可补充）</p>
<h3 id="平稳随机过程通过线性系统"><a class="header-anchor" href="#平稳随机过程通过线性系统">¶</a>平稳随机过程通过线性系统</h3>
<p>设 $X(t)$ 是平稳的输入随机过程，其均值为 $a_X$，其自相关函数为 $R_X(\tau)$，其功率谱密度为 $P_X(\omega)$，通过线性系统，输出过程 $Y(t)$，有</p>
$$Y(t) = X(t) * h(t) = \int^{\infty}_{-\infty}h(\tau)X(t-\tau)\mathrm{d}\tau$$
<ul>
<li>
<p>$Y(t)$ 的均值：<br>
$E[Y(t)] = a_XH(0) = a_Y$（输入过程均值与系统直流增益的乘积，与 $t$ 无关）</p>
</li>
<li>
<p>$Y(t)$ 的相关函数：<br>
$R_Y(t, t+\tau) = R_Y(\tau)$（即 $Y(t)$ 平稳）</p>
</li>
<li>
<p>$Y(t)$ 的功率谱密度：<br>
$P_Y(\omega) = |H(\omega)|^2 P_X(\omega)$</p>
</li>
<li>
<p>$Y(t)$ 的概率分布函数：</p>
</li>
</ul>
$Y(t) = \lim\limits_{\Delta \tau_k \rightarrow 0} \sum^{\infty}_{k=-\infty} h(\tau_k) X(t-\tau_k)\Delta\tau_k$
<p>（高斯过程经过线性变换后认为高斯过程）</p>
<h3 id="窄带随机过程"><a class="header-anchor" href="#窄带随机过程">¶</a>窄带随机过程</h3>
<p>（可补充）</p>
<h3 id="正弦波加窄带高斯噪声"><a class="header-anchor" href="#正弦波加窄带高斯噪声">¶</a>正弦波加窄带高斯噪声</h3>
<p>（可补充）</p>
<h3 id="高斯白噪声和带限白噪声"><a class="header-anchor" href="#高斯白噪声和带限白噪声">¶</a>高斯白噪声和带限白噪声</h3>
<h4 id="白噪声"><a class="header-anchor" href="#白噪声">¶</a>白噪声</h4>
<p>凡功率谱密度在整个频域内都是均匀分布的噪声，称为白噪声。<br>
只要噪声的功率谱均匀分布的频率范围远大于通信系统的工作频带，就可视为白噪声。</p>
<ul>
<li>双边谱密度：$P_n(\omega) = \dfrac{n_0}{2}~~~~~~~~(-\infty&lt; \omega &lt;+\infty)$</li>
<li>单边谱密度：$P_n(\omega) = n_0~~~~~~~~~(0&lt; \omega &lt;+\infty)$</li>
</ul>
<p>其中：$n_0$ 为常数，$\text{W/Hz}$。一般默认白噪声为平稳的。</p>
<p>自相关函数：$P_n(\omega) = \dfrac{n_0}{2}\leftrightarrow R_n(\tau) = \dfrac{n_0}{2}\delta(\tau)$（互为傅氏变换对）</p>
<p>平均功率：$R(0) = \dfrac{n_0}{2}\delta(0) = \infty$</p>
<h4 id="高斯白噪声"><a class="header-anchor" href="#高斯白噪声">¶</a>高斯白噪声</h4>
<p>在通信系统的抗噪声性能分析时，常把通信信道中的噪声源视为高斯白噪声。<br>
高斯白噪声是指噪声取值的概率密度函数满足正态分布统计特性，同时它的功率谱密度函数是常数的一类噪声。</p>
<h4 id="带限白噪声"><a class="header-anchor" href="#带限白噪声">¶</a>带限白噪声</h4>
<p>带限白噪声指白噪声功率被限制在一定范围的噪声</p>
<h5 id="低通白噪声"><a class="header-anchor" href="#低通白噪声">¶</a>低通白噪声</h5>
<p>白噪声经理想低通滤波器或理想低通信道后而形成的噪声，被称为低通白噪声。</p>
<p>功率谱密度：</p>
$$
P_n(\omega) =
\begin{cases}
\dfrac{n_0}{2}, & |\omega| \le \omega_H\\
0, & \text{else}
\end{cases}
$$
<p>自相关函数：对 $P_n(\omega)$ 取傅里叶变换：$R(\tau)=n_0 f_H Sa(\omega_H\tau)$</p>
<p>低通白噪声的功率：$N = R(0) = n_0 f_H = n_0 B$</p>
<h5 id="带通白噪声"><a class="header-anchor" href="#带通白噪声">¶</a>带通白噪声</h5>
<p>如果白噪声通过理想矩形的带通滤波器或理想带通信道，则其输出的噪声称为带通白噪声。</p>
<p>设理想带通滤波器的传输特性为</p>
$$
H(f) =
\begin{cases}
1, & f_c - \dfrac{B}{2} \le |f| \le f_c + \dfrac{B}{2}\\
0, & \text{else}
\end{cases}
$$
<p>式中：$f_c$－中心频率，$B$－通带宽度。</p>
<p>则带通白噪声的功率谱密度为</p>
$$
P_n(\omega) =
\begin{cases}
\dfrac{n_0}{2}, & f_c - \dfrac{B}{2} \le |f| \le f_c + \dfrac{B}{2}\\
0, & \text{else}
\end{cases}
$$
<p>自相关函数：$R(\tau) = n_0 B \cdot Sa \pi B \tau \cdot cos\omega_c\tau$</p>
<p>带通白噪声的功率：$N=R(0)=n_0 B$</p>
<p>理想低通与理想带通皆为线性系统，当输入的白噪声为高斯型时，其输<br>
出也必为高斯的，且均值为 $0$，方差为 $n_0 B$。</p>
<h2 id="信道与噪声"><a class="header-anchor" href="#信道与噪声">¶</a>信道与噪声</h2>
<blockquote>
<p>考察重点: 待定<br>
勿忘求相频特性的方法</p>
</blockquote>
<h3 id="信道"><a class="header-anchor" href="#信道">¶</a>信道</h3>
<p>通俗地说，信道是指以传输媒介为基础的信号通路，可大体分成狭义信道和广义信道。</p>
<h4 id="调制信道模型"><a class="header-anchor" href="#调制信道模型">¶</a>调制信道模型</h4>
<p>调制信道即传输已调信号的信道。</p>
<p>可用一个二对端（或多对端）的时变线性网络来表示调制信道，</p>
$$e_0 (t) = k(t) \cdot e_i(t) + n(t).$$
<p>信道对信号的影响可归纳为两点：一是乘性干扰 $k(t)$，二是加性干扰（噪声） $n(t)$。不同特性的信道，仅反映信道模型有不同的 $k(t)$ 及 $n(t)$。</p>
<p>根据信道中 $k(t)$ 的特性不同，可以将信道分为：</p>
<ul>
<li>恒参信道: $k(t) \sim t$ 不变或慢变；</li>
<li>变参信道（随参信道）: $k(t) \sim t$ 随机快变。</li>
</ul>
<h3 id="恒参信道及其对所传信号的影响"><a class="header-anchor" href="#恒参信道及其对所传信号的影响">¶</a>恒参信道及其对所传信号的影响</h3>
<p>恒参信道可以等效为一个线性时不变网络。</p>
<p>网络的传输特性：$H(\omega) = |H(\omega)|e^{j\varphi(\omega)}$</p>
<p>信号不失真传输条件</p>
<p>要使任意一个信号通过线性网络不产生波形失真，网络的传输特性应该具备以下两个理想条件：</p>
<ul>
<li>网络的幅频特性 $|H(\omega)|$ 是一个不随频率变化的常数；</li>
<li>网络的相频特性 $\varphi(\omega)$ 应与频率成负斜率直线关系。其中 $t_0$ 为传输时延常数。</li>
</ul>
<p>网络的相频特性还常采用群迟延-频率特性 $\tau(\omega)$ 来衡量，有</p>
$$\tau(\omega) = \dfrac{\mathrm{d}\varphi(\omega)}{\mathrm{d} \omega}$$
<div align=center><img width = '' height ='' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E9%80%9A%E4%BF%A1/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%90%86%E6%83%B3%E4%B8%8D%E5%A4%B1%E7%9C%9F.PNG"/></div><br>
<p>随参信道及其对所传信号的影响<br>
一般的多径传播 信号带宽（可补充）</p>
<h3 id="信道容量"><a class="header-anchor" href="#信道容量">¶</a>信道容量</h3>
<p>在信息论中，称信道无差错传输信息的最大信息速率为信道容量，记之为 $C$。</p>
<p>假设连续信道的加性高斯带限白噪声功率为 $N（\text{W}）$，信道的带宽为 $B（\text{Hz}）$，信号功率为 $S（\text{W}）$，则该信道的信道容量 $C$ 为：</p>
$$C = B\log_{2}(1 + \dfrac{S}{N}) = B\log_2(1 + \dfrac{S}{n_0 B})~~~~(\text{bit/s})$$
<p>其中：<br>
$n_0$：高斯白噪声的单边功率谱密度 $(\text{W/Hz})$；<br>
$S/N$：存在于信道中的信噪比。</p>
<p>关于香农公式的几点讨论（可补充）</p>
<h2 id="模拟调制系统"><a class="header-anchor" href="#模拟调制系统">¶</a>模拟调制系统</h2>
<h3 id="幅度调制的原理"><a class="header-anchor" href="#幅度调制的原理">¶</a>幅度调制的原理</h3>
<p>常规双边带调幅（AM, Amplitude Modulation）<br>
抑制载波的双边带调幅（DSB-SC，Double Side-Band-Suppressed Carrier）<br>
单边带调制（SSB，Single Side Band）<br>
残留边带调制（VSB）</p>
<h1>To Be Continued…</h1>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>通信原理与技术</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驶员考试科目三攻略</title>
    <url>/2021/01/18/%E9%A9%BE%E8%80%83%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<h1>2020.1.14</h1>
<h2 id="科三必过"><a class="header-anchor" href="#科三必过">¶</a>科三必过</h2>
<p>马上就要再考科目三了，今天整理一下科目三的要点，算作回顾与总结吧，上次挂科目三实在是大意了，犯了一些教练多次提到的错误点，有些东西还是要先想明白的，行稳致远嘛</p>
<h1>2020.1.15</h1>
<h2 id="qwq过了过了"><a class="header-anchor" href="#qwq过了过了">¶</a>qwq过了过了</h2>
<p>虽然安全员很坑，但是本人技术过硬（教练夸的 PS：高情商：还是教练教的好，低情商：都第二次了还能不硬吗qwq），操作还是有的，最后过了是真的舒服<br>
只不过这考场的系统属实带点nt，考完科三一堆人在科四考场旁边干等着，但是大部分人科三成绩没有录入系统，交不了钱，于是就考不了科四<br>
本人迫切地想拿证，于是从九点多等到十一点多科四考场工作人员下班，最后系统还是显示本人科三未通过，无法缴费，今天星期五，那么只能过三天再来了</p>
<h1>2020.1.18</h1>
<h2 id="拿证了"><a class="header-anchor" href="#拿证了">¶</a>拿证了</h2>
<p>拿到驾驶证也许是另一种意义上的成年吧<a id="more"></a></p>
<h1>机动车驾驶人考试科目三</h1>
<p>这里按照流程来</p>
<h2 id="上车起步"><a class="header-anchor" href="#上车起步">¶</a>上车起步</h2>
<p>开始时，考生在上车后，与安全员确认本次考试开始，然后确认安全后下车来到考车外面，注意把门关好<br>
首先需要绕考车一周，从车的左后方开始，按逆时针方向走到车的左前方，即驾驶座的车门位置<br>
在走的过程中，依次按下考车左后方、右后方、右前方、左前方的车身上的按钮，听到响声即为按下动作有效，最后左前方的按钮按下不会发出响声<br>
在做完这一系列动作后，上车坐在驾驶座，同样注意把门关好<br>
上车后马上系好安全带，接下来可以稍微调整一下座椅，特别是要保证离合踩得舒服，这是避免熄火的一个点，<br>
然后按照考试指令，启动发动机，拿住钥匙向下拧到底，听到发动机响声就松手<br>
灯光考试开始，首先总是开启前照灯，这时要把转向灯没回的回了，远光灯没回的打成近光灯<br>
然后通过电脑播报的题目进行答题</p>
<div align=left><img width = '600' height ='320' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/%E6%97%A5%E5%BF%97/%E7%81%AF%E5%85%89%E8%80%83%E8%AF%95.png"/></div>
<p>命令与其对应操作：<br>
请打开前照灯：打开灯光（如果是远光灯须回到近光）<br>
夜间同方向近距离跟车行驶：开启近光灯<br>
夜间通过有信号灯路口：开启近光灯<br>
夜间与机动车会车：开启近光灯<br>
进入照明良好道路：开启近光灯<br>
进入照明不良道路：开启远光灯<br>
夜间通过急弯、坡路、拱桥、人行横道：交替使用远近灯光<br>
夜间没有交通信号灯指示的路口：交替使用远近灯光<br>
夜间超越前方车辆：交替使用远近灯光<br>
夜间在路边临时停车：开启警示灯，大灯换示廓灯<br>
灯光考试结束后，听到指令，关闭所有灯光<br>
然后听到请立即起步的指令<br>
这时可按照以下顺序进行操作：<br>
检查安全带是否系好、检查座椅是否还需要调整、离合器与刹车均踩到底、打左转向灯、挂一档、放手刹<br>
做完上述动作后，观察车辆周遍情况，确认安全后开始抬离合器<br>
一定注意，慢慢地抬离合器，避免熄火，抬到大约临界点时，车身抖动，此时慢慢松刹车，2~3秒后成功起步<br>
起步即可向左打一点方向盘，此时可选择保持在当前车道，回左转向灯，也可选择向左侧车道变道，中间保持左转向灯<br>
上述选择与前方有无障碍、考试路径等有关</p>
<h2 id="挂档变速"><a class="header-anchor" href="#挂档变速">¶</a>挂档变速</h2>
<p>一档只能够走100米，二档也有距离限制，这要求我们不能长时间保持低档位，在能够做到的条件下，需要将低档位换成高档位<br>
也就是说全程主要以三档为主，如果将要超过距离而未能提高档位，可以停车重新起步，此时低档位走过的距离会重新开始计算<br>
一档在大约15千米每小时的时候进二档，二档在大约25千米每小时的时候进三档，同样，三党在大约35千米每小时的时候可以进四档，也就是逢五进档<br>
在考试全程中，必须要自己控制进一次四档，并且达到45到50的速度，这算一次动作，注意不要超过60码，如果在考试全程三千米内没有进入过四档，则判定考试不合格<br>
在进入四档后，如果离十字路口还有一长段距离，就可以从容的松油门轻踩刹车减速，并降档为三档<br>
如果没有时间降档，则开至隔十字路口停止线或前车一段距离时，稍重刹车减速，并在只有一小段距离时，将离合器刹车踩到底后滑动一段距离停车<br>
上述描述中的时间与距离都需要自己把控好，原则上是做不到就停车<br>
与前车距离过近，而前车速度过慢，来不及降档，也需要直接停车<br>
注意不要因为考试紧张挂档时不踩离合器<br>
如果按要求逢五进档，并且三档不要低于20码，基本是不会出现速度与档位不匹配的情况</p>
<h2 id="考试路线"><a class="header-anchor" href="#考试路线">¶</a>考试路线</h2>
<p>在考试路线中，有P的标志，表示公交车站，此时要注意，在车头经过P标志后三秒，需要点一下刹车，也可以通过与地上画的线的距离来判断何时点刹车<br>
同样在考试路线中有人行横道时需提前点刹车，一般是在经过停止线的前面的方向标志时点刹车，十字路口的时候也要注意点刹车<br>
当看到学校标志时，需要保持速度不高于30码，超出了速度要提前点刹车，做不到就停车<br>
在快要到十字路口的时候，提前想好自己要往哪个方向去，从而判断应该走哪个车道，是否需要变更车道<br>
在十字路口停车后，注意该打转向灯则打转向灯，将档位回到原位，并挂一档准备起步<br>
如果是左转弯，起步后需要在一挡上加一点油，保持大约10到15码进行左转弯，同时注意后方是否有要超车的车辆，左右两边是否有车辆要过<br>
如果做不到正常行驶就停车，注意不要停在人行横道上，如正常转弯，则注意直接一挡转弯与中心点保持一定距离转弯，转弯后优先走中间车道<br>
如果是右转弯，则不需要看红绿灯，起步后保持一档右转，注意不要压线<br>
在转弯过程中，如果转向灯回了，需要将其再打上<br>
如果需要掉头，则分两种情况，如果车道左边的双黄线全是实线，则观察是否有红绿灯<br>
无红绿灯且可以通行的情况下则直接起步，有红绿灯等待左边红绿灯变绿后起步<br>
起步后保持一档，待肩膀通过人行横道末端后三秒，根据实际情况将方向盘向左打死，或者向左打一圈半<br>
如果车到左边的双黄线是一实一虚，则无需等待红绿灯，与停止线保持一定距离时即可直接将方向盘向左打死起步<br>
注意，掉头时保持左转向灯，并且在掉头后不能够直接向左变更车道</p>
<h2 id="安全员按的动作"><a class="header-anchor" href="#安全员按的动作">¶</a>安全员按的动作</h2>
<p>安全员能够按的动作有，会车，直线行驶，变更车道，超车，以及最后的靠边停车<br>
听到会车指令时，点一下刹车即可，注意不要因为会车点刹车将三档时的速度降至20以下，这样会导致速度与档位不匹配<br>
听到保持直线这需要行驶指令时，在三挡将由油门加至35码至40码左右松油，并且将方向盘握稳，保持直线行驶<br>
感觉有偏移可以小幅度进行微调，不可大幅度打方向盘，这也需要我们考试时在车道内行驶尽量走中间，也就是人坐在靠左1/3车道宽处<br>
听到变更车道指令时，根据实际情况，向左向右变更车道，首先要打对转向灯，在转向灯亮三秒后，通过左右后视镜观察左右情况<br>
确认安全后打方向盘变更车道，变更车道完成后关闭转向灯<br>
注意，方向盘的幅度不要打的太大，不能够连续变更车道，自己变更车道的时候也要注意上述要点<br>
当听到超车指令时，打左转向灯，向左变更车道，然后打右转向灯，变更回原车道，一定要在确认安全的情况下完成该动作<br>
在完成变更车道和超车动作时应稳住油门，保持速度，超车可以适当加速<br>
注意，超车动作和变更车道动作都有完成距离限制<br>
在行驶里程超过三千米，且符合靠边停车条件时，安全员会按下靠边停车指令，此时需要立即打右转向灯，并且减速停车，重新挂一档起步<br>
在确认右侧安全后，起步并向右打方向，并适当向左调整，根据车道的宽度不同，判断方向盘的中心点应该对准哪个位置<br>
如果是最窄的车道，没有两根白色实线，则将方向盘的中心点对准车道中央<br>
如果是略宽的车道，有两根白色实线，则需将人坐在中间白色实线左侧一点<br>
如果是最宽的车道，则需将人坐在中间白色实线上<br>
对准上述位置后，将车摆正，并略微向右边靠一点后停车，看后视镜，观察右后轮胎与右侧白色实线的距离<br>
若宽，向右打一点方向后保持半联动状态走3秒，再向左稍微打一点使车摆正后停车，若还宽则还可以采用上述步骤<br>
如果车未摆正，一般是向右偏，而看后视镜感到宽，则无需打方向保持半联动状态走三秒后向左打一点方向<br>
如果感觉宽窄合适，则空档，拉手刹，熄火，松安全带，下车关门完成考试<br>
注意，靠边停车全程需要打右转向灯，如果转向灯停止需补回</p>
<h2 id="一些复杂的情况"><a class="header-anchor" href="#一些复杂的情况">¶</a>一些复杂的情况</h2>
<p>安全员可能在你遇到P标志时按动作，比如按下超车或变更车道<br>
也有可能在你进四档的时候按这些动作，一定要沉着冷静，先打好转向灯，然后看情况做出对应的操作完成<br>
如果做不到就停车重新起步<br>
如果在进四档后需要做直线行驶，一定要握稳方向盘，若偏离原来行驶方向一定要微调<br>
也有可能在你已进入左转车道准备前方的左转时，按下变更车道，你需要在有限的条件下，向右变更车道，再变回左侧车道<br>
如果做不到就停车，重新起步后变更车道<br>
总之总之总之，一些地方没有要求立即做的，做不到就停车</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM-微控制器与接口技术代码分析</title>
    <url>/2020/11/24/ARM-%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1>ARM-微控制器与接口技术代码分析</h1>
<h2 id="基于-open-1768-的单片机实验代码分析"><a class="header-anchor" href="#基于-open-1768-的单片机实验代码分析">¶</a>基于 open 1768 的单片机实验代码分析</h2>
<h3 id="open-1768-的硬件资源"><a class="header-anchor" href="#open-1768-的硬件资源">¶</a>open 1768 的硬件资源</h3>
<h4 id="硬件资源图示"><a class="header-anchor" href="#硬件资源图示">¶</a>硬件资源图示</h4>
<div align=left><img width = '630' height ='540' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/2.png"/></div>
<h4 id="【芯片简介】【1】-LPC1768"><a class="header-anchor" href="#【芯片简介】【1】-LPC1768">¶</a>【芯片简介】【1】 LPC1768</h4>
<p>以下为 LPC1768FBD100 的核心资源参数：<br>
内 核：Cortex-M3 32-bit RISC；<br>
工作频率：100MHz Max；<br>
工作电压：2.4-3.6V；（3.3V 典型值）<br>
封 装：LQFP100；<br>
I/O 口：70；<br>
存储资源：512kB Flash，64kB RAM；<br>
接口资源：2 x SPI，2 x SSP，4 x UART，3 x I2C，1 x I2S，6 x PWM，8 x ADC，1 x DAC；<br>
调试下载：可通过 SWD 接口实现调试下载，可通过 UART接口实现 ISP。<a id="more"></a></p>
<h4 id="【其他接口与器件】"><a class="header-anchor" href="#【其他接口与器件】">¶</a>【其他接口与器件】</h4>
<p>仅介绍与实验有关的接口与器件</p>
<p>【6】用户 LED ：便于 I/O 输出测试或显示程序运行状态<br>
【25】8I/Os 接口（含 3 路 AD、1 路 DA）：方便接入各类使用 I/O 控制的模块。 如 8 位按键模块，电机控制模块等。 同时，该接口具备了 AD/DA 功能，可以方便 AD/DA 测试<br>
【26】ISP 接口（含 UART0 接口）：方便接入 ISP 模块或使用 UART 接口的器件。 如 RS232、RS485、USB TO UART 模块等<br>
【27】USB 接口：可与 PC 机进行 USB 通信<br>
【28】5V DC 接口</p>
<h3 id="单片机上的位操作"><a class="header-anchor" href="#单片机上的位操作">¶</a>单片机上的位操作</h3>
<p>一般单片机不能够直接对寄存器的某一位进行操作，这时就需要通过一些间接的手段，即对所有位都进行操作，但是只改变某一位的值，对其他位没有影响</p>
<h4 id="从-C-语言的位操作说起"><a class="header-anchor" href="#从-C-语言的位操作说起">¶</a>从 C 语言的位操作说起</h4>
<p>首先得说明以下操作：</p>
<p>我们知道 C 语言的位操作，<code>|</code>【位或】<code>&amp;</code>【位与】<code>~</code>【位取反】<code>^</code>【位异或】<code>&lt;&lt;</code>【位左移】<code>&gt;&gt;</code>【位右移】</p>
<p>那么下面这些操作也顺理成章</p>
<p><code>|=</code>：【按位 “或” 后取值】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0x02</span>;</span><br><span class="line">x |= <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>
<p>0x 在 C 语言中表示这个数是一个十六进制数，我们将其转换为二进制数进行运算，一个十六进制位即对应四个二进制位<br>
0x02 即 00000010<br>
0x01 即 00000001<br>
两个数进行 “或” 操作后，结果应为 00000011，即 0x03<br>
我们看到，对 x 与 0x01 进行【按位 “或” 后取值】的操作后，相当于将 x 这个八位二进制数的最右边的一个二进制位，置为 “1”</p>
<p><code>&amp;=</code>：【按位 “与” 后取值】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0x02</span>;</span><br><span class="line">x &amp;= <span class="number">0xFD</span>;</span><br></pre></td></tr></table></figure>
<p>十六进制中的 A~F（或 a~f）表示 1001(2) ~ 1111(2)，即 9(10) ~ 15(10)<br>
0x02 即 00000010<br>
0xFD 即 11111101<br>
两个数进行 “与” 操作后，结果应为 00000000，即 0x00<br>
我们看到，对 x 与 0xFD 进行【按位 “与” 后取值】的操作后，相当于将 x 这个八位二进制数的从右往左数的的第二个二进制位，置为 “0”</p>
<p><code>^=</code>：【按位 “异或” 后取值】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0x03</span>;</span><br><span class="line">x ^= <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>
<p>0x03 即 00000011<br>
0x01 即 00000001<br>
两个数进行 “异或” 操作后，结果应为 00000010，即 0x02<br>
我们看到，对 x 与 0x01 进行【按位 “异或” 后取值】的操作后，相当于对 x 这个八位二进制数的最右边的一个二进制位，取反</p>
<p>这样，我们就有了对单片机上的寄存器进行位操作的方法</p>
<h4 id="间接位操作"><a class="header-anchor" href="#间接位操作">¶</a>间接位操作</h4>
<p>下面以 GPIO 端口方向寄存器 FIOxDIR 和 GPIO 管脚值寄存器 FIOxPIN 为例做演示，FIOxDIR 是一个32位的寄存器，作用是设定 GPIO 的方向，FIOxPIN 也是一个32位的寄存器，可以通过它获取管脚当前的电平状态<br>
注：FIOxDIR 中的 x 即控制的引脚 Px.n 中的 x，FIOxPIN 同理</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>32个二进制位</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIOxDIR</td>
<td>Bit31 Bit30 Bit29 … Bit1 Bit0</td>
</tr>
<tr>
<td>FIOxPIN</td>
<td>Bit31 Bit30 Bit29 … Bit1 Bit0</td>
</tr>
</tbody>
</table>
<h5 id="写位操作"><a class="header-anchor" href="#写位操作">¶</a>写位操作</h5>
<p>置 1 使用 <code>|=</code> 操作，即按位 “或” 后取值</p>
<p>例如，我们需要设置 GPIO 方向，P0.0 为输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIO0DIR |= <span class="number">0x00000001</span>;</span><br></pre></td></tr></table></figure>
<p>若是将 <code>0x00000001</code> 进行宏定义，程序将更加简洁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     BIT0        0x00000001</span></span><br></pre></td></tr></table></figure>
<p>上面设置 GPIO 方向的操作可写为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIO0DIR |= BIT0;</span><br></pre></td></tr></table></figure>
<p>可以使用加法进行批量操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     BIT0        0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>     BIT4        0x00000010</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIO0DIR |= BIT0 + BIT4;</span><br></pre></td></tr></table></figure>
<p>置 0 使用 <code>&amp;= ~</code> 操作，即取反后再按位 “或” 然后取值</p>
<p>可以直接使用 <code>&amp;=</code> 操作吗，可以的，但是为了可以与置 1 操作共用宏定义，使用 <code>&amp;= ~</code> 更巧妙</p>
<p>例如，我们需要设置 GPIO 方向，P0.0 为输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIO0DIR &amp;= <span class="number">0xFFFFFFFE</span>;          <span class="comment">// 用 '&amp;=' 置0</span></span><br><span class="line">FIO0DIR &amp;= ~<span class="number">0x00000001</span>;         <span class="comment">// 用 '&amp;= ~' 置0</span></span><br><span class="line">FIO0DIR &amp;= ~BIT0;               <span class="comment">// 共用宏定义</span></span><br></pre></td></tr></table></figure>
<p>取反使用 <code>^=</code> 操作，即按位 “异或” 后取值</p>
<p>反转 P0.0 的 GPIO 方向</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIO0DIR ^= <span class="number">0x00000001</span>;</span><br><span class="line">FIO0DIR ^= BIT0;</span><br></pre></td></tr></table></figure>
<p>这里要顺便补充一下左移 <code>&lt;&lt;</code> 和右移 <code>&gt;&gt;</code><br>
操作的时候要考虑有符号数（signed number）和无符号数（unsigned number）的区别<br>
对于有符号数：左移的时候右侧补0；右移的时候左侧补符号位（正数符号位为0，则补0；负数符号位为1，则补1）<br>
对于无符号数：左移的时候右侧补0；右移的时候左侧也是补0</p>
<h5 id="读位操作"><a class="header-anchor" href="#读位操作">¶</a>读位操作</h5>
<p>如果我们想要通过 FIO0PIN 获取 P0.0 的当前电平状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PinStat = FIO0PIN &amp; <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>
<p>利用 <code>&amp;</code> 操作的性质将其他位都置为 0，对应 P0.0 的那一位为其当前电平状态</p>
<h3 id="实验一及GPIO简介"><a class="header-anchor" href="#实验一及GPIO简介">¶</a>实验一及GPIO简介</h3>
<h4 id="GPIO简介"><a class="header-anchor" href="#GPIO简介">¶</a>GPIO简介</h4>
<p>GPIO是通用型输入/输出（General Purpose I/O）的简称，主要用于工业现场需要用到数字量输入/输出的场合，例如：<br>
继电器、 LED、蜂鸣器等的控制<br>
传感器状态、高低电平等信息的输入等</p>
<h4 id="GPIO特性描述"><a class="header-anchor" href="#GPIO特性描述">¶</a>GPIO特性描述</h4>
<h5 id="I-O结构"><a class="header-anchor" href="#I-O结构">¶</a>I/O结构</h5>
<div align=left><img width = '300' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/3.png"/></div>
<ul>
<li>大部分GPIO为推挽输出，具有完整I2C功能的是开漏结构</li>
<li>正常拉出灌入电流为4mA，短时间极限值40mA；</li>
</ul>
<h5 id="通用输入输出"><a class="header-anchor" href="#通用输入输出">¶</a>通用输入输出</h5>
<ul>
<li>LPC1700 系列 Cortex-M3 有 5 组 GPIO，多达 70 个通用 I/O 管脚（100 管脚封装）</li>
<li>所有 GPIO 寄存器位于 AHB 总线上，可以进行高性能的 CPU 快速访问，支持 Cortex-M3 位带操作</li>
<li>可配置为上拉/下拉电阻、开漏和中继模式</li>
<li>GPIO 允许进行 DMA 数据操作</li>
</ul>
<h5 id="中断"><a class="header-anchor" href="#中断">¶</a>中断</h5>
<ul>
<li>LPC1700 系列 Cortex-M3 的 P0 和 P2 还具有中断功能，P0 和 P2 每个引脚都可配置为上升沿、下降沿或边沿中断</li>
</ul>
<h4 id="GPIO输入输出"><a class="header-anchor" href="#GPIO输入输出">¶</a>GPIO输入输出</h4>
<h5 id="I-O-相关寄存器与-I-O-功能框图"><a class="header-anchor" href="#I-O-相关寄存器与-I-O-功能框图">¶</a>I/O 相关寄存器与 I/O 功能框图</h5>
<div align=left><img width = '700' height ='350' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/4.PNG"/></div>
<h6 id="PINSELx-与-PINMODEx"><a class="header-anchor" href="#PINSELx-与-PINMODEx">¶</a>PINSELx 与 PINMODEx</h6>
<p>图中首先涉及到了引脚连接模块中的引脚功能选择寄存器 PINSELx 与 引脚模式选择寄存器 PINMODEx</p>
<p>查用户手册可知：</p>
<div align=left><img width = '600' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/7.PNG"/></div>
<p>仅当引脚选择 GPIO 功能时，GPIO 寄存器中的方向控制位才有效。对于其它功能来说，方<br>
向是自动控制的</p>
<p>接着查到 P0.0 的配置方法：</p>
<div align=left><img width = '600' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/8.PNG"/></div>
<p>PINSEL0 寄存器控制端口 0 低半部分的位功能。仅当引脚选择使用 GPIO 功能时，FIO0DIR<br>
寄存器中的方向控制位才有效。对于其它功能来说，方向是自动控制的</p>
<p>据表可知，要想将 P0.0 设为 GPIO 功能，需要将 PINSEL0 中的 PINSEL0[1:0] 这两位都置零，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PINSEL0 &amp;= <span class="number">0xFFFFFFFC</span>;</span><br></pre></td></tr></table></figure>
<p>关于引脚模式选择寄存器 PINMODEx，这里不作过多解释</p>
<div align=left><img width = '600' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/9.PNG"/></div>
<p>当引脚处于逻辑高电平时，中继模式使能上拉电阻；当引脚处于逻辑低电平时，使能下拉电<br>
阻。当引脚配置为输入且不是通过外部驱动时，引脚将保持上一个已知状态。</p>
<h6 id="FIOxDIR"><a class="header-anchor" href="#FIOxDIR">¶</a>FIOxDIR</h6>
<p>FIOxDIR 为高速 GPIO 端口方向控制寄存器，该寄存器单独控制每个端口引脚的方向</p>
<p>当引脚被配置为 GPIO 功能时，该寄存器可用来控制引脚的方向。勿必根据引脚功能来设置<br>
每个引脚的方向</p>
<table>
<thead>
<tr>
<th>位</th>
<th>符号</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>31:1</td>
<td>FIOxDIR(FIO0DIR ~ FIO4DIR)</td>
<td>0/1</td>
<td>控制的引脚为输入引脚 / 控制的引脚为输出引脚</td>
</tr>
</tbody>
</table>
<h6 id="FIOxMASK"><a class="header-anchor" href="#FIOxMASK">¶</a>FIOxMASK</h6>
<p>不作解释，可查询用户手册</p>
<h6 id="FIOxSET-与-FIOxCLR"><a class="header-anchor" href="#FIOxSET-与-FIOxCLR">¶</a>FIOxSET 与 FIOxCLR</h6>
<table>
<thead>
<tr>
<th>通用名称</th>
<th>描述</th>
<th>复位值</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIOSET</td>
<td>高速端口输出置位寄存器，该寄存器控制输出引脚的状态，写 1 使相应的端口引脚产生高电平，写 0 没有影响</td>
<td>0x0</td>
</tr>
<tr>
<td>FIOCLR</td>
<td>高速端口输出清零寄存器，该寄存器控制输出引脚的状态，写 1 使相应的端口引脚产生低电平。写 0 没有影响</td>
<td>0x0</td>
</tr>
</tbody>
</table>
<h6 id="FIOxPIN"><a class="header-anchor" href="#FIOxPIN">¶</a>FIOxPIN</h6>
<p>高速端口引脚值寄存器，不管引脚方向或可选的功能选择如何，数字端口引脚的当前状态可从该寄存器中读出（只要引脚不配置为 ADC 的 输 入 ）</p>
<h5 id="I-O-操作流程"><a class="header-anchor" href="#I-O-操作流程">¶</a>I/O 操作流程</h5>
<div align=left><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/5.png"/></div>
<div align=left><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/6.png"/></div>
<h5 id="ZLG-操作实例"><a class="header-anchor" href="#ZLG-操作实例">¶</a>ZLG 操作实例</h5>
<h6 id="P0-0输出高电平"><a class="header-anchor" href="#P0-0输出高电平">¶</a>P0.0输出高电平</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PINSEL0 &amp;= <span class="number">0xFFFFFFFC</span>;      <span class="comment">// 设置引脚连接模块，P0.0为GPIO</span></span><br><span class="line">FIO0DIR |= <span class="number">0x00000001</span>;      <span class="comment">// 设置GPIO口方向，P0.0为输出</span></span><br><span class="line">FIO0SET  = <span class="number">0x00000001</span>;      <span class="comment">// 设置输出电平，P0.0为高电平</span></span><br></pre></td></tr></table></figure>
<h6 id="读P0-0管脚电平"><a class="header-anchor" href="#读P0-0管脚电平">¶</a>读P0.0管脚电平</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint32 PinStat;             <span class="comment">// 定义变量</span></span><br><span class="line">PINSEL0 &amp;= <span class="number">0xFFFFFFFC</span>;      <span class="comment">// 设置引脚连接模块，P0.0为GPIO</span></span><br><span class="line">FIO0DIR &amp;= <span class="number">0xFFFFFFFE</span>;      <span class="comment">// 设置GPIO口方向，P0.0为输入</span></span><br><span class="line">PinStat  = FIO0PIN &amp; <span class="number">0x01</span>;  <span class="comment">// 通过FIO0PIN获取P0.0当前电平状态</span></span><br></pre></td></tr></table></figure>
<h4 id="实验一代码分析"><a class="header-anchor" href="#实验一代码分析">¶</a>实验一代码分析</h4>
<h5 id="变量宏定义"><a class="header-anchor" href="#变量宏定义">¶</a>变量宏定义</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_OFF()   FIO0SET |= LED3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_ON()    FIO0CLR |= LED3</span></span><br></pre></td></tr></table></figure>
<p>这里为了方便操作，进行了变量的宏定义，显然 <code>(1 &lt;&lt; 3)</code> 代表将 1 左移 3 位<br>
相当于 <code>LED3</code> 即为 <code>0x00000008</code>，使得 Bit31 ~ Bit0 中的 Bit3 为 1，其余为 0</p>
<p>接着将端口 P0.3 产生高低电平宏定义为端口 P0.3 LED 灯的亮灭，特别注意，此处高电平对应 LED 灯灭，而低电平对应 LED 灯亮</p>
<h5 id="延时函数"><a class="header-anchor" href="#延时函数">¶</a>延时函数</h5>
<p>在跑马灯中，我们想要单片机做一个延时，即延长灯亮灯灭的时间。单片机通常有两种延时方式，分别是软件延时与硬件延时，硬件延时要用到定时器/计数器，这种方法可以提高 CPU 的工作效率，也能做到精确延时；而另一种是软件延时，这种方法主要采用循环体进行，即让单片机在一段时间内做一些空操作，使其在这段时间内输出端口的信号不发生任何的变化。我们这里采用软件延时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDelay</span> <span class="params">(INT32U  ulTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ulTime--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++);       <span class="comment">// 单片机在for循环中不做任何操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="main-函数"><a class="header-anchor" href="#main-函数">¶</a>main 函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;                        <span class="comment">/* 初始化要进行迭代的变量       */</span></span><br><span class="line">    targetInit();                   <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                      <span class="comment">/* 引脚初始化                  */</span></span><br><span class="line">  </span><br><span class="line">    FIO0DIR |= LED0 + LED1 + LED2 + LED3;</span><br><span class="line">                                    <span class="comment">/* 初始化 P0 端口 GPIO 方向    */</span></span><br><span class="line">    LED0_OFF();                     <span class="comment">/* 使 LED 灯在初始状态下全灭    */</span></span><br><span class="line">    LED1_OFF();</span><br><span class="line">    LED2_OFF();</span><br><span class="line">    LED3_OFF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)                       <span class="comment">/* while(1) 使得跑马灯程序一直运行 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)                  <span class="comment">/* 根据 i 的值判断哪个灯该亮，并在 case 中执行 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: LED0_ON();myDelay(<span class="number">50</span>);LED0_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: LED1_ON();myDelay(<span class="number">50</span>);LED1_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: LED2_ON();myDelay(<span class="number">50</span>);LED2_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: LED3_ON();myDelay(<span class="number">50</span>);LED3_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;                        <span class="comment">/* 对 i 进行迭代                  */</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">3</span>) i = <span class="number">0</span>;            <span class="comment">/* 限定 i 的范围                  */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>targetInit()</code> 与 <code>pinInit()</code> 函数在其他文件中进行了宏定义，此处只需知晓其抽象作用即可</p>
<h5 id="实验一完整代码-main-c"><a class="header-anchor" href="#实验一完整代码-main-c">¶</a>实验一完整代码(main.c)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 变量宏定义 ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0        (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_OFF()   FIO0SET |= LED0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_ON()    FIO0CLR |= LED0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1        (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_OFF()   FIO0SET |= LED1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_ON()    FIO0CLR |= LED1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2        (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_OFF()   FIO0SET |= LED2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_ON()    FIO0CLR |= LED2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_OFF()   FIO0SET |= LED3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_ON()    FIO0CLR |= LED3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">** Function name:       myDelay</span></span><br><span class="line"><span class="comment">** Descriptions:        软件延时</span></span><br><span class="line"><span class="comment">** input parameters:    ulTime</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDelay</span> <span class="params">(INT32U  ulTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ulTime--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    targetInit();                   <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                      <span class="comment">/* 引脚初始化                  */</span></span><br><span class="line">  </span><br><span class="line">    FIO0DIR |= LED0 + LED1 + LED2 + LED3;</span><br><span class="line"></span><br><span class="line">    LED0_OFF();</span><br><span class="line">    LED1_OFF();</span><br><span class="line">    LED2_OFF();</span><br><span class="line">    LED3_OFF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: LED0_ON();myDelay(<span class="number">50</span>);LED0_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: LED1_ON();myDelay(<span class="number">50</span>);LED1_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: LED2_ON();myDelay(<span class="number">50</span>);LED2_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: LED3_ON();myDelay(<span class="number">50</span>);LED3_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">3</span>) i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GPIO-中断"><a class="header-anchor" href="#GPIO-中断">¶</a>GPIO 中断</h4>
<p>由于实验中未使用到 GPIO 中断，此处简略地介绍一下</p>
<p>端口 P0 和 P2 引脚具有中断功能，GPIO 管脚的中断寄存器可分为两组：控制寄存器和状态寄存器</p>
<table>
<thead>
<tr>
<th>控制寄存器</th>
<th>状态寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td>上升沿中断使能寄存器 IO0/2IntEnR</td>
<td>上升沿中断状态寄存器 IO0/2IntStatR</td>
</tr>
<tr>
<td>下降沿中断使能寄存器 IO0/2IntEnF</td>
<td>下降沿中断状态寄存器 IO0/2IntStatF</td>
</tr>
<tr>
<td>中断标志清零寄存器 IO0/2IntClr</td>
<td>整体中断状态寄存器 IOIntStatus</td>
</tr>
</tbody>
</table>
<div align=left><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/10.PNG"/></div>
<div align=left><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/11.PNG"/></div>
<br>
<h5 id="操作示例——设置P0-0下降沿中断"><a class="header-anchor" href="#操作示例——设置P0-0下降沿中断">¶</a>操作示例——设置P0.0下降沿中断</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PINSEL0     &amp;=  <span class="number">0xFFFFFFFC</span>;                 <span class="comment">/* 设置引脚连接模块 */</span></span><br><span class="line">PINMODE0    &amp;=  <span class="number">0xFFFFFFFC</span>;</span><br><span class="line">IO0IntEnF   |=  <span class="number">0x01</span>；                      <span class="comment">/* 设置下降沿中断   */</span></span><br><span class="line">ISER0       |=  (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)；                 <span class="comment">/* 使能 GPIO 中断   */</span></span><br><span class="line">zyIrqEnable();                              <span class="comment">/* 打开全局中断     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ISR</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((IO0IntStatF &amp; <span class="number">0x01</span>) != <span class="number">0</span>) &#123;         <span class="comment">/* 判断是否为P0.0下降沿中断 */</span></span><br><span class="line">        IO0IntClr  =  <span class="number">0x01</span>;                 <span class="comment">/* 清除中断标志            */</span></span><br><span class="line">        ......                              <span class="comment">/* 其它代码                */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验二与定时器简介"><a class="header-anchor" href="#实验二与定时器简介">¶</a>实验二与定时器简介</h3>
<h4 id="定时器-计数器概述"><a class="header-anchor" href="#定时器-计数器概述">¶</a>定时器/计数器概述</h4>
<p>定时器/计数器本质上都是加法计数器<br>
定时器是用来对固定周期的脉冲信号计数，如 CPU 内部的外设时钟 (PCLK)<br>
计数器可以对脉冲长度不确定的信号进行计数，如微处理器外部 I/O 引脚的脉冲信号</p>
<h4 id="定时器-计数器特性"><a class="header-anchor" href="#定时器-计数器特性">¶</a>定时器/计数器特性</h4>
<p>注：4 个定时器/计数器，除了外设基址之外完全相同。4 个定时器最少有 2 个捕获输入和 2 个匹配输出，并且有多个引脚可以选择。定时器 2 引出了全部 4 个匹配输出。</p>
<ul>
<li>32 位的定时器/计数器，带有一个可编程的 32 位预分频器；</li>
<li>计数器或定时器操作；</li>
<li>每个定时器包含 2 个 32 位的捕获通道，当输入信号变化时捕捉定时器的瞬时值。也可以选择产生中断；</li>
<li>4 个 32 位匹配寄存器，允许执行以下操作：
<ul>
<li>匹配时连续工作，在匹配时可选择产生中断；</li>
<li>在匹配时停止定时器运行，可选择产生中断；</li>
<li>在匹配时复位定时器，可选择产生中断；</li>
</ul>
</li>
<li>有 4 个与匹配寄存器相对应的外部输出，这些输出具有以下功能：
<ul>
<li>匹配时设为低电平；</li>
<li>匹配时设为高电平；</li>
<li>匹配时翻转电平；</li>
<li>匹配时不执行任何操作。</li>
</ul>
</li>
</ul>
<h4 id="内部结构，功能描述及部分寄存器介绍"><a class="header-anchor" href="#内部结构，功能描述及部分寄存器介绍">¶</a>内部结构，功能描述及部分寄存器介绍</h4>
<p><br><div align=left><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/12.png"/></div></p>
<table>
<thead>
<tr>
<th>通用寄存器名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>IR(TxIR)</td>
<td>中断寄存器。可向 IR 写入相应的值来清除中断。也可读 IR 来确定 8 个中断源中哪个中断源被挂起</td>
</tr>
<tr>
<td>TCR(TxTCR)</td>
<td>定时器控制寄存器。TCR 用来控制定时器计数器功能。定时器计数器可以通过 TCR 来禁能或复位</td>
</tr>
<tr>
<td>PR(TxPR)</td>
<td>预分频寄存器。当预分频计数器的值与这个寄存器的值相等时，下个时钟 TC 加 1，PC 清零</td>
</tr>
<tr>
<td>TC(TxTC)</td>
<td>保存定时器计数器的计数值。32 位的 TC 每隔（PR+1）个 PCLK 周期递增一次。TC 通过 TCR 来控制</td>
</tr>
<tr>
<td>PC(TxPC)</td>
<td>预分频计数器。32 位的 PC 是一个计数器，它会增加到与 PR 中存放的值相等。当达到了 PR 的值时，TC 加 1，PC 清零。可以通过总线接口来观察和控制 PC</td>
</tr>
<tr>
<td>MCR(TxMCR)</td>
<td>匹配控制寄存器。MCR 用来控制在匹配出现时是否产生中断和是否复位 TC</td>
</tr>
<tr>
<td>MR(TxMRx)</td>
<td>匹配寄存器。MR 可通过 MCR 设定为在匹配时复位 TC，停止 TC 和 PC 和/或产生中断</td>
</tr>
<tr>
<td>CCR(TxCCR)</td>
<td>捕获控制寄存器。CCR 控制捕获时捕获输入边沿方式，以及在发生捕获时是否产生中断</td>
</tr>
<tr>
<td>CR(TxCRx)</td>
<td>捕获寄存器。当在 CAP 输入上产生捕获事件时，CR 装载 TC 的值</td>
</tr>
<tr>
<td>EMR(TxEMR)</td>
<td>外部匹配寄存器。EMR 控制外部匹配引脚 MATn.0-3（MAT0.0-3 和 MAT1.0-3）</td>
</tr>
<tr>
<td>CTCR(TxCTCR)</td>
<td>计数控制寄存器。CTCR 选择在定时器模式还是计数器模式工作，在计数器模式中选择计数的信号和边沿</td>
</tr>
</tbody>
</table>
<div align=left><img width = '400' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/16.PNG"/></div>
<h5 id="计数功能模块"><a class="header-anchor" href="#计数功能模块">¶</a>计数功能模块</h5>
<p><br><div align=left><img width = '450' height ='225' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/13.png"/></div></p>
<p>预分频器</p>
<p>定时器/计数器带有一个 32 位可编程预分频器，PC 每经过 PR+1 个 PCLK 周期 TC 就加 1</p>
<p>$定时器的计数频率 = \dfrac{F_{PCLK}}{PR + 1}$</p>
<p><br><div align=left><img width = '450' height ='225' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/14.png"/></div></p>
<p>计数外部脉冲</p>
<p>在计数器模式时，用户可以选择是在输入脉冲的上升沿、下降沿或者是边沿，实现对外部脉冲信号进行计数</p>
<h5 id="匹配功能模块"><a class="header-anchor" href="#匹配功能模块">¶</a>匹配功能模块</h5>
<p>定时器/计数器的当前计数值等于用户设定的“匹配值”时，根据相应设置，触发外部某个功能匹配输出，同时也可以产生中断信号</p>
<p>定时时间 t 与匹配值 MR 的计算关系：$t = \dfrac{MR \times (PR + 1)}{F_{PCLK}}$</p>
<div align=left><img width = '450' height ='225' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/15.png"/></div>
<h5 id="捕获功能模块"><a class="header-anchor" href="#捕获功能模块">¶</a>捕获功能模块</h5>
<p>当定时器/计数器运行时，在捕获引脚上，出现有效外部触发动作，此时定时器计数器的当前值保存到指定捕获寄存器中</p>
<h5 id="部分寄存器用法"><a class="header-anchor" href="#部分寄存器用法">¶</a>部分寄存器用法</h5>
<p>下面用一个定时器0初始化的例程，来说明部分寄存器的用法<br>
这个例程利用定时器0的匹配功能，实现每秒产生一次中断的功能</p>
<h6 id="ZLG-定时器0初始化例程"><a class="header-anchor" href="#ZLG-定时器0初始化例程">¶</a>ZLG 定时器0初始化例程</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time0Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T0TCR  = <span class="number">0x02</span>;                  <span class="comment">/*  定时器不使能，定时器复位     */</span></span><br><span class="line">    T0IR   = <span class="number">1</span>;                     <span class="comment">/*  清除匹配通道0的中断标志      */</span></span><br><span class="line">    T0CTCR = <span class="number">0</span>;                     <span class="comment">/*  定时器模式                  */</span></span><br><span class="line">    T0TC   = <span class="number">0</span>;                     <span class="comment">/*  计数器清零                  */</span></span><br><span class="line">    T0PR   = <span class="number">0</span>;                     <span class="comment">/*  定时器时钟不分频             */</span></span><br><span class="line">    T0MR0  = FPCLK;                 <span class="comment">/*  1s中断一次                  */</span></span><br><span class="line">    T0MCR  = <span class="number">0x03</span>;                  <span class="comment">/*  匹配后产生中断，TC值复位     */</span></span><br><span class="line"></span><br><span class="line">    zyIsrSet(NVIC_TIMER0,           <span class="comment">/*  设置中断并使能              */</span></span><br><span class="line">            (INT32U)timer0Isr,</span><br><span class="line">            PRIO_TWO);</span><br><span class="line">    T0TCR  = <span class="number">0x01</span>;                  <span class="comment">/*  启动定时器                  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="TxTCR-与-TxCTCR"><a class="header-anchor" href="#TxTCR-与-TxCTCR">¶</a>TxTCR 与 TxCTCR</h6>
<p>定时器控制寄存器（TCR）用来控制定时器/计数器的操作，其拥有 0~7 八个二进制位，其中第 0 位为计数器使能位，第 1 位为计数器复位位，描述如下：</p>
<div align=left><img width = '700' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/17.PNG"/></div>
<p>在上面的例程中，先使得定时器不使能、定时器复位，以便对定时器进行配置，在配置完成后即启动定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T0TCR  = <span class="number">0x02</span>;                  <span class="comment">/*  定时器不使能，定时器复位     */</span></span><br><span class="line">......                          <span class="comment">/*  配置过程                    */</span></span><br><span class="line">T0TCR  = <span class="number">0x01</span>;                  <span class="comment">/*  启动定时器                  */</span></span><br></pre></td></tr></table></figure>
<br>
<p>计数控制寄存器（CTCR）也拥有八个二进制位，用来在定时器模式和计数器模式之间进行选择，在计数器模式中选择计数的引脚和边沿</p>
<div align=left><img width = '700' height ='200' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/18.PNG"/></div><br>
<p>我们将其设置为定时器模式，只需使其 0 与 1 两位均为 0 即可</p>
<h6 id="TxIR"><a class="header-anchor" href="#TxIR">¶</a>TxIR</h6>
<p>中断寄存器（IR），拥有八个二进制位，0~3 位对应 MR0~MR3 的中断，即对应匹配通道 0~3 的中断标志，后面还有两位对应捕获中断，如果有中断产生，IR 中的对应位会置位，否则为 0。向对应的 IR 位写入 1 会复位中断。写入 0 无效</p>
<p>在例程中，我们需要使用匹配通道0，所以向对应位写入 1，复位匹配通道0的中断标志</p>
<h6 id="TxTC"><a class="header-anchor" href="#TxTC">¶</a>TxTC</h6>
<p>定时器计数器寄存器（TC）<br>
当预分频计数器到达计数的上限时，32 位 TC 加 1。如果 TC 在到达计数器上限之前没有复位，它将一直计数到 0xFFFF FFFF，然后翻转到 0x0000 0000。该事件不会产生中断，如果需要，可用匹配寄存器检测溢出</p>
<p>在例程中，我们需要将其清零，然后才能够开始计数</p>
<h6 id="TxPR-与-TxPC"><a class="header-anchor" href="#TxPR-与-TxPC">¶</a>TxPR 与 TxPC</h6>
<p>预分频寄存器（PR）<br>
32 位预分频寄存器指定了预分频计数器的最大值，例程中设置为 0<br>
预分频计数器寄存器（PC）<br>
32 位预分频计数器使用某个常量值来控制 PCLK 的分频，再使之输入 TC。预分频计数器<br>
每个 PCLK 周期加 1。当其值到达预分频寄存器中保存的值时，定时器计数器 TC 加 1，预分频计数器在下个 PCLK 周期复位。例如，当 PR＝0 时，定时器计数器每个 PCLK 周期加 1，当 PR＝1 时定时器计数器每 2 个 PCLK 周期加 1，以此类推</p>
<h6 id="TxMRx-与-TxMCR"><a class="header-anchor" href="#TxMRx-与-TxMCR">¶</a>TxMRx 与 TxMCR</h6>
<p>匹配寄存器（TxMRx）<br>
匹配寄存器值连续与定时器计数值相比较。当两个值相等时自动触发相应动作。这些动作<br>
包括产生中断，复位定时器计数器或停止定时器。所执行的动作由 MCR 寄存器控制</p>
<p>匹配控制寄存器（TxMCR）<br>
匹配控制寄存器用来控制发生匹配时所执行的操作</p>
<div align=left><img width = '700' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/19.PNG"/></div><br>
<p>在例程中，我们需要 TC 值与 MR0 值匹配时产生一个中断，且此时 TC 复位，以便进行下一轮计数匹配</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T0MCR  = <span class="number">0x03</span>;                  <span class="comment">/*  匹配后产生中断，TC值复位     */</span></span><br></pre></td></tr></table></figure>
<p>比较关键的是 MR0 值的确定，之前就给出了公式，在了解了这些寄存器的工作原理后，自己推出来应该没有问题</p>
<p>定时时间 t 与匹配值 MR 的计算关系：$t = \dfrac{MR \times (PR + 1)}{F_{PCLK}}$</p>
<p>为了定时一秒，我们将 PR 设为 $0$，将 MR 值设为 $F_{PCLK}$</p>
<p>这样，我们只要再设置中断并使能就完成了定时器0的初始化，使其每一秒产生一个中断</p>
<h4 id="实验二代码分析"><a class="header-anchor" href="#实验二代码分析">¶</a>实验二代码分析</h4>
<h5 id="变量与宏定义"><a class="header-anchor" href="#变量与宏定义">¶</a>变量与宏定义</h5>
<p>与实验一一致</p>
<h5 id="定时器初始化函数"><a class="header-anchor" href="#定时器初始化函数">¶</a>定时器初始化函数</h5>
<p>与上面定时器0的初始化例程基本一致，只是实验要求定时 0.5 秒，只需修改匹配寄存器 MR0 的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T0MR0  = FPCLK / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h5 id="中断处理函数与-main-函数"><a class="header-anchor" href="#中断处理函数与-main-函数">¶</a>中断处理函数与 main 函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T0IR         = <span class="number">0x01</span>;                 <span class="comment">/* 清除中断标志                */</span>  </span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中断处理函数中首先需要干一件非常重要的事，那就是将中断标志清除，即向对应的 IR 位写入 1，复位中断，干了这件事之后，再干其他的</p>
<p>这里利用之前设立的全局变量 <code>flag</code>，将其置为 1 来记录中断的发生，也就是要告诉 main 函数，一个定时周期已经过去了，该干啥干啥，同时在 main 函数中应该将 <code>flag</code> 重新置为 0，以等待下一次中断</p>
<p>main 函数非常之简单，此处略去分析过程</p>
<h5 id="实验二完整代码-main-c"><a class="header-anchor" href="#实验二完整代码-main-c">¶</a>实验二完整代码(main.c)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************* 变量与宏定义 ************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0        (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_OFF()   FIO0SET |= LED0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_ON()    FIO0CLR |= LED0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1        (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_OFF()   FIO0SET |= LED1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_ON()    FIO0CLR |= LED1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2        (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_OFF()   FIO0SET |= LED2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_ON()    FIO0CLR |= LED2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_OFF()   FIO0SET |= LED3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_ON()    FIO0CLR |= LED3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name:        timer0Isr</span></span><br><span class="line"><span class="comment">* Description:          TIMER0 中断处理函数</span></span><br><span class="line"><span class="comment">* Input:                无</span></span><br><span class="line"><span class="comment">* Output:               无</span></span><br><span class="line"><span class="comment">* Return:               无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T0IR         = <span class="number">0x01</span>;                            <span class="comment">/* 清除中断标志                */</span>  </span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       timer0Init</span></span><br><span class="line"><span class="comment">** Descriptions:        定时器0初始化程序</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0Init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T0TCR  = <span class="number">0x02</span>;</span><br><span class="line">    T0IR   = <span class="number">1</span>;</span><br><span class="line">    T0CTCR = <span class="number">0</span>;</span><br><span class="line">    T0TC   = <span class="number">0</span>;</span><br><span class="line">    T0PR   = <span class="number">0</span>;</span><br><span class="line">    T0MR0  = FPCLK / <span class="number">2</span>;                                                 <span class="comment">/* 定时 0.5 秒                 */</span></span><br><span class="line">    T0MCR  = <span class="number">0x03</span>;                                                      <span class="comment">/* 匹配后产生中断               */</span></span><br><span class="line">    zyIsrSet(NVIC_TIMER0, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)timer0Isr, PRIO_TWO);          <span class="comment">/* 设置中断并使能               */</span></span><br><span class="line">    T0TCR  = <span class="number">0x01</span>;                                                      <span class="comment">/* 启动定时器                   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        定时器0中断实验。每1秒产生中断</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line">    timer0Init();                                                       <span class="comment">/* 定时器0初始化                */</span></span><br><span class="line"></span><br><span class="line">    FIO0DIR |= LED0 + LED1 + LED2 + LED3;</span><br><span class="line"></span><br><span class="line">    LED0_OFF();</span><br><span class="line">    LED1_OFF();</span><br><span class="line">    LED2_OFF();</span><br><span class="line">    LED3_OFF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">1</span>)&#123; LED3_OFF(); LED0_ON(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>)&#123; LED0_OFF(); LED1_ON(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span>)&#123; LED1_OFF(); LED2_ON(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">4</span>)&#123; LED2_OFF(); LED3_ON(); &#125;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">4</span>) x=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************* End Of File **********************************************/</span></span><br></pre></td></tr></table></figure>
<h3 id="实验三与UART串口简介"><a class="header-anchor" href="#实验三与UART串口简介">¶</a>实验三与UART串口简介</h3>
<p>第三个实验的程序与第四个实验的程序展开来分析过于复杂，下面基本按照 ZLG 的 PPT 的思路来分析，很多图片也从 PPT 上直接截取</p>
<h4 id="通用异步收发器-UART"><a class="header-anchor" href="#通用异步收发器-UART">¶</a>通用异步收发器(UART)</h4>
<p>通用异步收发器（UART）是实现设备间异步串行通信的关键模块，LPC1700 系列 ARM 具有 4 个符合 16C550 工业标准的异步串口</p>
<ul>
<li>16 字节收发 FIFO；</li>
<li>寄存器的存储单元符合’550 工业标准；</li>
<li>接收器 FIFO 触发点可为 1、4、8 和 14 字节；</li>
<li>内置波特率发生器；</li>
<li>用于精确控制波特率的小数分频器，并拥有赖以实现软件流控制的自动波特率检测能</li>
<li>力和机制；</li>
<li>支持 DMA 发送和接收；</li>
<li>UART3 还包含一种支持红外通信的 IrDA 模式。</li>
</ul>
<p>RS-232是PC机与设备通信里应用最广泛的一种串行接口。它被定义为一种在低速率串行通讯中增加通讯距离的单端标准，由于其最大通信距离的限制，因此它常用于本地设备之间的通信</p>
<p>RS-232特性</p>
<ul>
<li>最高速率约为 20 kb/s</li>
<li>传输最大距离约为 15 m</li>
<li>共模抑制比能力差</li>
</ul>
<p>RS-485是一种常用远距离和多机通信的串行接口。RS-485只是定义电压和阻抗，编程方式和普通串口类似，与RS-232主要区别在于其特性</p>
<p>RS-485特性</p>
<ul>
<li>与 TTL 电平兼容</li>
<li>传输距离实际达 1200 m</li>
<li>共模抑制比能力强</li>
</ul>
<p>LPC1700 系列 ARM 的 UART0/2/3 可以工作在 UART 模式，也可以工作在 IrDA 模式，这里只介绍 UART 模式</p>
<p>下图为结构框图</p>
<div align=left><img width = '500' height ='700' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/21.PNG"/></div><br>
<h4 id="UARTn-部分寄存器映射"><a class="header-anchor" href="#UARTn-部分寄存器映射">¶</a>UARTn 部分寄存器映射</h4>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RBR（UxRBR）（DLAB=0）（只读）</td>
<td>接收缓冲寄存器。内含下一个要读取的已接收字符</td>
</tr>
<tr>
<td>THR（UxTHR）（DLAB=0）（只写）</td>
<td>发送保持寄存器。在此写入下一个要发送的字符</td>
</tr>
<tr>
<td>DLL（UxDLL）（DLAB=1）</td>
<td>除数锁存器 LSB。波特率除数值的最低有效字节</td>
</tr>
<tr>
<td>DLM（UxDLM）（DLAB=1）</td>
<td>除数锁存器 LSM。波特率除数值的最高有效字节。小数分频器是使用整个除数来产生波特率的</td>
</tr>
<tr>
<td>IER（UxIER）（DLAB=0）</td>
<td>中断使能寄存器。包含 7 个独立的中断使能位对应 7 个潜在的 UART1 中断</td>
</tr>
<tr>
<td>IIR（UxIIR）（只读）</td>
<td>中断 ID 寄存器。识别等待处理的中断</td>
</tr>
<tr>
<td>FCR（UxFCR）（只写）</td>
<td>FIFO 控制寄存器。控制 UART1 FIFO 的使用和模式</td>
</tr>
<tr>
<td>LCR（UxLCR）</td>
<td>线控制寄存器。包含帧格式控制和间隔产生控制</td>
</tr>
<tr>
<td>LSR（UxLSR）（只读）</td>
<td>线状态寄存器。包含发送和接收的状态标志（包括线错误）</td>
</tr>
</tbody>
</table>
<p>UARTn接收器缓冲寄存器</p>
<p>UnRBR（[ 7:0 ]）是 UARTn RX FIFO 的最高字节。它包含了最早接收到的字符，并且可通过总线接<br>
口进行读取。LSB（位 0）表示最“早”接收的数据位。如果接收到的字符少于 8 位，未使用<br>
的 MSB 则用 0 填充。<br>
如果要访问 UnRBR，UnLCR 中的除数锁存器访问位（DLAB）必须为 0。UnRBR 为只读<br>
寄存器。</p>
<p>UARTn发送保持寄存器</p>
<p>UnTHR（[ 7:0 ]）是 UARTn TX FIFO 的最高字节。它是 TX FIFO 中的最新字符，可通过总线接口进<br>
行写入。LSB 代表第一个要发送出去的位。<br>
如果要访问 UnTHR，UnLCR 中的除数锁存器访问位（DLAB）必须为 0。UnTHR 为只写<br>
寄存器。</p>
<p>UARTn除数锁存器LSB和UARTn除数锁存器MSB寄存器</p>
<p>UARTn 除数锁存器是 UARTn 波特率发生器的一部分，它与小数分频器一同使用，保持产<br>
生波特率时钟的APB时钟（PCLK）分频值，波特率时钟必须是波特率的16倍。UnDLL和UnDLM<br>
寄存器一起构成了一个 16 位除数，其中 UnDLL 包含了除数的低 8 位而 UnDLM 包含了除数的高 8 位。分频值 0x0000 会被作为 0x0001 处理，因为除数不能为 0。如果要访问 UARTn 除数锁存寄存器，UnLCR 中的除数锁存器访问位（DLAB）必须为 1。</p>
<h4 id="UART-基本操作"><a class="header-anchor" href="#UART-基本操作">¶</a>UART 基本操作</h4>
<h5 id="UART-初始化"><a class="header-anchor" href="#UART-初始化">¶</a>UART 初始化</h5>
<div align=left><img width = '700' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/20.PNG"/></div><br>
<h6 id="手动波特率配置"><a class="header-anchor" href="#手动波特率配置">¶</a>手动波特率配置</h6>
<p>波特率这里只介绍手动波特率</p>
<p>手动波特率配置模式：<br>
UART波特率发生器的时钟源是APB时钟，APB时钟经过16分频后将该值保存在除数锁存寄存器DLM与DLL</p>
<p>目标波特率 $Baud = \dfrac{F_{PCLK}}{16 \times (UnDLM:UnDLL)}$</p>
<p>假设 APB 时钟为 24MHz，UART0 要得到的目标波特率为 9600</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FPCLK 24000000                   <span class="comment">/*  24 MHz                    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  UART_BPS  9600</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">U0LCR  = <span class="number">0x83</span>;                            <span class="comment">/*  允许设置波特率              */</span></span><br><span class="line">ulFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;         <span class="comment">/*  设置波特率                  */</span></span><br><span class="line">U0DLM  = ulFdiv / <span class="number">256</span>;                    <span class="comment">/*  取高 8 位                  */</span></span><br><span class="line">U0DLL  = ulFdiv % <span class="number">256</span>;                    <span class="comment">/*  取低 8 位                  */</span></span><br><span class="line">U0LCR  = <span class="number">0x03</span>;                           <span class="comment">/*  锁定波特率                  */</span></span><br></pre></td></tr></table></figure>
<p>关于 <code>U0LCR</code> 可以看下面的帧格式设置</p>
<p>在 <code>ulFdiv = (FPCLK / 16) / UART_BPS;</code> 中计算结果小数部分被忽略掉，实际的波特率并不准确，为 9615</p>
<p>小数分频器寄存器（UnFDR）可以控制产生波特率的时钟预分频，大大降低了波特率因时钟整数分频所带来的误差，这里不作介绍</p>
<h6 id="帧格式设置"><a class="header-anchor" href="#帧格式设置">¶</a>帧格式设置</h6>
<p>UART通信时需保证收发两端的帧格式一致，否则会出现通信错误</p>
<div align=left><img width = '700' height ='100' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/22.PNG"/></div><br>
<p>UARTn 线控制寄存器 UnLCR 确定了发送或接收数据字符的格式</p>
<div align=left><img width = '700' height ='700' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/23.PNG"/></div><br>
<p>若要求UART0的工作模式为：8位字符长度，1个停止位，无奇偶校验</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U0LCR = <span class="number">0x03</span>;</span><br></pre></td></tr></table></figure>
<p>在手动配置波特率的时候，要先使能访问除数锁存器，即需置 DLAB 为 1，配置波特率完成后，再复位 DLAB</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U0LCR = <span class="number">0x83</span>;                       <span class="comment">/*  允许设置波特率              */</span></span><br></pre></td></tr></table></figure>
<h6 id="FIFO设置"><a class="header-anchor" href="#FIFO设置">¶</a>FIFO设置</h6>
<p>FIFO的初始化比较简单，主要设置包括Rx的触发深度，Tx FIFO与Rx FIFO的复位，以及FIFO的使能</p>
<p>UARTn FIFO控制寄存器 UnFCR 控制 UARTn RX 和 TX FIFO 的操作</p>
<div align=left><img width = '700' height ='700' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/24.PNG"/></div><br>
<p>若要设 UART0 接收缓冲区触发点为 8 字节，同时使能并复位发送和接收 FIFO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U0FCR  = <span class="number">0x87</span>;</span><br></pre></td></tr></table></figure>
<h5 id="UART-数据收发"><a class="header-anchor" href="#UART-数据收发">¶</a>UART 数据收发</h5>
<div align=left><img width = '500' height ='400' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/25.PNG"/></div><br>
<p>在数据收发的过程中，通常采用查询和中断两种方式来进行。它们的基本原理如下：</p>
<ul>
<li>查询方式：通过查询线状态寄存器（UnLSR）来获得数据发送和接收的状态，然后进行相应操作</li>
<li>中断方式：通过中断实现对数据的收发，然后查询中断标志寄存器（UnIIR）来进行不同处理</li>
</ul>
<h6 id="线状态寄存器"><a class="header-anchor" href="#线状态寄存器">¶</a>线状态寄存器</h6>
<p>UARTn 线状态寄存器 UnLSR 是一个只读寄存器，提供 UARTn TX 和 RX 模块的状态信息</p>
<div align=left><img width = '700' height ='150' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/26.PNG"/></div><br>
<div align=left><img width = '700' height ='125' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/27.PNG"/></div><br>
<h6 id="中断-v2"><a class="header-anchor" href="#中断-v2">¶</a>中断</h6>
<p>UARTn 中断使能寄存器 UnIER 用于使能 3 个 UARTn 中断源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U0IER  = <span class="number">0x01</span>;                        <span class="comment">/*  使能接收中断（RDA 中断）       */</span></span><br></pre></td></tr></table></figure>
<p>UnIER [0] 可以使能 UARTn 的接收数据可用中断，它还控制着字符接<br>
收超时中断</p>
<p>UARTn 中断标识寄存器 UnIIR 提供状态代码用于指示一个挂起处理中断的优先级别和中断源。在访问 UnIIR 过程中，中断被冻结。如果在访问 UnIIR 过程中产生了中断，该中断会被记录，下次访问 UnIIR 时可读出该中断</p>
<div align=left><img width = '700' height ='350' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/28.PNG"/></div><br>
<p>判断接收数据可用（发生 RDA 中断）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U0IIR &amp; <span class="number">0x0E</span> == <span class="number">0x04</span></span><br></pre></td></tr></table></figure>
<p>若上式逻辑值为真，则发生了 RDA 中断，同理，判断字符超时的方法为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U0IIR &amp; <span class="number">0x0E</span> == <span class="number">0x0C</span></span><br></pre></td></tr></table></figure>
<p>UARTn RDA 中断（UnIIR[3:1]=010）与 CTI 中断（UnIIR[3:1]=110）共用第二优先级。当<br>
UARTn Rx FIFO 深度到达 U1FCR[7:6]所定义的触发点时，RDA 就会被激活；当 UARTn Rx FIFO深度低于触发点时，RDA 复位。当 RDA 中断激活时，CPU 可读出由触发点所定义的数据块。<br>
CTI 中断（UnIIR[3:1]=110）是一个第二优先级中断，当 UARTn Rx FIFO 内含有至少一个<br>
字符并且在接收到 3.5 到 4.5 字符的时间内没有发生 UARTn Rx FIFO 动作时，该中断激活。任何 UARTn Rx FIFO 动作（UARTn RSR 的读取或写入）将会清除该中断。当接收到的信息不是触发点值的倍数时，CTI 中断将会清空 UARTn RBR。例如：如果外围设备想要发送一个长度为 105 个字符的信息，而触发值为 10 个字符，那么前 100 个字符将使 CPU 接收 10 个 RDA 中断，而剩下的 5 个字符使 CPU 收到 1 到 5 个 CTI 中断（取决于服务程序）。</p>
<h4 id="ZLG-UART0-中断例程与实验三"><a class="header-anchor" href="#ZLG-UART0-中断例程与实验三">¶</a>ZLG UART0 中断例程与实验三</h4>
<p>实验三是在 ZLG UART0 中断例程的基础上进行的改进，增加了一个数组，便于发送，在 uart0Isr 即 UART0 中断函数中要做一些修改</p>
<h5 id="ZLG-UART0-中断例程"><a class="header-anchor" href="#ZLG-UART0-中断例程">¶</a>ZLG UART0 中断例程</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> INT8U        GucRcvNew;                                 <span class="comment">/* 串口接收新数据的标志         */</span></span><br><span class="line"><span class="keyword">extern</span>          INT8U        GucRcvBuf[<span class="number">10</span>] ;                            <span class="comment">/* 串口接收数据缓冲区           */</span></span><br><span class="line"><span class="keyword">extern</span>          INT32U       GulNum;                                    <span class="comment">/* 串口接收数据的个数           */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BPS             9600                                       <span class="comment">/* 串口通信波特率               */</span></span></span><br><span class="line"><span class="keyword">volatile</span>        INT8U        GucRcvNew;                                 <span class="comment">/* 串口接收新数据的标志         */</span></span><br><span class="line">INT8U           GucRcvBuf[<span class="number">10</span>] ;                                         <span class="comment">/* 串口接收数据缓冲区           */</span></span><br><span class="line">INT32U          GulNum;                                                 <span class="comment">/* 串口接收数据的个数           */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       delayNS</span></span><br><span class="line"><span class="comment">** Descriptions:        延时函数</span></span><br><span class="line"><span class="comment">** input parameters:    uiDly:   值越大，延时时间越长</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayNS</span> <span class="params">(INT32U ulDly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; ulDly &gt; <span class="number">0</span>; ulDly--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name:        uart0Isr</span></span><br><span class="line"><span class="comment">* Description:          UART0 中断处理函数</span></span><br><span class="line"><span class="comment">* Input:                None</span></span><br><span class="line"><span class="comment">* Output:               None</span></span><br><span class="line"><span class="comment">* Return:               None</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GulNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((U0IIR &amp; <span class="number">0x01</span>) == <span class="number">0</span>)&#123;                                        <span class="comment">/*  判断是否有中断挂起          */</span></span><br><span class="line">        <span class="keyword">switch</span> (U0IIR &amp; <span class="number">0x0E</span>)&#123;                                          <span class="comment">/*  判断中断标志                */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x04</span>:                                                  <span class="comment">/*  接收数据中断                */</span></span><br><span class="line">                GucRcvNew = <span class="number">1</span>;                                          <span class="comment">/*  置接收新数据标志            */</span></span><br><span class="line">                <span class="keyword">for</span> (GulNum = <span class="number">0</span>; GulNum &lt; <span class="number">8</span>; GulNum++)&#123;                 <span class="comment">/*  连续接收8个字节             */</span></span><br><span class="line">                    GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0C</span>:                                                  <span class="comment">/*  字符超时中断                */</span></span><br><span class="line">                GucRcvNew = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)&#123;                         <span class="comment">/*  判断数据是否接收完毕        */</span></span><br><span class="line">                    GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">                    GulNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uartInit</span></span><br><span class="line"><span class="comment">** Descriptions:        串口初始化，设置为8位数据位，1位停止位，无奇偶校验，波特率为9600</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT16U ulFdiv;</span><br><span class="line"></span><br><span class="line">    U0LCR  = <span class="number">0x83</span>;                                                      <span class="comment">/*  允许设置波特率              */</span></span><br><span class="line">    ulFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;                                   <span class="comment">/*  设置波特率                  */</span></span><br><span class="line">    U0DLM  = ulFdiv / <span class="number">256</span>;</span><br><span class="line">    U0DLL  = ulFdiv % <span class="number">256</span>;</span><br><span class="line">    U0LCR  = <span class="number">0x03</span>;                                                      <span class="comment">/*  锁定波特率                  */</span></span><br><span class="line">    U0FCR  = <span class="number">0x87</span>;                                                      <span class="comment">/*  使能FIFO，设置8个字节触发点 */</span></span><br><span class="line">    U0IER  = <span class="number">0x01</span>;                                                      <span class="comment">/*  使能接收中断                */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendByte</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送子节数据，并等待数据发送完成，使用查询方式</span></span><br><span class="line"><span class="comment">** input parameters:    uiDat:   要发送的数据</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendByte</span> <span class="params">(INT8U ucDat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U0THR = ucDat;                                                      <span class="comment">/*  写入数据                    */</span></span><br><span class="line">    <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x20</span>) == <span class="number">0</span>);                                        <span class="comment">/*  等待数据发送完毕            */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendStr</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字符串</span></span><br><span class="line"><span class="comment">** input parameters:    pucStr:  要发送的字符串指针</span></span><br><span class="line"><span class="comment">**                      ulNum:   要发送的数据个数</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendStr</span> <span class="params">(INT8U <span class="keyword">const</span> *pucStr, INT32U ulNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ulNum; i++) &#123;                                       <span class="comment">/* 发送指定个字节数据            */</span></span><br><span class="line">        uart0SendByte(*pucStr++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        以中断方式接收上位机数据并将接收的数据回送给上位机。短接JP14,借助串口调试软件，</span></span><br><span class="line"><span class="comment">**                      并设置波特率为9600，8位数据位，1位停止位，注意不要选中"HEX显示"</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line"></span><br><span class="line">    GucRcvNew = <span class="number">0</span>;</span><br><span class="line">    uartInit ();                                                        <span class="comment">/* 串口初始化                   */</span></span><br><span class="line"></span><br><span class="line">    zyIsrSet(NVIC_UART0,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)uart0Isr,PRIO_ONE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (GucRcvNew == <span class="number">1</span>)&#123;                                            <span class="comment">/* 判断是否有新数据             */</span></span><br><span class="line">            GucRcvNew = <span class="number">0</span>;                                              <span class="comment">/* 清除标志                     */</span></span><br><span class="line">            uart0SendStr (GucRcvBuf, GulNum);                           <span class="comment">/* 向串口发送数据               */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br></pre></td></tr></table></figure>
<h5 id="实验三完整代码-main-c"><a class="header-anchor" href="#实验三完整代码-main-c">¶</a>实验三完整代码(main.c)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BPS             9600                                       <span class="comment">/* 串口通信波特率               */</span></span></span><br><span class="line"><span class="keyword">volatile</span>        INT8U        GucRcvNew;                                 <span class="comment">/* 串口接收新数据的标志         */</span></span><br><span class="line">INT8U           GucRcvBuf[<span class="number">128</span>];                                         <span class="comment">/* 串口接收数据缓冲区           */</span></span><br><span class="line">INT32U          GulNum = <span class="number">0</span>;                                             <span class="comment">/* 串口接收数据的个数           */</span></span><br><span class="line">INT32U          GucRcvLen;</span><br><span class="line">INT8U           GucProcessBuf[<span class="number">128</span>];</span><br><span class="line">INT8U           GucRcvfinishFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       delayNS</span></span><br><span class="line"><span class="comment">** Descriptions:        延时函数</span></span><br><span class="line"><span class="comment">** input parameters:    uiDly:   值越大，延时时间越长</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayNS</span> <span class="params">(INT32U ulDly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line">    <span class="keyword">for</span> (; ulDly &gt; <span class="number">0</span>; ulDly--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name:        uart0Isr</span></span><br><span class="line"><span class="comment">* Description:          UART0 中断处理函数</span></span><br><span class="line"><span class="comment">* Input:                None</span></span><br><span class="line"><span class="comment">* Output:               None</span></span><br><span class="line"><span class="comment">* Return:               None</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT8U i;</span><br><span class="line">    <span class="keyword">while</span> ((U0IIR &amp; <span class="number">0x01</span>) == <span class="number">0</span>)&#123;                                        <span class="comment">/*  判断是否有中断挂起          */</span></span><br><span class="line">        <span class="keyword">switch</span> (U0IIR &amp; <span class="number">0x0E</span>)&#123;                                          <span class="comment">/*  判断中断标志                */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x04</span>:                                                      <span class="comment">/*  接收数据中断                */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;                                        <span class="comment">/*  连续接收8个字节             */</span></span><br><span class="line">        GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">        GulNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0C</span>:                                                      <span class="comment">/*  字符超时中断                */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)&#123;                                 <span class="comment">/*  判断数据是否接收完毕        */</span></span><br><span class="line">        GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">        GulNum++;</span><br><span class="line">        <span class="keyword">if</span>(GulNum &gt;= <span class="number">128</span>)&#123;</span><br><span class="line">            GulNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GulNum; i++)&#123;</span><br><span class="line">            GucProcessBuf[i] = GucRcvBuf[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GucRcvfinishFlag = <span class="number">1</span>;</span><br><span class="line">        GucRcvLen = GulNum;</span><br><span class="line">        GulNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uartInit</span></span><br><span class="line"><span class="comment">** Descriptions:        串口初始化，设置为8位数据位，1位停止位，无奇偶校验，波特率为9600</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT16U ulFdiv;</span><br><span class="line"></span><br><span class="line">    U0LCR  = <span class="number">0x83</span>;                                                      <span class="comment">/*  允许设置波特率              */</span></span><br><span class="line">    ulFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;                                   <span class="comment">/*  设置波特率                  */</span></span><br><span class="line">    U0DLM  = ulFdiv / <span class="number">256</span>;</span><br><span class="line">    U0DLL  = ulFdiv % <span class="number">256</span>;</span><br><span class="line">    U0LCR  = <span class="number">0x03</span>;                                                      <span class="comment">/*  锁定波特率                  */</span></span><br><span class="line">    U0FCR  = <span class="number">0x87</span>;                                                      <span class="comment">/*  使能FIFO，设置8个字节触发点 */</span></span><br><span class="line">    U0IER  = <span class="number">0x01</span>;                                                      <span class="comment">/*  使能接收中断                */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendByte</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送子节数据，并等待数据发送完成，使用查询方式</span></span><br><span class="line"><span class="comment">** input parameters:    uiDat:   要发送的数据</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendByte</span> <span class="params">(INT8U ucDat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U0THR = ucDat;                                                      <span class="comment">/*  写入数据                    */</span></span><br><span class="line">    <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x20</span>) == <span class="number">0</span>);                                        <span class="comment">/*  等待数据发送完毕            */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendStr</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字符串</span></span><br><span class="line"><span class="comment">** input parameters:    pucStr:  要发送的字符串指针</span></span><br><span class="line"><span class="comment">**                      ulNum:   要发送的数据个数</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendStr</span> <span class="params">(INT8U <span class="keyword">const</span> *pucStr, INT32U ulNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ulNum; i++) &#123;                                       <span class="comment">/* 发送指定个字节数据            */</span></span><br><span class="line">        uart0SendByte(*pucStr++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        以中断方式接收上位机数据并将接收的数据回送给上位机。短接JP14,借助串口调试软件，</span></span><br><span class="line"><span class="comment">**                      并设置波特率为9600，8位数据位，1位停止位，注意不要选中"HEX显示"</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line"></span><br><span class="line">    uartInit ();                                                        <span class="comment">/* 串口初始化                   */</span></span><br><span class="line"></span><br><span class="line">    zyIsrSet(NVIC_UART0,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)uart0Isr,PRIO_ONE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (GucRcvfinishFlag == <span class="number">1</span>)&#123;                                     <span class="comment">/* 判断是否有新数据             */</span></span><br><span class="line">            GucRcvfinishFlag = <span class="number">0</span>;                                       <span class="comment">/* 清除标志                     */</span></span><br><span class="line">            uart0SendStr (GucRcvBuf, GucRcvLen);                        <span class="comment">/* 向串口发送数据               */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br></pre></td></tr></table></figure>
<h3 id="实验四与ADC简介"><a class="header-anchor" href="#实验四与ADC简介">¶</a>实验四与ADC简介</h3>
<h4 id="ADC简介"><a class="header-anchor" href="#ADC简介">¶</a>ADC简介</h4>
<p>LPC1700系列Cortex-M3具有1个12位的逐次逼近式的ADC，并可以根据应用进行灵活配置。可应用于工业现场的模拟信号到数字信号转换</p>
<p>ADC功能特性</p>
<ul>
<li>具有掉电模式；</li>
<li>12位转换时间达200KHz；</li>
<li>一个或多个输入的Burst模式；</li>
<li>可选由输入跳变或定时器匹配信号触发转换。</li>
<li>12 位主次逼近式模数转换器；</li>
<li>8 个引脚复用为 A/D 输入脚；</li>
<li>测量范围：0~VREFP（通常为 3V；不超过 VDDA）；</li>
</ul>
<div align=left><img width = '700' height ='350' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/29.PNG"/></div><br>
<div align=left><img width = '700' height ='350' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/30.PNG"/></div><br>
<h5 id="ADC-基本操作"><a class="header-anchor" href="#ADC-基本操作">¶</a>ADC 基本操作</h5>
<h6 id="引脚、电源配置"><a class="header-anchor" href="#引脚、电源配置">¶</a>引脚、电源配置</h6>
<p>电源控制：通过置位PCONP.PADC位使能ADC时钟源</p>
<p>引脚配置：当使用ADC的模拟引脚测量电压时，可不理会引脚在PINSEL寄存器中的设置，但是这样会影响测量精度。可通过选择AIN功能改善测量精度</p>
<div align=left><img width = '600' height ='300' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/31.PNG"/></div><br>
<h6 id="ADC初始化配置"><a class="header-anchor" href="#ADC初始化配置">¶</a>ADC初始化配置</h6>
<p>ADC的初始化主要通过写AD0CR配置ADC转换所需的时钟、工作模式、转换速率等完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PCONP  |= <span class="number">1</span> &lt;&lt; PADC;                    <span class="comment">// (1) 打开ADC功率控制位</span></span><br><span class="line">PISEL3 |= ((<span class="keyword">unsigned</span>)<span class="number">0x03</span>) &lt;&lt; <span class="number">30</span>;       <span class="comment">// (2) 配置引脚为AIN功能</span></span><br><span class="line">AD0CR = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)                        <span class="comment">// (3) 设置转换通道，通道5</span></span><br><span class="line">        |  ((Fpclk/<span class="number">1000000</span><span class="number">-1</span>) &lt;&lt; <span class="number">8</span>)     <span class="comment">// (4) 设置转换时钟，1MHz</span></span><br><span class="line">        |  (<span class="number">0</span> &lt;&lt; <span class="number">16</span>)                    <span class="comment">// (5) 设置转换模式，软件模式</span></span><br><span class="line">        |  (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)                    <span class="comment">// (6) 设置工作模式，正常</span></span><br><span class="line">        |  (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);                   <span class="comment">// (7) 设置启动方式，直接启动</span></span><br></pre></td></tr></table></figure>
<p>参考 ADxCR 寄存器</p>
<div align=left><img width = '700' height ='250' src ="http://cloudplayer99.oss-cn-beijing.aliyuncs.com/blog_pic/LPC1768/32.PNG"/></div><br>
<h6 id="ADC转换结果处理"><a class="header-anchor" href="#ADC转换结果处理">¶</a>ADC转换结果处理</h6>
<p>A/D转换完成后，转换结果保存在ADDRx和AD0GDR中。但该结果只是转换后的数字量，必须进行转换。假定要读取通道x的电压值，A/D的参考电压为VREF</p>
<p>则实际转换结果为：$实际电压 = \dfrac{ADDRx \times V_{REF}}{4096}$</p>
<p>转换参考代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ulADCbuf = ADDRx;</span><br><span class="line">ulADCbuf = (ulADCbuf &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xfff</span>;</span><br><span class="line">ulADCData = (ulADCData * Vref)/<span class="number">4096</span>;</span><br></pre></td></tr></table></figure>
<h5 id="实验四-ADC-初始化函数"><a class="header-anchor" href="#实验四-ADC-初始化函数">¶</a>实验四 ADC 初始化函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adcInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U ulTemp;</span><br><span class="line">    ulTemp = (<span class="number">24000000</span> / (<span class="number">13000000</span>));</span><br><span class="line">    ulTemp = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)                                                   <span class="comment">/* 选择AD0.1为AD输入引脚        */</span></span><br><span class="line">           |((ulTemp) &lt;&lt; <span class="number">8</span>)                                             <span class="comment">/* 转换时钟为13MHz              */</span></span><br><span class="line">           |(<span class="number">0</span> &lt;&lt; <span class="number">16</span>)                                                   <span class="comment">/* BURST = 0,软件控制转换操作   */</span></span><br><span class="line">           |(<span class="number">1</span> &lt;&lt; <span class="number">21</span>)                                                   <span class="comment">/* PDN = 1，正常工作模式        */</span></span><br><span class="line">           |(<span class="number">1</span> &lt;&lt; <span class="number">24</span>)                                                   <span class="comment">/* 设置直接启动模式             */</span></span><br><span class="line">    AD0CR  = ulTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实验四完整代码-main-c"><a class="header-anchor" href="#实验四完整代码-main-c">¶</a>实验四完整代码(main.c)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  宏定义</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BPS        9600                                            <span class="comment">/* 串口通信波特率               */</span></span></span><br><span class="line"><span class="keyword">char</span>    GcRcvBuf[<span class="number">20</span>];                                                   <span class="comment">/* AD采集到的数据               */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       myDelay</span></span><br><span class="line"><span class="comment">** Descriptions:        软件延时</span></span><br><span class="line"><span class="comment">** input parameters:    ulTime</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDelay</span> <span class="params">(INT32U ulTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ulTime--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0Init</span></span><br><span class="line"><span class="comment">** Descriptions:        按默认值初始化串口0的引脚和通讯参数。设置为8位数据位，1位停止位，无奇偶校验</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0Init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT16U usFdiv;</span><br><span class="line"></span><br><span class="line">    U0LCR  = <span class="number">0x83</span>;                                                      <span class="comment">/* 允许设置波特率               */</span></span><br><span class="line">    usFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;                                   <span class="comment">/* 设置波特率                   */</span></span><br><span class="line">    U0DLM  = usFdiv / <span class="number">256</span>;</span><br><span class="line">    U0DLL  = usFdiv % <span class="number">256</span>;</span><br><span class="line">    U0LCR  = <span class="number">0x03</span>;                                                      <span class="comment">/* 锁定波特率                   */</span></span><br><span class="line">    U0FCR  = <span class="number">0x06</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendByte</span></span><br><span class="line"><span class="comment">** Descriptions:        从串口0发送数据</span></span><br><span class="line"><span class="comment">** input parameters:    data: 发送的数据</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendByte</span> <span class="params">(INT8U ucData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U0THR   = ucData;</span><br><span class="line">    <span class="keyword">while</span> ( (U0LSR &amp; <span class="number">0x40</span>) == <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendStr</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字符串</span></span><br><span class="line"><span class="comment">** input parameters:    pucStr:  要发送的字符串指针</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendStr</span> <span class="params">(INT8U  <span class="keyword">const</span> *pucStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pucStr == <span class="string">'\0'</span>)<span class="keyword">break</span>;                                      <span class="comment">/* 遇到结束符，退出             */</span></span><br><span class="line">        uart0SendByte (*pucStr++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function name:        adcInit</span></span><br><span class="line"><span class="comment">* Descriptions:         ADC初始化</span></span><br><span class="line"><span class="comment">* input parameters:     无</span></span><br><span class="line"><span class="comment">* output parameters:    无</span></span><br><span class="line"><span class="comment">* Returned value:       无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adcInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U ulTemp;</span><br><span class="line">    ulTemp = (<span class="number">24000000</span> / (<span class="number">13000000</span>));</span><br><span class="line">    ulTemp = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)                                                   <span class="comment">/* 选择AD0.1为AD输入引脚        */</span></span><br><span class="line">           |((ulTemp) &lt;&lt; <span class="number">8</span>)                                             <span class="comment">/* 转换时钟为13MHz              */</span></span><br><span class="line">           |(<span class="number">0</span> &lt;&lt; <span class="number">16</span>)                                                   <span class="comment">/* BURST = 0,软件控制转换操作   */</span></span><br><span class="line">           |(<span class="number">1</span> &lt;&lt; <span class="number">21</span>)                                                   <span class="comment">/* PDN = 1，正常工作模式        */</span></span><br><span class="line">           |(<span class="number">1</span> &lt;&lt; <span class="number">24</span>)                                                   <span class="comment">/* 设置直接启动模式             */</span></span><br><span class="line">    AD0CR  = ulTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        AD采集数据例程，需将跳线一端连到JP22的P0.24脚，另一端连接待测电压端。同时将PC机的</span></span><br><span class="line"><span class="comment">**                      串口线连接到开发板UART0，然后短接JP14跳线组，打开Easyarm串口调试软件，观察采样结果</span></span><br><span class="line"><span class="comment">**                      注意：由于AD参考电压是3.0V，若直接采用P0.23采集电压，电压不得高于3.0V。若经过开发板</span></span><br><span class="line"><span class="comment">**                      的采集电路后，JP16端输入电压范围为-5V~+5V</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> INT32U ulADCbuf;                                                <span class="comment">/* AD采集数据缓冲区             */</span></span><br><span class="line">    <span class="keyword">static</span> INT32U ulADCData;</span><br><span class="line">    <span class="keyword">static</span> INT8U i;</span><br><span class="line"></span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line"></span><br><span class="line">    uart0Init();</span><br><span class="line"></span><br><span class="line">    PCONP |= <span class="number">1</span> &lt;&lt; <span class="number">12</span>;                                                   <span class="comment">/* 打开ADC电源                  */</span></span><br><span class="line">    adcInit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ulADCData = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            AD0CR |= <span class="number">1</span> &lt;&lt; <span class="number">24</span>;                                           <span class="comment">/* 立即转换                     */</span></span><br><span class="line">            <span class="keyword">while</span> ((ADSTAT &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) == <span class="number">0</span>);                           <span class="comment">/* 读取AD0STAT的通道1的Done     */</span></span><br><span class="line">            AD0CR |= (<span class="number">1</span> &lt;&lt;<span class="number">24</span>);                                          <span class="comment">/* 第一次转换结果丢弃           */</span></span><br><span class="line">            <span class="keyword">while</span> ((ADSTAT &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) == <span class="number">0</span>);                           <span class="comment">/* 读取AD0STAT的通道1的Done     */</span></span><br><span class="line">            ulADCbuf = ADDR1;                                           <span class="comment">/* 只有一路，则读取全局寄存器   */</span></span><br><span class="line">            ulADCbuf = (ulADCbuf &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xfff</span>;</span><br><span class="line">            ulADCData += ulADCbuf;</span><br><span class="line">       &#125;</span><br><span class="line">        ulADCData = (ulADCData/<span class="number">8</span>);                                      <span class="comment">/* 采样8次进行滤波处理          */</span></span><br><span class="line">        ulADCData = (ulADCData*<span class="number">3300</span>)/<span class="number">4096</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(GcRcvBuf,<span class="string">"VIN1 = %4d mv"</span>,ulADCData);</span><br><span class="line">        uart0SendStr(GcRcvBuf);</span><br><span class="line"></span><br><span class="line">        myDelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br></pre></td></tr></table></figure>
<hr>
<h1>附录</h1>
<h2 id="LPC1700-系列概述"><a class="header-anchor" href="#LPC1700-系列概述">¶</a>LPC1700 系列概述</h2>
<p>以下内容摘自《LPC1700 用户手册 - 广州周立功单片机发展有限公司》</p>
<h3 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h3>
<p>LPC1700 系列 Cortex-M3 微控制器用于处理要求高度集成和低功耗的嵌入式应用。ARM Cortex-M3 是下一代新生内核，它可提供系统增强型特性，例如现代化调试特性和支持更高级别的块集成。</p>
<p>LPC1700 系列 Cortex-M3 微控制器的操作频率可达 100MHz。ARM Cortex-M3 CPU 具有 3 级流水线和哈佛结构，带独立的本地指令和数据总线以及用于外设的稍微低性能的第三条总线。ARM Cortex-M3 CPU 还包含一个支持随机跳转的内部预取指单元。</p>
<p>LPC1700 系列 Cortex-M3 微控制器的外设组件包含高达 512KB 的 Flash 存储器、64KB 的数据存储器、以太网 MAC、USB 主机/从机/OTG 接口、8 通道的通用 DMA 控制器、4 个 UART、 2 条 CAN 通道、2 个 SSP 控制器、SPI 接口、3 个 I2C 接口、2-输入和 2-输出的 I2S 接口、8 通道的 12 位 ADC、10 位 DAC、电机控制 PWM、正交编码器接口、4 个通用定时器、6-输出的通用 PWM、带独立电池供电的超低功耗 RTC 和多达 70 个的通用 I/O 管脚。</p>
<h3 id="特性"><a class="header-anchor" href="#特性">¶</a>特性</h3>
<ul>
<li>ARM Cortex-M3 处理器，可在高至 100MHz 的频率下运行，并包含一个支持 8 个区的存储器保护单元（MPU）；</li>
<li>ARM Cortex-M3 内置了嵌套的向量中断控制器（NVIC）；</li>
<li>具有在系统编程（ISP）和在应用编程（IAP）功能的 512KB 片上 Flash 程序存储器。把增强型的 Flash 存储加速器和 Flash 存储器在 CPU 本地代码/数据总线上的位置进行整合，则 Flash 可提供高性能的代码；</li>
<li>64KB 片内 SRAM 包括：
<ul>
<li>32KB SRAM 可供高性能 CPU 通过本地代码/数据总线访问；</li>
<li>2 个 16KB SRAM 模块，带独立访问路径，可进行更高吞量的操作。这些 SRAM 模块可用于以太网、USB、DMA 存储器，以及通用指令和数据存储；</li>
</ul>
</li>
<li>AHB 多层矩阵上具有 8 通道的通用 DMA 控制器，它可结合 SSP、I2S、UART、模数和数模转换器外设、定时器匹配信号和 GPIO 使用，并可用于存储器到存储器的传输；</li>
<li>多层 AHB 矩阵内部连接，为每个 AHB 主机提供独立的总线。AHB 主机包括 CPU、通用 DMA 控制器、以太网 MAC 和 USB 接口。这个内部连接特性提供无仲裁延迟的通信，除非 2 个主机尝试同时访问同一个从机；</li>
<li>分离的 APB 总线允许在 CPU 和 DMA 之间提供更多的带宽，更少的延迟。CPU 无须等待 APB 写操作完成；</li>
<li>串行接口
<ul>
<li>以太网 MAC 带 RMII 接口和相关的 DMA 控制器；</li>
<li>USB 2.0 全速从机/主机/OTG 控制器，带有用于从机、主机功能的片内 PHY 和相关的 DMA 控制器；</li>
<li>4 个 UART，带小数波特率发生功能、内部 FIFO、DMA 支持和 RS-485 支持。1 个 UART 带有 modem 控制 I/O 并支持 RS-485/EIA-485，全部的 UART 都支持 IrDA；</li>
<li>CAN 控制器，带 2 个通道；</li>
<li>SPI 控制器，具有同步、串行、全双工通信和可编程的数据长度；</li>
<li>2 个 SSP 控制器，带有 FIFO，可按多种协议进行通信。其中一个可选择用于 SPI，并且和 SPI 共用中断。SSP 接口可以与 GPDMA 控制器一起使用；</li>
<li>3 个增强型的 I2C 总线接口，其中 1 个具有开漏输出功能，支持整个 I2C 规范和数据速率为 1Mbit/s 的快速模式，另外 2 个具有标准的端口管脚。增强型特性包括多个地址识别功能和监控模式；</li>
<li>I2S（Inter-IC Sound）接口，用于数字音频输入或输出，具有小数速率控制功能。I2S接口可与 GPDMA 一起使用。I2S 接口支持 3-线的数据发送和接收或 4-线的组合发送和接收连接，以及主机时钟输入/输出；</li>
</ul>
</li>
<li>其它外设：
<ul>
<li>70 个（100 个管脚封装）通用 I/O（GPIO）管脚，带可配置的上拉/下拉电阻。AHB总线上的所有 GPIO 可进行快速访问，支持新的、可配置的开漏操作模式；GPIO 位于存储器中，它支持 Cortex-M3 位带宽并且由通用 DMA 控制器使用；</li>
<li>12 位模数转换器（ADC），可在 8 个管脚间实现多路输入，转换速率高达 1MHz，并具有多个结果寄存器。12 位 ADC 可与 GPDMA 控制器一起使用；</li>
<li>10 位数模转换器（DAC），具有专用的转换定时器，并支持 DMA 操作；</li>
<li>4 个通用定时/计数器，共有 8 个捕获输入和 10 个比较输出。每个定时器模块都具有一个外部计数输入。可选择特定的定时器事件来产生 DMA 请求；</li>
<li>1 个电机控制 PWM，支持三相的电机控制；</li>
<li>正交编码器接口，可监控一个外部正交编码器；</li>
<li>1 个标准的 PWM/定时器模块，带外部计数输入；</li>
<li>实时时钟（RTC）带有独立的电源域。RTC 通过专用的 RTC 振荡器来驱动。RTC模块包括 20 字节电池供电的备用寄存器，当芯片的其它部分掉电时允许系统状态存储在该寄存器中。电池电源可由标准的 3V 锂电池供电。当电池电压掉至 2.1V 的低电压时，RTC 仍将会继续工作。RTC 中断可将 CPU 从任何低功率模式中唤醒；</li>
<li>看门狗定时器（WDT），该定时器的时钟源可在内部 RC 振荡器、RTC 振荡器或 APB时钟三者间进行选择；</li>
<li>支持 ARM Cortex-M3 系统节拍定时器，包括外部时钟输入选项；</li>
<li>重复性的中断定时器提供可编程和重复定时的中断；</li>
</ul>
</li>
<li>标准 JTAG 测试/调试接口以及串行线调试和串行线跟踪端口选项；</li>
<li>仿真跟踪模块支持实时跟踪；</li>
<li>4 个低功率模式：睡眠、深度睡眠、掉电、深度掉电；</li>
<li>单个 3.3V 电源（2.4V – 3.6V）。温度范围为-40°C - 85°C；</li>
<li>4 个外部中断输入，可配置为边沿/电平触发。PORT0 和 PORT2 上的所有管脚都可用作边沿触发的中断源；</li>
<li>不可屏蔽中断（NMI）输入；</li>
<li>时钟输出功能，可反映主振荡器时钟、IRC 时钟、RTC 时钟、CPU 时钟或 USB 时钟的输出状态；</li>
<li>当处于掉电模式时，可通过中断（包括外部中断、RTC 中断、USB 活动中断、以太网唤醒中断、CAN 总线活动中断、PORT0/2 管脚中断和 NMI）将处理器从掉电模式中唤醒；</li>
<li>每个外设都自带时钟分频器，以进一步节省功耗；</li>
<li>带掉电检测功能，可对掉电中断和强制复位分别设置阀值；</li>
<li>片内有上电复位电路；</li>
<li>片内晶振工作频率为 1MHz 到 24MHz；</li>
<li>4MHz 内部 RC 振荡器可在±1%的精度内调整，可选择用作系统时钟；</li>
<li>通过片内 PLL，没有高频晶振，CPU 也可以最高频率运转。用户可从主振荡器、内部 RC 振荡器或 RTC 振荡器三者中选择一个作为 PLL 时钟源；</li>
<li>第二个专用的 PLL 可用于 USB 接口，以允许增加主 PLL 设置的灵活性；</li>
<li>用户可在管脚对应的多种功能中进行选择；</li>
<li>可采用 100 脚和 80 脚 LQFP 封装（14×14×1.4mm）。</li>
</ul>
<h2 id="完整实验程序-main-c-文件"><a class="header-anchor" href="#完整实验程序-main-c-文件">¶</a>完整实验程序(main.c 文件)</h2>
<h3 id="实验一、GPIO例程之跑马灯"><a class="header-anchor" href="#实验一、GPIO例程之跑马灯">¶</a>实验一、GPIO例程之跑马灯</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 变量宏定义 ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0        (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_OFF()   FIO0SET |= LED0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_ON()    FIO0CLR |= LED0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1        (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_OFF()   FIO0SET |= LED1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_ON()    FIO0CLR |= LED1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2        (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_OFF()   FIO0SET |= LED2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_ON()    FIO0CLR |= LED2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_OFF()   FIO0SET |= LED3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_ON()    FIO0CLR |= LED3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">** Function name:       myDelay</span></span><br><span class="line"><span class="comment">** Descriptions:        软件延时</span></span><br><span class="line"><span class="comment">** input parameters:    ulTime</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDelay</span> <span class="params">(INT32U  ulTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ulTime--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    targetInit();                   <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                      <span class="comment">/* 引脚初始化                  */</span></span><br><span class="line">  </span><br><span class="line">    FIO0DIR |= LED0 + LED1 + LED2 + LED3;</span><br><span class="line"></span><br><span class="line">    LED0_OFF();</span><br><span class="line">    LED1_OFF();</span><br><span class="line">    LED2_OFF();</span><br><span class="line">    LED3_OFF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: LED0_ON();myDelay(<span class="number">50</span>);LED0_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: LED1_ON();myDelay(<span class="number">50</span>);LED1_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: LED2_ON();myDelay(<span class="number">50</span>);LED2_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: LED3_ON();myDelay(<span class="number">50</span>);LED3_OFF();myDelay(<span class="number">50</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">3</span>) i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验二、定时器例程之跑马灯"><a class="header-anchor" href="#实验二、定时器例程之跑马灯">¶</a>实验二、定时器例程之跑马灯</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************* 变量与宏定义 ************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0        (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_OFF()   FIO0SET |= LED0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0_ON()    FIO0CLR |= LED0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1        (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_OFF()   FIO0SET |= LED1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1_ON()    FIO0CLR |= LED1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2        (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_OFF()   FIO0SET |= LED2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED2_ON()    FIO0CLR |= LED2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3        (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_OFF()   FIO0SET |= LED3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED3_ON()    FIO0CLR |= LED3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name:        timer0Isr</span></span><br><span class="line"><span class="comment">* Description:          TIMER0 中断处理函数</span></span><br><span class="line"><span class="comment">* Input:                无</span></span><br><span class="line"><span class="comment">* Output:               无</span></span><br><span class="line"><span class="comment">* Return:               无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T0IR         = <span class="number">0x01</span>;                            <span class="comment">/* 清除中断标志                */</span>  </span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       timer0Init</span></span><br><span class="line"><span class="comment">** Descriptions:        定时器0初始化程序</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer0Init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T0TCR  = <span class="number">0x02</span>;</span><br><span class="line">    T0IR   = <span class="number">1</span>;</span><br><span class="line">    T0CTCR = <span class="number">0</span>;</span><br><span class="line">    T0TC   = <span class="number">0</span>;</span><br><span class="line">    T0PR   = <span class="number">0</span>;</span><br><span class="line">    T0MR0  = FPCLK / <span class="number">2</span>;                                                 <span class="comment">/* 定时 0.5 秒                 */</span></span><br><span class="line">    T0MCR  = <span class="number">0x03</span>;                                                      <span class="comment">/* 匹配后产生中断               */</span></span><br><span class="line">    zyIsrSet(NVIC_TIMER0, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)timer0Isr, PRIO_TWO);          <span class="comment">/* 设置中断并使能               */</span></span><br><span class="line">    T0TCR  = <span class="number">0x01</span>;                                                      <span class="comment">/* 启动定时器                   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        定时器0中断实验。每1秒产生中断</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line">    timer0Init();                                                       <span class="comment">/* 定时器0初始化                */</span></span><br><span class="line"></span><br><span class="line">    FIO0DIR |= LED0 + LED1 + LED2 + LED3;</span><br><span class="line"></span><br><span class="line">    LED0_OFF();</span><br><span class="line">    LED1_OFF();</span><br><span class="line">    LED2_OFF();</span><br><span class="line">    LED3_OFF();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">1</span>)&#123; LED3_OFF(); LED0_ON(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>)&#123; LED0_OFF(); LED1_ON(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span>)&#123; LED1_OFF(); LED2_ON(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">4</span>)&#123; LED2_OFF(); LED3_ON(); &#125;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">4</span>) x=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************* End Of File **********************************************/</span></span><br></pre></td></tr></table></figure>
<h3 id="实验三、UART串口"><a class="header-anchor" href="#实验三、UART串口">¶</a>实验三、UART串口</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BPS             9600                                       <span class="comment">/* 串口通信波特率               */</span></span></span><br><span class="line"><span class="keyword">volatile</span>        INT8U        GucRcvNew;                                 <span class="comment">/* 串口接收新数据的标志         */</span></span><br><span class="line">INT8U           GucRcvBuf[<span class="number">128</span>];                                         <span class="comment">/* 串口接收数据缓冲区           */</span></span><br><span class="line">INT32U          GulNum = <span class="number">0</span>;                                             <span class="comment">/* 串口接收数据的个数           */</span></span><br><span class="line">INT32U          GucRcvLen;</span><br><span class="line">INT8U           GucProcessBuf[<span class="number">128</span>];</span><br><span class="line">INT8U           GucRcvfinishFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       delayNS</span></span><br><span class="line"><span class="comment">** Descriptions:        延时函数</span></span><br><span class="line"><span class="comment">** input parameters:    uiDly:   值越大，延时时间越长</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayNS</span> <span class="params">(INT32U ulDly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line">    <span class="keyword">for</span> (; ulDly &gt; <span class="number">0</span>; ulDly--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function Name:        uart0Isr</span></span><br><span class="line"><span class="comment">* Description:          UART0 中断处理函数</span></span><br><span class="line"><span class="comment">* Input:                None</span></span><br><span class="line"><span class="comment">* Output:               None</span></span><br><span class="line"><span class="comment">* Return:               None</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0Isr</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT8U i;</span><br><span class="line">    <span class="keyword">while</span> ((U0IIR &amp; <span class="number">0x01</span>) == <span class="number">0</span>)&#123;                                        <span class="comment">/*  判断是否有中断挂起          */</span></span><br><span class="line">        <span class="keyword">switch</span> (U0IIR &amp; <span class="number">0x0E</span>)&#123;                                          <span class="comment">/*  判断中断标志                */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x04</span>:                                                      <span class="comment">/*  接收数据中断                */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;                                        <span class="comment">/*  连续接收8个字节             */</span></span><br><span class="line">        GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">        GulNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0C</span>:                                                      <span class="comment">/*  字符超时中断                */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)&#123;                                 <span class="comment">/*  判断数据是否接收完毕        */</span></span><br><span class="line">        GucRcvBuf[GulNum] = U0RBR;</span><br><span class="line">        GulNum++;</span><br><span class="line">        <span class="keyword">if</span>(GulNum &gt;= <span class="number">128</span>)&#123;</span><br><span class="line">            GulNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GulNum; i++)&#123;</span><br><span class="line">            GucProcessBuf[i] = GucRcvBuf[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GucRcvfinishFlag = <span class="number">1</span>;</span><br><span class="line">        GucRcvLen = GulNum;</span><br><span class="line">        GulNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uartInit</span></span><br><span class="line"><span class="comment">** Descriptions:        串口初始化，设置为8位数据位，1位停止位，无奇偶校验，波特率为9600</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uartInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT16U ulFdiv;</span><br><span class="line"></span><br><span class="line">    U0LCR  = <span class="number">0x83</span>;                                                      <span class="comment">/*  允许设置波特率              */</span></span><br><span class="line">    ulFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;                                   <span class="comment">/*  设置波特率                  */</span></span><br><span class="line">    U0DLM  = ulFdiv / <span class="number">256</span>;</span><br><span class="line">    U0DLL  = ulFdiv % <span class="number">256</span>;</span><br><span class="line">    U0LCR  = <span class="number">0x03</span>;                                                      <span class="comment">/*  锁定波特率                  */</span></span><br><span class="line">    U0FCR  = <span class="number">0x87</span>;                                                      <span class="comment">/*  使能FIFO，设置8个字节触发点 */</span></span><br><span class="line">    U0IER  = <span class="number">0x01</span>;                                                      <span class="comment">/*  使能接收中断                */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendByte</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送子节数据，并等待数据发送完成，使用查询方式</span></span><br><span class="line"><span class="comment">** input parameters:    uiDat:   要发送的数据</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendByte</span> <span class="params">(INT8U ucDat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U0THR = ucDat;                                                      <span class="comment">/*  写入数据                    */</span></span><br><span class="line">    <span class="keyword">while</span> ((U0LSR &amp; <span class="number">0x20</span>) == <span class="number">0</span>);                                        <span class="comment">/*  等待数据发送完毕            */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendStr</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字符串</span></span><br><span class="line"><span class="comment">** input parameters:    pucStr:  要发送的字符串指针</span></span><br><span class="line"><span class="comment">**                      ulNum:   要发送的数据个数</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendStr</span> <span class="params">(INT8U <span class="keyword">const</span> *pucStr, INT32U ulNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ulNum; i++) &#123;                                       <span class="comment">/* 发送指定个字节数据            */</span></span><br><span class="line">        uart0SendByte(*pucStr++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        以中断方式接收上位机数据并将接收的数据回送给上位机。短接JP14,借助串口调试软件，</span></span><br><span class="line"><span class="comment">**                      并设置波特率为9600，8位数据位，1位停止位，注意不要选中"HEX显示"</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line"></span><br><span class="line">    uartInit ();                                                        <span class="comment">/* 串口初始化                   */</span></span><br><span class="line"></span><br><span class="line">    zyIsrSet(NVIC_UART0,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)uart0Isr,PRIO_ONE);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (GucRcvfinishFlag == <span class="number">1</span>)&#123;                                     <span class="comment">/* 判断是否有新数据             */</span></span><br><span class="line">            GucRcvfinishFlag = <span class="number">0</span>;                                       <span class="comment">/* 清除标志                     */</span></span><br><span class="line">            uart0SendStr (GucRcvBuf, GucRcvLen);                        <span class="comment">/* 向串口发送数据               */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br></pre></td></tr></table></figure>
<h3 id="实验四、ADC实验"><a class="header-anchor" href="#实验四、ADC实验">¶</a>实验四、ADC实验</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\config.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  宏定义</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_BPS        9600                                            <span class="comment">/* 串口通信波特率               */</span></span></span><br><span class="line"><span class="keyword">char</span>    GcRcvBuf[<span class="number">20</span>];                                                   <span class="comment">/* AD采集到的数据               */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       myDelay</span></span><br><span class="line"><span class="comment">** Descriptions:        软件延时</span></span><br><span class="line"><span class="comment">** input parameters:    ulTime</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myDelay</span> <span class="params">(INT32U ulTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U i;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ulTime--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0Init</span></span><br><span class="line"><span class="comment">** Descriptions:        按默认值初始化串口0的引脚和通讯参数。设置为8位数据位，1位停止位，无奇偶校验</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0Init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT16U usFdiv;</span><br><span class="line"></span><br><span class="line">    U0LCR  = <span class="number">0x83</span>;                                                      <span class="comment">/* 允许设置波特率               */</span></span><br><span class="line">    usFdiv = (FPCLK / <span class="number">16</span>) / UART_BPS;                                   <span class="comment">/* 设置波特率                   */</span></span><br><span class="line">    U0DLM  = usFdiv / <span class="number">256</span>;</span><br><span class="line">    U0DLL  = usFdiv % <span class="number">256</span>;</span><br><span class="line">    U0LCR  = <span class="number">0x03</span>;                                                      <span class="comment">/* 锁定波特率                   */</span></span><br><span class="line">    U0FCR  = <span class="number">0x06</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendByte</span></span><br><span class="line"><span class="comment">** Descriptions:        从串口0发送数据</span></span><br><span class="line"><span class="comment">** input parameters:    data: 发送的数据</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendByte</span> <span class="params">(INT8U ucData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U0THR   = ucData;</span><br><span class="line">    <span class="keyword">while</span> ( (U0LSR &amp; <span class="number">0x40</span>) == <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       uart0SendStr</span></span><br><span class="line"><span class="comment">** Descriptions:        向串口发送字符串</span></span><br><span class="line"><span class="comment">** input parameters:    pucStr:  要发送的字符串指针</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart0SendStr</span> <span class="params">(INT8U  <span class="keyword">const</span> *pucStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pucStr == <span class="string">'\0'</span>)<span class="keyword">break</span>;                                      <span class="comment">/* 遇到结束符，退出             */</span></span><br><span class="line">        uart0SendByte (*pucStr++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">* Function name:        adcInit</span></span><br><span class="line"><span class="comment">* Descriptions:         ADC初始化</span></span><br><span class="line"><span class="comment">* input parameters:     无</span></span><br><span class="line"><span class="comment">* output parameters:    无</span></span><br><span class="line"><span class="comment">* Returned value:       无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adcInit</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT32U ulTemp;</span><br><span class="line">    ulTemp = (<span class="number">24000000</span> / (<span class="number">13000000</span>));</span><br><span class="line">    ulTemp = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)                                                   <span class="comment">/* 选择AD0.1为AD输入引脚        */</span></span><br><span class="line">           |((ulTemp) &lt;&lt; <span class="number">8</span>)                                             <span class="comment">/* 转换时钟为13MHz              */</span></span><br><span class="line">           |(<span class="number">0</span> &lt;&lt; <span class="number">16</span>)                                                   <span class="comment">/* BURST = 0,软件控制转换操作   */</span></span><br><span class="line">           |(<span class="number">1</span> &lt;&lt; <span class="number">21</span>)                                                   <span class="comment">/* PDN = 1，正常工作模式        */</span></span><br><span class="line">           |(<span class="number">1</span> &lt;&lt; <span class="number">24</span>)                                                   <span class="comment">/* 设置直接启动模式             */</span></span><br><span class="line">           |(<span class="number">0</span> &lt;&lt; <span class="number">27</span> );                                                 <span class="comment">/* 设置模式，直接启动模式下无效 */</span></span><br><span class="line">    AD0CR  = ulTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">** Function name:       main</span></span><br><span class="line"><span class="comment">** Descriptions:        AD采集数据例程，需将跳线一端连到JP22的P0.24脚，另一端连接待测电压端。同时将PC机的</span></span><br><span class="line"><span class="comment">**                      串口线连接到开发板UART0，然后短接JP14跳线组，打开Easyarm串口调试软件，观察采样结果</span></span><br><span class="line"><span class="comment">**                      注意：由于AD参考电压是3.0V，若直接采用P0.23采集电压，电压不得高于3.0V。若经过开发板</span></span><br><span class="line"><span class="comment">**                      的采集电路后，JP16端输入电压范围为-5V~+5V</span></span><br><span class="line"><span class="comment">** input parameters:    无</span></span><br><span class="line"><span class="comment">** output parameters:   无</span></span><br><span class="line"><span class="comment">** Returned value:      无</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> INT32U ulADCbuf;                                                <span class="comment">/* AD采集数据缓冲区             */</span></span><br><span class="line">    <span class="keyword">static</span> INT32U ulADCData;</span><br><span class="line">    <span class="keyword">static</span> INT8U i;</span><br><span class="line"></span><br><span class="line">    targetInit();                                                       <span class="comment">/* 初始化目标板，切勿删除       */</span></span><br><span class="line">    pinInit();                                                          <span class="comment">/* 引脚初始化                   */</span></span><br><span class="line"></span><br><span class="line">    uart0Init();</span><br><span class="line"></span><br><span class="line">    PCONP |= <span class="number">1</span> &lt;&lt; <span class="number">12</span>;                                                   <span class="comment">/* 打开ADC电源                  */</span></span><br><span class="line">    adcInit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ulADCData = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            AD0CR |= <span class="number">1</span> &lt;&lt; <span class="number">24</span>;                                           <span class="comment">/* 立即转换                     */</span></span><br><span class="line">            <span class="keyword">while</span> ((ADSTAT &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) == <span class="number">0</span>);                           <span class="comment">/* 读取AD0STAT的通道1的Done     */</span></span><br><span class="line">            AD0CR |= (<span class="number">1</span> &lt;&lt;<span class="number">24</span>);                                          <span class="comment">/* 第一次转换结果丢弃           */</span></span><br><span class="line">            <span class="keyword">while</span> ((ADSTAT &amp; (<span class="number">1</span> &lt;&lt; <span class="number">1</span>)) == <span class="number">0</span>);                           <span class="comment">/* 读取AD0STAT的通道1的Done     */</span></span><br><span class="line">            ulADCbuf = ADDR1;                                           <span class="comment">/* 只有一路，则读取全局寄存器   */</span></span><br><span class="line">            ulADCbuf = (ulADCbuf &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xfff</span>;</span><br><span class="line">            ulADCData += ulADCbuf;</span><br><span class="line">       &#125;</span><br><span class="line">        ulADCData = (ulADCData/<span class="number">8</span>);                                      <span class="comment">/* 采样8次进行滤波处理          */</span></span><br><span class="line">        ulADCData = (ulADCData*<span class="number">3300</span>)/<span class="number">4096</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(GcRcvBuf,<span class="string">"VIN1 = %4d mv"</span>,ulADCData);</span><br><span class="line">        uart0SendStr(GcRcvBuf);</span><br><span class="line"></span><br><span class="line">        myDelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">*********************************************************************************************************/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DIGITAL</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
</search>
